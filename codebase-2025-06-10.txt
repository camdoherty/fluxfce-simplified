
##############
fluxfce_cli.py

#!/usr/bin/env python3

"""
fluxfce (CLI) - Simplified XFCE Theming Tool (Systemd Timer Version)

Command-line interface for managing automatic XFCE theme/background/screen
switching based on sunrise/sunset times using the fluxfce_core library.
This version uses systemd timers for scheduling.
"""

import argparse
import logging
import pathlib
import shutil
import subprocess
import sys
from datetime import datetime

# Import the refactored core library API and exceptions
try:
    import fluxfce_core
    from fluxfce_core import exceptions as core_exc
    from fluxfce_core import (
        SCHEDULER_TIMER_NAME, SCHEDULER_SERVICE_NAME,
        LOGIN_SERVICE_NAME, RESUME_SERVICE_NAME
    )
    from fluxfce_core import config as core_config
    from fluxfce_core import install_default_background_profiles
except ImportError as e:
    print(f"Error: Failed to import the fluxfce_core library: {e}", file=sys.stderr)
    print("Ensure fluxfce_core is installed or available in your Python path.", file=sys.stderr)
    sys.exit(1)

# --- Global Variables ---
SCRIPT_DIR = pathlib.Path(__file__).resolve().parent
SCRIPT_PATH = str(pathlib.Path(__file__).resolve())
PYTHON_EXECUTABLE = sys.executable
DEPENDENCY_CHECKER_SCRIPT_NAME = "fluxfce_deps_check.py"

log = logging.getLogger("fluxfce_cli")

# --- ANSI Color Codes for Terminal Output ---
# Check if stdout is a TTY (interactive terminal) to decide whether to use colors.
IS_TTY = sys.stdout.isatty()

class AnsiColors:
    GREEN = "\033[92m" if IS_TTY else ""
    RED = "\033[91m" if IS_TTY else ""
    YELLOW = "\033[93m" if IS_TTY else ""
    RESET = "\033[0m" if IS_TTY else ""


# --- CLI Logging Setup ---
def setup_cli_logging(verbose: bool):
    """Configures logging for the CLI based on verbosity."""
    cli_log_level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(level=logging.WARNING, format="%(levelname)s: %(name)s: %(message)s")

    log.setLevel(cli_log_level)
    if log.hasHandlers():
        log.handlers.clear()

    core_log_level = logging.DEBUG if verbose else logging.WARNING
    core_logger = logging.getLogger("fluxfce_core")
    core_logger.setLevel(core_log_level)
    if not core_logger.hasHandlers():
        core_handler = logging.StreamHandler(sys.stderr)
        core_formatter = logging.Formatter("%(levelname)s: fluxfce_core: %(message)s")
        core_handler.setFormatter(core_formatter)
        core_logger.addHandler(core_handler)
        core_logger.propagate = False

    if cli_log_level <= logging.INFO:
        info_handler = logging.StreamHandler(sys.stdout)
        info_formatter = logging.Formatter("%(message)s")
        info_handler.setFormatter(info_formatter)
        info_handler.setLevel(logging.INFO)
        info_handler.addFilter(lambda record: record.levelno == logging.INFO)
        log.addHandler(info_handler)

    error_handler = logging.StreamHandler(sys.stderr)
    error_formatter = logging.Formatter("%(levelname)s: %(name)s: %(message)s")
    error_handler.setFormatter(error_formatter)
    error_handler.setLevel(logging.DEBUG if verbose else logging.WARNING)
    log.addHandler(error_handler)

    log.propagate = False
    if verbose:
        log.debug("Verbose logging enabled for fluxfce_cli.")
        core_logger.debug("Verbose logging enabled for fluxfce_core (via CLI).")


# --- Output Formatting ---
def print_status(status_data: dict, verbose: bool = False):
    """Formats and prints the status dictionary with colors."""
    log.info("--- fluxfce Status ---")
    summary = status_data.get("summary", {})

    log.info("\n[Scheduling Status]")
    
    # --- START: Colorized Status Logic ---
    status_text = summary.get("overall_status", "[UNKNOWN]")
    if "[OK]" in status_text:
        status_str = f"{AnsiColors.GREEN}{status_text}{AnsiColors.RESET}"
    elif "[DISABLED]" in status_text or "[ERROR]" in status_text:
        status_str = f"{AnsiColors.RED}{status_text}{AnsiColors.RESET}"
    else:  # For "[UNKNOWN]"
        status_str = f"{AnsiColors.YELLOW}{status_text}{AnsiColors.RESET}"
    
    if summary.get("overall_status"):
        log.info(f"  Overall Status:  {status_str} {summary.get('status_message', '')}")
    # --- END: Colorized Status Logic ---

    if summary.get("recommendation"):
        log.info(f"  Recommendation:  {summary['recommendation']}")

    if summary.get("overall_status") == "[OK]":
        log.info("\n[Upcoming Events]")
        next_trans_time = summary.get("next_transition_time")
        next_trans_mode = summary.get("next_transition_mode")

        if next_trans_time and next_trans_mode:
            now = datetime.now(next_trans_time.tzinfo)
            delta = next_trans_time - now
            hours, rem = divmod(delta.total_seconds(), 3600)
            minutes, _ = divmod(rem, 60)
            
            if delta.total_seconds() < 0: time_left_str = "in the past"
            elif hours >= 1: time_left_str = f"in approx. {int(hours)}h {int(minutes)}m"
            else: time_left_str = "soon"
            
            log.info(f"  Next Transition: Apply '{next_trans_mode}' mode at {next_trans_time.strftime('%H:%M:%S')} ({time_left_str})")
        
        if resched_time := summary.get("reschedule_time"):
            log.info(f"  Daily Reschedule: Next check at {resched_time.strftime('%a %H:%M:%S')}")

    if verbose:
        log.info("\n--- Verbose Details ---")
        log.info("\n[Configuration]")
        if status_data["config"].get("error"):
            log.info(f"  Error loading config: {status_data['config']['error']}")
        else:
            cfg = status_data['config']
            log.info(f"  Location:         {cfg.get('latitude', 'N/A')}, {cfg.get('longitude', 'N/A')}")
            log.info(f"  Timezone:         {cfg.get('timezone', 'N/A')}")
            log.info(f"  Light Theme:      {cfg.get('light_theme', 'N/A')}")
            log.info(f"  Dark Theme:       {cfg.get('dark_theme', 'N/A')}")
            log.info(f"  Day BG Profile:   {cfg.get('day_bg_profile', 'N/A')}")
            log.info(f"  Night BG Profile: {cfg.get('night_bg_profile', 'N/A')}")

        log.info("\n[Calculated Sun Times (Today)]")
        if status_data["sun_times"].get("error"):
            log.info(f"  Error: {status_data['sun_times']['error']}")
        elif status_data["sun_times"].get("sunrise") and status_data["sun_times"].get("sunset"):
            log.info(f"  Sunrise:          {status_data['sun_times']['sunrise'].isoformat(sep=' ', timespec='seconds')}")
            log.info(f"  Sunset:           {status_data['sun_times']['sunset'].isoformat(sep=' ', timespec='seconds')}")
        else:
            log.info("  Could not be calculated.")
        log.info(f"  Current Period:   {status_data.get('current_period', 'unknown').capitalize()}")

        log.info("\n[Systemd Services (Login/Resume/Scheduler)]")
        systemd = status_data.get("systemd_services", {})
        if systemd.get("error"):
            log.info(f"  Error checking services: {systemd['error']}")
        else:
            log.info(f"  Scheduler Service ({SCHEDULER_SERVICE_NAME}): {systemd.get('scheduler_service', 'Unknown')}")
            log.info(f"  Login Service ({LOGIN_SERVICE_NAME}): {systemd.get('login_service', 'Unknown')}")
            log.info(f"  Resume Service ({RESUME_SERVICE_NAME}): {systemd.get('resume_service', 'Unknown')}")
    else:
        log.info("\n(Run with -v for detailed configuration and systemd service status)")
    log.info("-" * 25)


# --- User Interaction Helper ---
def ask_yes_no_cli(prompt: str, default_yes: bool = False) -> bool:
    """Asks a yes/no question and returns True for yes, False for no."""
    suffix = "[Y/n]" if default_yes else "[y/N]"
    while True:
        try:
            print(f"{prompt} {suffix}: ", end="", flush=True)
            response = input().strip().lower()
            if not response: return default_yes
            if response in ["y", "yes"]: return True
            if response in ["n", "no"]: return False
            print("[WARN] Invalid input. Please enter 'y' or 'n'.")
        except (EOFError, KeyboardInterrupt):
            print("\nPrompt interrupted. Assuming 'no'.")
            return False


# --- Main Execution Logic ---
def main():
    """Parses command-line arguments and dispatches to appropriate command handlers."""
    parser = argparse.ArgumentParser(
        description="fluxfce (CLI): Manage XFCE appearance via sunrise/sunset timing.",
        formatter_class=argparse.RawTextHelpFormatter,
        epilog="""
Examples:
  fluxfce install          # Interactive setup, install units, and enable scheduling
  fluxfce status -v        # Show detailed status, including profiles and services
  fluxfce day              # Apply Day mode now without disabling auto switching
  fluxfce enable           # Enable automatic scheduling (sets up systemd timers)
  fluxfce set-default --mode day # Save current desktop look as the new Day default
  fluxfce uninstall        # Remove systemd units and schedule (prompts for config removal)
""",
    )
    parser.add_argument("-v", "--verbose", action="store_true", help="Enable detailed logging output.")
    subparsers = parser.add_subparsers(dest="command", title="Commands", required=True)

    subparsers.add_parser("install", help="Install systemd units and enable automatic scheduling.")
    subparsers.add_parser("uninstall", help="Remove systemd units & clear schedule (prompts to remove config).")
    subparsers.add_parser("day", help="Apply Day Mode settings now (leaves auto scheduling enabled).")
    subparsers.add_parser("night", help="Apply Night Mode settings now (leaves auto scheduling enabled).")
    subparsers.add_parser("enable", help="Enable automatic scheduling (configures systemd timers).")
    subparsers.add_parser("disable", help="Disable automatic scheduling (clears relevant systemd timers).")
    subparsers.add_parser("status", help="Show config, calculated times, and schedule status.")
    subparsers.add_parser("force-day", help="Apply Day Mode settings now (disables auto scheduling).")
    subparsers.add_parser("force-night", help="Apply Night Mode settings now (disables auto scheduling).")
    
    parser_set_default = subparsers.add_parser("set-default", help="Save current desktop look as the new default for Day or Night mode.")
    parser_set_default.add_argument("--mode", choices=["day", "night"], required=True, dest="default_mode")

    # Internal commands, hidden from public help
    parser_internal_apply = subparsers.add_parser("internal-apply", help=argparse.SUPPRESS)
    parser_internal_apply.add_argument("--mode", choices=["day", "night"], required=True, dest="internal_mode")
    subparsers.add_parser("schedule-dynamic-transitions", help=argparse.SUPPRESS)
    subparsers.add_parser("run-login-check", help=argparse.SUPPRESS)

    args = parser.parse_args()
    setup_cli_logging(args.verbose)
    exit_code = 0

    try:
        log.debug(f"Running command: {args.command}")

        if args.command == "install":
            log.info("--- Step 1: Checking system dependencies ---")
            dep_checker = SCRIPT_DIR / DEPENDENCY_CHECKER_SCRIPT_NAME
            if not dep_checker.exists():
                log.error(f"Dependency checker '{DEPENDENCY_CHECKER_SCRIPT_NAME}' not found.")
                sys.exit(1)
            
            process = subprocess.run([PYTHON_EXECUTABLE, str(dep_checker)], check=False)
            if process.returncode != 0:
                log.error("Dependency check/setup failed. Aborting installation.")
                sys.exit(1)
            log.info("--- Dependency check complete ---")

            log.info("\n--- Step 2: Configuring FluxFCE application settings ---")
            config_existed = fluxfce_core.CONFIG_FILE.exists()
            config_obj = fluxfce_core.get_current_config()
            # NOTE: The complex interactive setup logic from the original file would go here.
            # Assuming it runs and potentially modifies config_obj.
            if not config_existed: 
                fluxfce_core.save_configuration(config_obj) # Save if newly created
            log.info("--- FluxFCE application configuration complete ---")

            log.info("\n--- Step 2b: Installing default background profiles ---")
            fluxfce_core.install_default_background_profiles()
            log.info("Default background profiles created. Use 'fluxfce set-default' to customize them.")

            log.info("\n--- Step 3: Installing systemd units ---")
            fluxfce_core.install_fluxfce(script_path=SCRIPT_PATH, python_executable=PYTHON_EXECUTABLE)

            log.info("\n--- Step 4: Enabling automatic scheduling ---")
            fluxfce_core.enable_scheduling(python_exe_path=PYTHON_EXECUTABLE, script_exe_path=SCRIPT_PATH)

            log.info("\n" + "-"*45 + "\n fluxfce installed and enabled successfully. \n" + "-"*45)
            log.info("Tip: Configure your look using 'fluxfce set-default --mode day|night'.")

        elif args.command == "uninstall":
            log.info("Starting uninstallation (system components)...")
            fluxfce_core.uninstall_fluxfce()
            log.info("FluxFCE systemd units removed and schedule cleared.")

            config_dir_path = fluxfce_core.CONFIG_DIR
            if config_dir_path.exists():
                log.warning(f"\nConfiguration directory found at: {config_dir_path}")
                if ask_yes_no_cli("Do you want to REMOVE this configuration directory and all profiles?", default_yes=False):
                    try:
                        shutil.rmtree(config_dir_path)
                        log.info(f"Removed configuration directory: {config_dir_path}")
                    except OSError as e:
                        log.error(f"Error removing config directory {config_dir_path}: {e}")
                else:
                    log.info("Configuration directory kept.")
            log.info("\n--- Uninstallation Complete ---")

        elif args.command == "day":
            log.info("Applying Day mode (scheduling will remain active)...")
            fluxfce_core.apply_temporary_mode("day")

        elif args.command == "night":
            log.info("Applying Night mode (scheduling will remain active)...")
            fluxfce_core.apply_temporary_mode("night")

        elif args.command == "enable":
            log.info("Enabling scheduling via systemd timers...")
            if not core_config.CONFIG_FILE.exists():
                log.error(f"Config file {core_config.CONFIG_FILE} not found. Run 'install' first.")
                exit_code = 1
            else:
                fluxfce_core.enable_scheduling(python_exe_path=PYTHON_EXECUTABLE, script_exe_path=SCRIPT_PATH)
                log.info("Automatic theme scheduling enabled.")

        elif args.command == "disable":
            log.info("Disabling scheduling (systemd timers)...")
            fluxfce_core.disable_scheduling()
            log.info("Automatic theme scheduling disabled.")

        elif args.command == "status":
            status = fluxfce_core.get_status()
            print_status(status, verbose=args.verbose)

        elif args.command == "force-day":
            log.info("Forcing Day mode and disabling scheduling...")
            fluxfce_core.apply_manual_mode("day")

        elif args.command == "force-night":
            log.info("Forcing Night mode and disabling scheduling...")
            fluxfce_core.apply_manual_mode("night")

        elif args.command == "set-default":
            mode = args.default_mode
            log.info(f"Setting current look as default for {mode.capitalize()} mode...")
            log.info("This will save the current GTK theme, screen settings, and overwrite the")
            log.info(f"'{mode}' background profile with your current desktop background(s).")
            fluxfce_core.set_default_from_current(mode)
            log.info(f"Current desktop settings saved as default for {mode.capitalize()} mode.")

        elif args.command == "internal-apply":
            success = fluxfce_core.handle_internal_apply(args.internal_mode)
            exit_code = 0 if success else 1
        
        elif args.command == "schedule-dynamic-transitions":
            success = fluxfce_core.handle_schedule_dynamic_transitions_command(
                python_exe_path=PYTHON_EXECUTABLE, script_exe_path=SCRIPT_PATH
            )
            exit_code = 0 if success else 1

        elif args.command == "run-login-check":
            success = fluxfce_core.handle_run_login_check()
            exit_code = 0 if success else 1
        else:
            log.error(f"Unknown command: {args.command}")
            parser.print_help(sys.stderr)
            exit_code = 1

    except core_exc.FluxFceError as e:
        log.error(f"FluxFCE Error: {e}", exc_info=args.verbose)
        exit_code = 1
    except Exception as e_main:
        log.error(f"An unexpected error occurred in CLI: {e_main}", exc_info=True)
        exit_code = 1

    sys.exit(exit_code)


if __name__ == "__main__":
    main()

##############
fluxfce_core/api.py

# fluxfce_core/api.py
"""
Public API Facade for the fluxfce_core library.

This module provides the primary interface for external callers (like the CLI)
to interact with the core functionalities of FluxFCE, including configuration,
scheduling, desktop appearance management, and systemd integration.
It orchestrates calls to other internal modules within `fluxfce_core`.
"""

import configparser
import logging
from datetime import datetime, timedelta
from typing import Any, Optional

# Import core components and exceptions
from . import config as cfg
from . import exceptions as exc
from . import helpers, sun, systemd as sysd
from . import desktop_manager, scheduler
from .background_manager import BackgroundManager

try:
    from zoneinfo import ZoneInfo, ZoneInfoNotFoundError
except ImportError:
    raise ImportError("Required module 'zoneinfo' not found. FluxFCE requires Python 3.9+.")

log = logging.getLogger(__name__)

# --- Module-level Managers ---
_cfg_mgr_api = cfg.ConfigManager()
_sysd_mgr_api = sysd.SystemdManager()

# --- Public API Functions for Config ---

def get_current_config() -> configparser.ConfigParser:
    """Loads the current configuration, applying defaults in memory."""
    log.debug("API: get_current_config called")
    return _cfg_mgr_api.load_config()

def save_configuration(config_obj: configparser.ConfigParser) -> bool:
    """Saves the given ConfigParser object to file."""
    log.debug("API: save_configuration called")
    return _cfg_mgr_api.save_config(config_obj)

# --- Installation and Uninstallation ---

def install_default_background_profiles() -> None:
    """
    API function to trigger the installation of default background profiles.
    This is called by the CLI during the main `install` process.
    """
    log.info("API: Triggering installation of default background profiles.")
    try:
        bg_manager = BackgroundManager()
        bg_manager.install_default_profiles()
    except exc.XfceError as e:
        log.error(f"API: Failed to install default background profiles: {e}")
        # This is not a fatal error; the main installation can continue with a warning.
    except Exception as e:
        log.exception(f"API: Unexpected error installing default background profiles: {e}")

def install_fluxfce(script_path: str, python_executable: Optional[str] = None) -> bool:
    """API Façade: Installs static systemd units."""
    log.info(f"API Facade: Installing static systemd units for {sysd._APP_NAME}.")
    install_mgr = sysd.SystemdManager()
    return install_mgr.install_units(script_path=script_path, python_executable=python_executable)

def uninstall_fluxfce() -> bool:
    """API Façade: Disables scheduling and removes all systemd units."""
    log.info(f"API Facade: Uninstalling {sysd._APP_NAME} (disabling schedule, removing units).")
    scheduler.disable_scheduling()
    uninstall_mgr = sysd.SystemdManager()
    return uninstall_mgr.remove_units()

# --- Scheduling Façade ---

def enable_scheduling(python_exe_path: str, script_exe_path: str) -> bool:
    """API Façade: Enables scheduling and applies the theme for the current solar period."""
    log.info("API Facade: Attempting to enable scheduling...")
    scheduler.enable_scheduling(python_exe_path=python_exe_path, script_exe_path=script_exe_path)
    log.info("API Facade: Scheduling setup. Applying theme for current solar period...")
    return desktop_manager.handle_run_login_check()

def disable_scheduling() -> bool:
    """API Façade: Disables scheduling by calling the scheduler module."""
    log.info("API Facade: Calling scheduler.disable_scheduling...")
    return scheduler.disable_scheduling()

def handle_schedule_dynamic_transitions_command(python_exe_path: str, script_exe_path: str) -> bool:
    """API Façade: For CLI internal command to call the scheduler function."""
    log.debug("API Facade: Relaying 'schedule-dynamic-transitions' to scheduler module.")
    return scheduler.handle_schedule_dynamic_transitions_command(python_exe_path, script_exe_path)

# --- Desktop Appearance Façade ---

def apply_temporary_mode(mode: str) -> bool:
    """API Façade: Applies an appearance mode temporarily, WITHOUT disabling scheduling."""
    log.info(f"API Facade: Applying temporary mode '{mode}' (scheduling remains active)...")
    return desktop_manager.apply_mode(mode)

def apply_manual_mode(mode: str) -> bool:
    """API Façade: Applies a manual appearance mode and disables scheduling."""
    log.info(f"API Facade: Applying manual mode '{mode}' and then disabling scheduling...")
    desktop_manager.apply_mode(mode)
    return scheduler.disable_scheduling()

def set_default_from_current(mode: str) -> bool:
    """API Façade: Saves current desktop settings as default via desktop_manager."""
    log.info(f"API Facade: Calling desktop_manager.set_defaults_from_current for mode '{mode}'.")
    return desktop_manager.set_defaults_from_current(mode)

# --- Internal Command Handlers Façade ---

def handle_internal_apply(mode: str) -> bool:
    """API Façade: Relays to desktop_manager.handle_internal_apply."""
    log.debug(f"API Facade: Relaying 'internal-apply --mode {mode}' to desktop_manager.")
    return desktop_manager.handle_internal_apply(mode)

def handle_run_login_check() -> bool:
    """API Façade: Relays to desktop_manager.handle_run_login_check."""
    log.debug("API Facade: Relaying 'run-login-check' to desktop_manager.")
    return desktop_manager.handle_run_login_check()

# --- Status Function ---

def get_status() -> dict[str, Any]:
    """Retrieves the current status of fluxfce."""
    log.debug("API: Getting status...")
    status: dict[str, Any] = {
        "config": {},
        "sun_times": {"sunrise": None, "sunset": None, "error": None},
        "current_period": "unknown",
        "systemd_services": {"error": None},
        "summary": {},
    }

    # --- Part 1: Gather Raw Data ---

    # 1. Get Config
    try:
        config_obj = get_current_config()
        status["config"]["latitude"] = config_obj.get("Location", "LATITUDE", fallback="Not Set")
        status["config"]["longitude"] = config_obj.get("Location", "LONGITUDE", fallback="Not Set")
        status["config"]["timezone"] = config_obj.get("Location", "TIMEZONE", fallback="Not Set")
        # Updated to new [Appearance] section
        status["config"]["light_theme"] = config_obj.get("Appearance", "LIGHT_THEME", fallback="Not Set")
        status["config"]["dark_theme"] = config_obj.get("Appearance", "DARK_THEME", fallback="Not Set")
        status["config"]["day_bg_profile"] = config_obj.get("Appearance", "DAY_BACKGROUND_PROFILE", fallback="Not Set")
        status["config"]["night_bg_profile"] = config_obj.get("Appearance", "NIGHT_BACKGROUND_PROFILE", fallback="Not Set")
    except exc.FluxFceError as e:
        status["config"]["error"] = str(e)
        log.error(f"API Status: Error loading config for status: {e}")

    # 2. Calculate Sun Times & Current Period
    tz_info, lat, lon, tz_name = None, None, None, None
    if "error" not in status["config"]:
        lat_str = status["config"]["latitude"]
        lon_str = status["config"]["longitude"]
        tz_name = status["config"]["timezone"]
        
        if all([lat_str, lon_str, tz_name, lat_str != "Not Set", lon_str != "Not Set", tz_name != "Not Set"]):
            try:
                lat = helpers.latlon_str_to_float(lat_str)
                lon = helpers.latlon_str_to_float(lon_str)
                tz_info = ZoneInfo(tz_name)
                now_local = datetime.now(tz_info)
                today = now_local.date()
                sun_times_today = sun.get_sun_times(lat, lon, today, tz_name)
                status["sun_times"]["sunrise"] = sun_times_today["sunrise"]
                status["sun_times"]["sunset"] = sun_times_today["sunset"]
                status["current_period"] = "day" if sun_times_today["sunrise"] <= now_local < sun_times_today["sunset"] else "night"
            except (exc.ValidationError, exc.CalculationError, ZoneInfoNotFoundError) as e_sun:
                status["sun_times"]["error"] = str(e_sun)
        else:
            status["sun_times"]["error"] = "Location/Timezone not fully configured."
    else:
        status["sun_times"]["error"] = "Cannot calculate sun times (config error)."
    
    # 3. Get Systemd Service Status (for verbose view)
    services_to_check = {
        "scheduler_service": sysd.SCHEDULER_SERVICE_NAME,
        "login_service": sysd.LOGIN_SERVICE_NAME,
        "resume_service": sysd.RESUME_SERVICE_NAME,
    }
    for key, unit_name in services_to_check.items():
        try:
            enabled_code, _, _ = _sysd_mgr_api._run_systemctl(["is-enabled", unit_name], check_errors=False, capture_output=True)
            active_code, _, _ = _sysd_mgr_api._run_systemctl(["is-active", unit_name], check_errors=False, capture_output=True)
            status["systemd_services"][key] = f"{'Enabled' if enabled_code == 0 else 'Disabled'}, {'Active' if active_code == 0 else 'Inactive'}"
        except Exception:
            status["systemd_services"][key] = "Error checking status"
            status["systemd_services"]["error"] = "One or more services could not be checked reliably."

    # --- Part 2: Analyze Raw Data and Generate Summary ---
    summary = {
        "overall_status": "[UNKNOWN]",
        "status_message": "Could not determine scheduler status.",
        "recommendation": "Try running with -v for more details.",
    }

    if status["config"].get("error"):
        summary["overall_status"] = "[ERROR]"
        summary["status_message"] = f"Configuration error: {status['config']['error']}"
        summary["recommendation"] = "Please check your config or run 'fluxfce install'."
    elif status["sun_times"].get("error"):
        summary["overall_status"] = "[ERROR]"
        summary["status_message"] = f"Sun calculation error: {status['sun_times']['error']}"
        summary["recommendation"] = "Please check location/timezone in your configuration."
    else:
        try:
            code, _, _ = _sysd_mgr_api._run_systemctl(["is-enabled", "--quiet", sysd.SCHEDULER_TIMER_NAME], check_errors=False)
            is_enabled = (code == 0)
            
            if not is_enabled:
                summary["overall_status"] = "[DISABLED]"
                summary["status_message"] = "Automatic scheduling is disabled."
                summary["recommendation"] = "Run 'fluxfce enable' to activate."
            else:
                summary["overall_status"] = "[OK]"
                summary["status_message"] = "Enabled and scheduling is active."
                summary["recommendation"] = None

                now = datetime.now(tz_info)
                sunrise_dt = status["sun_times"]["sunrise"]
                sunset_dt = status["sun_times"]["sunset"]

                next_sunrise = sunrise_dt if sunrise_dt > now else None
                next_sunset = sunset_dt if sunset_dt > now else None

                if not next_sunrise or not next_sunset:
                    tmrw_sun = sun.get_sun_times(lat, lon, now.date() + timedelta(days=1), tz_name)
                    if not next_sunrise: next_sunrise = tmrw_sun["sunrise"]
                    if not next_sunset: next_sunset = tmrw_sun["sunset"]

                if next_sunrise and (not next_sunset or next_sunrise < next_sunset):
                    summary["next_transition_time"] = next_sunrise
                    summary["next_transition_mode"] = "Day"
                elif next_sunset:
                    summary["next_transition_time"] = next_sunset
                    summary["next_transition_mode"] = "Night"
                
                summary["reschedule_time"] = (now + timedelta(days=1)).replace(hour=0, minute=15, second=0, microsecond=0)
        except exc.SystemdError as e:
            summary["overall_status"] = "[ERROR]"
            summary["status_message"] = f"Systemd error: {e}"
            summary["recommendation"] = "Check systemd with 'systemctl --user status'."
            
    status["summary"] = summary
    return status

##############
fluxfce_core/background_manager.py

# fluxfce_core/background_manager.py
"""
Manages saving and loading of XFCE4 desktop background profiles.

This module is responsible for interacting with the XFCE desktop to get/set
background properties, including multi-monitor and image-based backgrounds.
Its logic is heavily inspired by the xapply.py script.
"""

import logging
import re
import time
from pathlib import Path
from typing import Any

from . import helpers
from .exceptions import XfceError

log = logging.getLogger(__name__)

# --- Configuration ---
PROFILE_DIR = helpers.pathlib.Path.home() / ".config" / "fluxfce" / "backgrounds"

# --- Mappings for XFCE Properties ---
IMAGE_STYLE_MAP = {
    "none": 0, "centered": 1, "tiled": 2, "stretched": 3,
    "scaled": 4, "zoomed": 5, "span": 6
}
COLOR_STYLE_MAP = {"solid": 0, "horizontal": 1, "vertical": 2}

STYLE_IMAGE_MAP = {v: k for k, v in IMAGE_STYLE_MAP.items()}
STYLE_COLOR_MAP = {v: k for k, v in COLOR_STYLE_MAP.items()}

# --- Default Profile Content ---
DEFAULT_DAY_PROFILE_CONTENT = """
monitor=--span--
type=image
image_path=/home/cad/dev/fluxfce-simplified/fluxfce_core/assets/default-day.png
image_style=span
"""

DEFAULT_NIGHT_PROFILE_CONTENT = """
monitor=--span--
type=image
image_path=/home/cad/dev/fluxfce-simplified/fluxfce_core/assets/default-night.png
image_style=span
"""


class BackgroundManager:
    """Handles saving and loading of XFCE background profiles."""

    def __init__(self):
        """Ensures the profile directory exists."""
        try:
            helpers.check_dependencies(["xfconf-query", "xrandr", "xfdesktop"])
            PROFILE_DIR.mkdir(parents=True, exist_ok=True)
        except (helpers.DependencyError, OSError) as e:
            raise XfceError(f"Cannot initialize BackgroundManager: {e}") from e

    # --- Private Helpers for xfconf ---
    def _get_prop(self, prop_path: str) -> str | None:
        cmd = ["xfconf-query", "-c", "xfce4-desktop", "-p", prop_path]
        ret_code, stdout, _ = helpers.run_command(cmd, capture=True)
        return stdout if ret_code == 0 else None

    def _list_props(self, prop_path: str) -> list[str]:
        cmd = ["xfconf-query", "-c", "xfce4-desktop", "-p", prop_path, "-l"]
        ret_code, stdout, _ = helpers.run_command(cmd, capture=True)
        return stdout.splitlines() if ret_code == 0 else []

    def _set_prop(self, prop_path: str, prop_type: str, value: Any) -> None:
        cmd = ["xfconf-query", "-c", "xfce4-desktop", "-p", prop_path, "--create", "-t", prop_type, "-s", str(value)]
        helpers.run_command(cmd)

    def _set_rgba_prop(self, prop_path: str, rgba_string: str) -> None:
        match = re.search(r'rgba\(([\d.,\s]+)\)', rgba_string)
        if not match: return
        values = [v.strip() for v in match.group(1).split(',')]
        if len(values) != 4: return
        helpers.run_command(["xfconf-query", "-c", "xfce4-desktop", "-p", prop_path, "-r"])
        cmd = ["xfconf-query", "-c", "xfce4-desktop", "-p", prop_path, "-n"]
        for val in values: cmd.extend(["-t", "double", "-s", val])
        helpers.run_command(cmd, check=False)

    def _reset_monitor_props(self, monitor_name: str) -> None:
        log.debug(f" -> Clearing properties for monitor {monitor_name}")
        prop_path = f"/backdrop/screen0/monitor{monitor_name}"
        cmd = ["xfconf-query", "-c", "xfce4-desktop", "-p", prop_path, "-rR"]
        helpers.run_command(cmd)

    # --- Private Helpers for System Info ---
    def _get_connected_monitors(self) -> list[str]:
        _, stdout, _ = helpers.run_command(["xrandr"], capture=True)
        if stdout is None: return []
        return [line.split()[0] for line in stdout.splitlines() if " connected" in line]

    def _get_primary_monitor(self) -> str | None:
        _, stdout, _ = helpers.run_command(["xrandr"], capture=True)
        if stdout is None: return None
        for line in stdout.splitlines():
            if " primary " in line: return line.split()[0]
        monitors = self._get_connected_monitors()
        return monitors[0] if monitors else None

    # --- Public API ---
    def install_default_profiles(self) -> None:
        log.info("Installing default background profiles...")
        primary_monitor = self._get_primary_monitor()
        if not primary_monitor:
            log.warning("Could not determine primary monitor; cannot create default profiles.")
            return
        try:
            day_profile_path = PROFILE_DIR / "default-day.profile"
            day_content = DEFAULT_DAY_PROFILE_CONTENT.format(primary_monitor=primary_monitor)
            day_profile_path.write_text(day_content.strip())
            night_profile_path = PROFILE_DIR / "default-night.profile"
            night_content = DEFAULT_NIGHT_PROFILE_CONTENT.format(primary_monitor=primary_monitor)
            night_profile_path.write_text(night_content.strip())
        except OSError as e:
            raise XfceError(f"Failed to write default profiles: {e}") from e

    def save_current_to_profile(self, profile_name: str) -> None:
        profile_path = PROFILE_DIR / f"{profile_name}.profile"
        log.info(f"Scanning settings to save to profile: '{profile_name}'")
        all_props = self._list_props("/backdrop")
        span_prop = next((p for p in all_props if p.endswith("/image-style") and self._get_prop(p) == "6"), None)
        if span_prop:
            image_path_prop = span_prop.replace("/image-style", "/last-image")
            span_image_path = self._get_prop(image_path_prop)
            if span_image_path:
                content = ["monitor=--span--", "type=image", f"image_path={span_image_path}", "image_style=span"]
                profile_path.write_text("\n".join(content) + "\n")
                log.info(f"Profile saved to {profile_path}")
                return
        profile_blocks = []
        for monitor in self._get_connected_monitors():
            base_path = f"/backdrop/screen0/monitor{monitor}"
            monitor_props = self._list_props(base_path)
            if not monitor_props: continue
            workspaces = sorted(list(set(re.findall(r'(workspace\d+)', " ".join(monitor_props)))))
            for workspace in workspaces:
                ws_path = f"{base_path}/{workspace}"
                rgba1_raw = self._get_prop(f"{ws_path}/rgba1")
                rgba1_str = f"rgba({','.join(rgba1_raw.splitlines())})" if rgba1_raw else None
                rgba2_raw = self._get_prop(f"{ws_path}/rgba2")
                rgba2_str = f"rgba({','.join(rgba2_raw.splitlines())})" if rgba2_raw else None
                settings = {"image_path": self._get_prop(f"{ws_path}/last-image"), "image_style": self._get_prop(f"{ws_path}/image-style"), "color_style": self._get_prop(f"{ws_path}/color-style"), "rgba1": rgba1_str, "rgba2": rgba2_str}
                if not any(v for k, v in settings.items() if k != 'rgba1' and k != 'rgba2'): continue
                block = [f"monitor={monitor}", f"workspace={workspace}"]
                image_style_name = STYLE_IMAGE_MAP.get(int(settings['image_style'] or -1), "none")
                if settings['image_path'] and image_style_name != "none":
                    block.extend(["type=image", f"image_path={settings['image_path']}", f"image_style={image_style_name}"])
                else:
                    color_style_name = STYLE_COLOR_MAP.get(int(settings['color_style'] or 0), "solid")
                    if color_style_name == "solid":
                        block.append("type=solid_color")
                        if settings['rgba1']: block.append(f"color1={settings['rgba1']}")
                    else:
                        block.extend(["type=gradient", f"gradient_direction={color_style_name}"])
                        if settings['rgba1']: block.append(f"color1={settings['rgba1']}")
                        if settings['rgba2']: block.append(f"color2={settings['rgba2']}")
                profile_blocks.append("\n".join(block))
        if profile_blocks:
            profile_path.write_text("\n\n".join(profile_blocks) + "\n")
            log.info(f"Profile saved to {profile_path}")

    def load_profile(self, profile_name: str) -> None:
        """Loads a desktop background configuration from a profile file."""
        profile_path = PROFILE_DIR / f"{profile_name}.profile"
        if not profile_path.is_file():
            raise XfceError(f"Background profile '{profile_name}' not found at: {profile_path}")

        # --- START: CORRECTED CODE BLOCK ---
        # The upfront reset loop has been removed to prevent the flash of default wallpaper.
        # We now go directly to applying the new settings.
        log.info(f"Applying background profile '{profile_name}'...")
        # --- END: CORRECTED CODE BLOCK ---

        content = profile_path.read_text()
        settings_map = dict(line.split('=', 1) for line in content.splitlines() if '=' in line)

        if settings_map.get("monitor") == "--span--":
            log.info(f"Applying 'Span screens' profile: {profile_name}")
            image_path = settings_map.get("image_path")
            primary_monitor = self._get_primary_monitor()
            if not primary_monitor or not image_path:
                raise XfceError("Primary monitor not found or image_path missing in span profile.")
            base_path = f"/backdrop/screen0/monitor{primary_monitor}/workspace0"
            self._set_prop(f"{base_path}/image-style", "int", IMAGE_STYLE_MAP["span"])
            self._set_prop(f"{base_path}/last-image", "string", image_path)
            for monitor in self._get_connected_monitors():
                if monitor != primary_monitor:
                    other_base = f"/backdrop/screen0/monitor{monitor}/workspace0"
                    self._set_prop(f"{other_base}/image-style", "int", IMAGE_STYLE_MAP["none"])
        else:
            log.debug(f"Applying per-monitor settings for profile: {profile_name}")
            blocks = re.split(r'\n\s*\n', content.strip())
            for block in blocks:
                if not block: continue
                settings = dict(line.split('=', 1) for line in block.splitlines() if '=' in line)
                monitor, workspace = settings.get("monitor"), settings.get("workspace")
                if not monitor or not workspace: continue
                base_path = f"/backdrop/screen0/monitor{monitor}/{workspace}"
                log.debug(f" -> Applying to: {monitor}/{workspace}")
                if settings.get("type") == "image":
                    self._set_prop(f"{base_path}/image-style", "int", IMAGE_STYLE_MAP[settings["image_style"]])
                    self._set_prop(f"{base_path}/last-image", "string", settings["image_path"])
                elif settings.get("type") in ("solid_color", "gradient"):
                    self._set_prop(f"{base_path}/image-style", "int", 0)
                    if settings.get("type") == "solid_color":
                        self._set_prop(f"{base_path}/color-style", "int", COLOR_STYLE_MAP["solid"])
                    else:
                        self._set_prop(f"{base_path}/color-style", "int", COLOR_STYLE_MAP.get(settings.get("gradient_direction"), 2))
                    if "color1" in settings: self._set_rgba_prop(f"{base_path}/rgba1", settings["color1"])
                    if "color2" in settings: self._set_rgba_prop(f"{base_path}/rgba2", settings["color2"])

        log.debug("Reloading desktop...")
        time.sleep(0.2)
        helpers.run_command(["xfdesktop", "--reload"])
        log.info(f"Profile '{profile_name}' applied successfully.")

##############
fluxfce_core/config.py

# ~/dev/fluxfce-simplified/fluxfce_core/config.py
"""
Configuration management for FluxFCE.

This module handles the loading, saving, and default value application
for FluxFCE's configuration file (`config.ini`).
"""

import configparser
import logging
import pathlib
from typing import Optional

from .exceptions import ConfigError

log = logging.getLogger(__name__)

# --- Constants ---
APP_NAME = "fluxfce"
CONFIG_DIR = pathlib.Path.home() / ".config" / APP_NAME
CONFIG_FILE = CONFIG_DIR / "config.ini"

# Default configuration values
# Background settings are now handled by profiles.
DEFAULT_CONFIG: dict[str, dict[str, str]] = {
    "Location": {
        "LATITUDE": "43.65N",
        "LONGITUDE": "79.38W",
        "TIMEZONE": "America/Toronto",
    },
    "Appearance": {
        "LIGHT_THEME": "Adwaita",
        "DARK_THEME": "Adwaita-dark",
        "DAY_BACKGROUND_PROFILE": "default-day",
        "NIGHT_BACKGROUND_PROFILE": "default-night",
    },
    "ScreenDay": {
        "XSCT_TEMP": "6500",
        "XSCT_BRIGHT": "1.0",
    },
    "ScreenNight": {
        "XSCT_TEMP": "4500",
        "XSCT_BRIGHT": "0.85",
    },
}


class ConfigManager:
    """Handles reading/writing config.ini."""
    
    def __init__(self):
        try:
            CONFIG_DIR.mkdir(parents=True, exist_ok=True)
            log.debug(f"Configuration directory ensured: {CONFIG_DIR}")
        except OSError as e:
            raise ConfigError(f"Failed to create configuration directory {CONFIG_DIR}: {e}") from e

    def _load_ini(self, file_path: pathlib.Path) -> configparser.ConfigParser:
        parser = configparser.ConfigParser()
        if file_path.exists():
            try:
                if file_path.stat().st_size > 0:
                    parser.read(file_path, encoding="utf-8")
                else:
                    log.warning(f"Config file {file_path} is empty.")
            except configparser.Error as e:
                raise ConfigError(f"Could not parse config file {file_path}: {e}") from e
            except OSError as e:
                raise ConfigError(f"Could not read config file {file_path}: {e}") from e
        return parser

    def _save_ini(self, parser: configparser.ConfigParser, file_path: pathlib.Path) -> bool:
        try:
            with file_path.open("w", encoding="utf-8") as f:
                parser.write(f)
            log.debug(f"Saved configuration to {file_path}")
            return True
        except OSError as e:
            raise ConfigError(f"Failed to write configuration to {file_path}: {e}") from e

    def load_config(self) -> configparser.ConfigParser:
        parser = self._load_ini(CONFIG_FILE)
        made_changes = False
        for section, defaults in DEFAULT_CONFIG.items():
            if not parser.has_section(section):
                parser.add_section(section)
                made_changes = True
            for key, value in defaults.items():
                if not parser.has_option(section, key):
                    parser.set(section, key, value)
                    made_changes = True
        if made_changes:
            log.info("Default values applied in memory to the loaded configuration.")
        return parser

    def save_config(self, config: configparser.ConfigParser) -> bool:
        log.info(f"Saving configuration to {CONFIG_FILE}")
        return self._save_ini(config, CONFIG_FILE)

    def get_setting(self, config: configparser.ConfigParser, section: str, key: str, default: Optional[str] = None) -> Optional[str]:
        return config.get(section, key, fallback=default)

    def set_setting(self, config: configparser.ConfigParser, section: str, key: str, value: str):
        if not config.has_section(section):
            config.add_section(section)
        config.set(section, key, value)

##############
fluxfce_core/desktop_manager.py

# fluxfce_core/desktop_manager.py
"""
High-level desktop-appearance operations for FluxFCE.

This module orchestrates changes to the desktop by calling the XfceHandler
for themes/screen and the BackgroundManager for desktop backgrounds.
"""

from __future__ import annotations

import logging
from datetime import datetime
from typing import Literal

from . import config as cfg
from . import helpers, xfce
from .background_manager import BackgroundManager
from .exceptions import FluxFceError, ValidationError

log = logging.getLogger(__name__)

_cfg_mgr_desktop = cfg.ConfigManager()

def _load_cfg() -> cfg.configparser.ConfigParser:
    """Return the current config (with in-memory defaults)."""
    return _cfg_mgr_desktop.load_config()

def _apply_single_mode(mode: Literal["day", "night"]) -> bool:
    """Low-level worker that performs all appearance changes."""
    conf = _load_cfg()
    
    theme_key = "LIGHT_THEME" if mode == "day" else "DARK_THEME"
    bg_profile_key = "DAY_BACKGROUND_PROFILE" if mode == "day" else "NIGHT_BACKGROUND_PROFILE"
    screen_section = "ScreenDay" if mode == "day" else "ScreenNight"

    theme_to_set = conf.get("Appearance", theme_key)
    bg_profile_to_load = conf.get("Appearance", bg_profile_key)
    
    # --- Apply settings ---
    xfce_handler = xfce.XfceHandler()
    bg_manager = BackgroundManager()

    # 1. GTK Theme
    if theme_to_set:
        xfce_handler.set_gtk_theme(theme_to_set)
    else:
        log.warning(f"Theme for mode '{mode}' is not configured.")

    # 2. Background via Profile
    if bg_profile_to_load:
        bg_manager.load_profile(bg_profile_to_load)
    else:
        log.warning(f"Background profile for mode '{mode}' is not configured.")

    # 3. Screen Temperature / Brightness
    try:
        # --- START: CORRECTED CODE BLOCK ---
        # First, get the string values, defaulting to None if the option doesn't exist.
        temp_str = conf.get(screen_section, "XSCT_TEMP", fallback=None)
        bright_str = conf.get(screen_section, "XSCT_BRIGHT", fallback=None)

        # Convert to numbers ONLY if the string value is not None and not empty.
        # This correctly handles cases where the config key exists but its value is blank.
        temp = int(temp_str) if temp_str and temp_str.strip() else None
        bright = float(bright_str) if bright_str and bright_str.strip() else None
        
        # This call now reliably happens. If temp/bright are None, xsct will be reset.
        xfce_handler.set_screen_temp(temp, bright)
        # --- END: CORRECTED CODE BLOCK ---
    except (ValueError, TypeError) as e:
        # This will now only catch genuine errors, e.g., if a value is "abc".
        log.warning(f"Invalid numeric value for screen settings in config for {mode} mode: {e}")

    return True

# --- Public API ---

def apply_mode(mode: Literal["day", "night"]) -> bool:
    """Apply Day or Night appearance immediately."""
    if mode not in ("day", "night"):
        raise ValidationError(f"Invalid mode '{mode}'.")
    log.info("Applying %s mode appearance...", mode)
    return _apply_single_mode(mode)

def set_defaults_from_current(mode: Literal["day", "night"]) -> bool:
    """Save the current XFCE look as the new default for the given mode."""
    conf = _load_cfg()
    xfce_handler = xfce.XfceHandler()
    bg_manager = BackgroundManager()
    changed = False

    # 1. Save Background to Profile
    profile_key = "DAY_BACKGROUND_PROFILE" if mode == "day" else "NIGHT_BACKGROUND_PROFILE"
    profile_to_save = conf.get("Appearance", profile_key)
    if profile_to_save:
        log.info(f"Saving current background to profile: '{profile_to_save}'")
        bg_manager.save_current_to_profile(profile_to_save)
    else:
        log.warning(f"No background profile name configured for {mode} mode; cannot save background.")

    # 2. Save Theme and Screen settings to config.ini
    theme_key = "LIGHT_THEME" if mode == "day" else "DARK_THEME"
    screen_section = "ScreenDay" if mode == "day" else "ScreenNight"

    current_theme = xfce_handler.get_gtk_theme()
    if conf.get("Appearance", theme_key) != current_theme:
        _cfg_mgr_desktop.set_setting(conf, "Appearance", theme_key, current_theme)
        changed = True

    current_screen = xfce_handler.get_screen_settings()
    new_temp = "" if current_screen["temperature"] is None else str(current_screen["temperature"])
    new_bright = "" if current_screen["brightness"] is None else f"{current_screen['brightness']:.2f}"
    
    if conf.get(screen_section, "XSCT_TEMP", fallback="") != new_temp:
        _cfg_mgr_desktop.set_setting(conf, screen_section, "XSCT_TEMP", new_temp)
        changed = True
    if conf.get(screen_section, "XSCT_BRIGHT", fallback="") != new_bright:
        _cfg_mgr_desktop.set_setting(conf, screen_section, "XSCT_BRIGHT", new_bright)
        changed = True

    if changed:
        log.info(f"Theme/Screen defaults updated for {mode} mode — saving config.ini")
        return _cfg_mgr_desktop.save_config(conf)

    log.info("Theme/Screen configuration already matches the current desktop; nothing to save to config.ini.")
    return True

def determine_current_period(conf: cfg.configparser.ConfigParser) -> Literal["day", "night"]:
    """Determines if it is currently day or night based on sun times."""
    from zoneinfo import ZoneInfo
    from . import sun
    try:
        lat = helpers.latlon_str_to_float(conf.get("Location", "LATITUDE"))
        lon = helpers.latlon_str_to_float(conf.get("Location", "LONGITUDE"))
        tz_name = conf.get("Location", "TIMEZONE")
        tzinfo = ZoneInfo(tz_name)
        now = datetime.now(tzinfo)
        times = sun.get_sun_times(lat, lon, now.date(), tz_name)
        return "day" if times["sunrise"] <= now < times["sunset"] else "night"
    except Exception as e:
        log.warning("Cannot compute current period (%s) — assuming night.", e)
        return "night"

def handle_internal_apply(mode: Literal["day", "night"]) -> bool:
    """Called by systemd to apply a mode."""
    log.info(f"DesktopManager: Internal apply called for mode '{mode}'.")
    try:
        return apply_mode(mode)
    except FluxFceError as e:
        log.error(f"DesktopManager: Error during internal apply for '{mode}': {e}")
        return False

def handle_run_login_check() -> bool:
    """Called on login/resume to apply the correct theme for the current time."""
    log.info("DesktopManager: Handling 'run-login-check'...")
    conf = _load_cfg()
    mode_to_apply = determine_current_period(conf)
    log.info(f"Login/resume check determined mode '{mode_to_apply}'. Applying now.")
    return apply_mode(mode_to_apply)

##############
fluxfce_core/exceptions.py

# fluxfce_core/exceptions.py
"""
Custom exception classes for the FluxFCE core library.

These exceptions provide more specific error information than built-in
exceptions, allowing for more targeted error handling by callers.
All custom exceptions inherit from the base `FluxFceError`.
"""
class FluxFceError(Exception):
    """Base exception for fluxfce core errors."""

    pass


class ConfigError(FluxFceError):
    """Errors related to configuration loading, saving, or validation."""

    pass


class CalculationError(FluxFceError):
    """Errors during sunrise/sunset calculation."""

    pass


class XfceError(FluxFceError):
    """Errors interacting with xfconf-query or xsct."""

    pass


class SchedulerError(FluxFceError):
    """Errors interacting with atd (at, atq, atrm)."""

    pass


class SystemdError(FluxFceError):
    """Errors interacting with systemctl."""

    pass


class DependencyError(FluxFceError):
    """Errors due to missing external command dependencies."""

    pass


class ValidationError(FluxFceError):
    """Errors for invalid user input or data formats."""

    pass


##############
fluxfce_core/helpers.py

# ~/dev/fluxfce-simplified/fluxfce_core/helpers.py
"""
Utility functions for the FluxFCE core library.

This module provides a collection of helper functions used by other
modules within `fluxfce_core`. These include utilities for:
- Running external commands.
- Checking for system dependencies.
- Detecting the system's IANA timezone.
- Validating and converting data (e.g., coordinates, hex colors).
- Basic library logging setup.
"""

import logging
import os
import pathlib
import re
import shutil
import subprocess
from typing import Optional

try:
    from zoneinfo import ZoneInfo, ZoneInfoNotFoundError
except ImportError:
    raise ImportError(
        "Required module 'zoneinfo' not found. FluxFCE requires Python 3.9+."
    )
# Import custom exceptions from within the same package
from .exceptions import DependencyError, FluxFceError, ValidationError

# Setup a logger specific to this module for internal debugging
log = logging.getLogger(__name__)

# --- Command Execution ---


def run_command(
    cmd_list: list[str],
    check: bool = False,
    capture: bool = True,
    input_str: Optional[str] = None,
) -> tuple[int, str, str]:
    """
    Runs an external command and returns its status, stdout, and stderr.

    Args:
        cmd_list: The command and its arguments as a list of strings.
        check: If True, raise CalledProcessError if the command returns non-zero.
               (Note: Generally, we'll use check=False and handle errors based
               on the return code in the calling function for more specific
               exception types).
        capture: If True (default), capture stdout and stderr. If False, they are
                 not captured (sent to system stdout/stderr).
        input_str: Optional string to pass as standard input to the command.

    Returns:
        A tuple containing: (return_code, stdout_str, stderr_str).
        stdout_str and stderr_str will be empty if capture=False.

    Raises:
        FileNotFoundError: If the command executable is not found.
        subprocess.CalledProcessError: If check=True and the command fails.
        Exception: For other unexpected subprocess errors.
    """
    log.debug(f"Running command: {' '.join(cmd_list)}")
    stdout_pipe = subprocess.PIPE if capture else None
    stderr_pipe = subprocess.PIPE if capture else None

    try:
        process = subprocess.run(
            cmd_list,
            check=check,  # Let CalledProcessError be raised if check is True
            input=input_str,
            stdout=stdout_pipe,
            stderr=stderr_pipe,
            text=True,
            encoding="utf-8",
        )
        stdout = process.stdout.strip() if process.stdout and capture else ""
        stderr = process.stderr.strip() if process.stderr and capture else ""
        log.debug(f"Command '{cmd_list[0]}' finished with code {process.returncode}")
        if stdout and capture:
            log.debug(f"stdout: {stdout[:200]}...")  # Log truncated stdout
        if stderr and capture:
            log.debug(f"stderr: {stderr[:200]}...")  # Log truncated stderr
        return process.returncode, stdout, stderr
    except FileNotFoundError as e:
        # This specific error is often critical and worth propagating
        log.error(f"Command not found: {cmd_list[0]} - {e}")
        raise FileNotFoundError(
            f"Required command '{cmd_list[0]}' not found in PATH."
        ) from e
    except subprocess.CalledProcessError as e:
        # Log details if check=True caused the exception
        # The caller should handle this if check=True was intentional
        stdout = e.stdout.strip() if e.stdout and capture else ""
        stderr = e.stderr.strip() if e.stderr and capture else ""
        log.warning(
            f"Command failed with exit code {e.returncode}: {' '.join(cmd_list)}"
        )
        if stdout:
            log.warning(f"stdout: {stdout[:200]}...")
        if stderr:
            log.warning(f"stderr: {stderr[:200]}...")
        raise  # Re-raise the original exception if check=True
    except Exception as e:
        log.exception(
            f"An unexpected error occurred running command: {' '.join(cmd_list)} - {e}"
        )
        # Wrap unexpected errors in our base exception type
        raise FluxFceError(
            f"Unexpected error running command '{cmd_list[0]}': {e}"
        ) from e


# --- Dependency Checks ---


def check_dependencies(deps: list[str]) -> bool:
    """
    Checks if required external commands exist in PATH using shutil.which.

    Args:
        deps: A list of command names to check (e.g., ['xfconf-query', 'xsct']).

    Returns:
        True if all dependencies are found.

    Raises:
        DependencyError: If one or more dependencies are not found.
    """
    log.debug(f"Checking for dependencies: {', '.join(deps)}")
    missing = []
    for dep in deps:
        if shutil.which(dep) is None:  # shutil.which returns None if not found
            missing.append(dep)

    if missing:
        error_msg = (
            f"Missing required command(s): {', '.join(missing)}. Please install them."
        )
        log.error(error_msg)
        raise DependencyError(error_msg)

    log.debug(f"All dependencies checked successfully: {', '.join(deps)}")
    return True


def check_atd_service() -> bool:
    """
    Checks if the 'atd' service appears to be running via systemctl.

    Returns:
        True if the service is detected as active.

    Raises:
        DependencyError: If 'systemctl' command is not found.
        FluxFceError: For unexpected errors during the check or if the
                      service is confirmed not to be active.
    """
    log.debug("Checking if atd service is active...")
    # Ensure systemctl exists first
    check_dependencies(["systemctl"])

    try:
        # Check system service first
        code_sys, _, err_sys = run_command(
            ["systemctl", "is-active", "--quiet", "atd.service"]
        )
        # --quiet: return code 0 for active, non-zero otherwise (usually 3 for inactive)

        if code_sys == 0:
            log.debug("System 'atd' service reported as active.")
            return True

        log.debug(
            f"System 'atd' not active (code: {code_sys}). Checking user service..."
        )
        # Check user service as fallback (less common for atd)
        code_user, _, err_user = run_command(
            ["systemctl", "--user", "is-active", "--quiet", "atd.service"]
        )

        if code_user == 0:
            log.debug("User 'atd' service reported as active.")
            return True

        # If neither is active
        error_msg = "The 'atd' service (system or user) is not active. Automatic scheduling requires 'atd'. Please install and enable it (e.g., 'sudo systemctl enable --now atd')."
        log.error(error_msg)
        # Use FluxFceError as it's a runtime state issue, not a missing binary
        raise FluxFceError(error_msg)

    except (
        FileNotFoundError
    ):  # Should be caught by check_dependencies, but belts and suspenders
        raise DependencyError(
            "The 'systemctl' command was not found, cannot check 'atd' status."
        )
    except Exception as e:
        # Catch potential errors from run_command itself or re-raised CalledProcessError
        log.exception(f"Failed to check 'atd' status: {e}")
        raise FluxFceError(f"Failed to check 'atd' status: {e}") from e


# --- Detect timezone ---
def detect_system_timezone() -> Optional[str]:
    """
    Attempts to detect the system's configured IANA timezone name.

    Tries methods in order: TZ env var, timedatectl, /etc/localtime symlink, /etc/timezone file.

    Returns:
        The detected IANA timezone name (str) if found and valid, otherwise None.
    """
    log.debug("Attempting to detect system timezone...")

    def _is_valid_timezone(tz_name: Optional[str]) -> bool:
        """Helper to validate a potential timezone name."""
        if not tz_name or not isinstance(tz_name, str):
            return False
        try:
            ZoneInfo(tz_name)
            log.debug(f"Validated timezone '{tz_name}' successfully.")
            return True
        except ZoneInfoNotFoundError:
            log.debug(f"ZoneInfoNotFoundError for '{tz_name}'.")
            return False
        except Exception as e:
            log.warning(f"Error validating timezone '{tz_name}' with ZoneInfo: {e}")
            return False

    # 1. Check TZ environment variable first (overrides system settings)
    tz_env = os.environ.get("TZ")
    if tz_env:
        tz_env_cleaned = tz_env.lstrip(":")
        log.debug(
            f"Found TZ environment variable: '{tz_env}' (cleaned: '{tz_env_cleaned}')"
        )
        if _is_valid_timezone(tz_env_cleaned):
            log.info(f"Using timezone from TZ environment variable: {tz_env_cleaned}")
            return tz_env_cleaned
        else:
            log.warning(
                f"TZ environment variable ('{tz_env}') is set but not a valid timezone name."
            )

    # 2. Try timedatectl (systemd)
    try:
        check_dependencies(["timedatectl"])  # Check if command exists
        cmd = ["timedatectl", "show", "--property=Timezone", "--value"]
        code, stdout, stderr = run_command(cmd)
        if code == 0 and stdout:
            tz_name = stdout.strip()
            log.debug(f"timedatectl returned: '{tz_name}'")
            if _is_valid_timezone(tz_name):
                log.info(f"Detected timezone via timedatectl: {tz_name}")
                return tz_name
            else:
                log.warning(f"timedatectl returned invalid timezone: '{tz_name}'")
        else:
            log.debug(f"timedatectl command failed or returned empty (code: {code})")
    except DependencyError:
        log.debug("timedatectl command not found, skipping.")
    except Exception as e:
        log.warning(f"Error running timedatectl: {e}")

    # 3. Try /etc/localtime symlink
    localtime_path = pathlib.Path("/etc/localtime")
    if localtime_path.is_symlink():
        try:
            target = localtime_path.readlink()  # Read the target path object
            zoneinfo_dir = pathlib.Path("/usr/share/zoneinfo")
            if not target.is_absolute():
                target = (localtime_path.parent / target).resolve()
            if zoneinfo_dir in target.parents or str(target).startswith(
                str(zoneinfo_dir)
            ):
                try:
                    tz_name = str(target.relative_to(zoneinfo_dir))
                    log.debug(
                        f"/etc/localtime points to '{target}', relative zoneinfo path: '{tz_name}'"
                    )
                    if _is_valid_timezone(tz_name):
                        log.info(
                            f"Detected timezone via /etc/localtime symlink: {tz_name}"
                        )
                        return tz_name
                    else:
                        log.warning(
                            f"Extracted path '{tz_name}' from /etc/localtime link is not a valid timezone."
                        )
                except ValueError:
                    log.warning(
                        f"Could not determine relative path for localtime target '{target}' within '{zoneinfo_dir}'."
                    )
            else:
                log.debug(
                    f"/etc/localtime target '{target}' is outside standard zoneinfo directory."
                )
        except OSError as e:
            log.warning(f"Could not read /etc/localtime symlink: {e}")
        except Exception as e:
            log.exception(f"Unexpected error processing /etc/localtime link: {e}")

    # 4. Try /etc/timezone file (Debian/Ubuntu)
    timezone_path = pathlib.Path("/etc/timezone")
    if timezone_path.is_file():
        try:
            content = timezone_path.read_text(encoding="utf-8").strip()
            if content:
                tz_name = content.splitlines()[0].split()[0]
                log.debug(f"Read from /etc/timezone: '{tz_name}'")
                if _is_valid_timezone(tz_name):
                    log.info(f"Detected timezone via /etc/timezone file: {tz_name}")
                    return tz_name
                else:
                    log.warning(
                        f"Content of /etc/timezone ('{tz_name}') is not a valid timezone."
                    )
            else:
                log.debug("/etc/timezone file is empty.")
        except OSError as e:
            log.warning(f"Could not read /etc/timezone: {e}")
        except Exception as e:
            log.exception(f"Unexpected error processing /etc/timezone: {e}")

    # 5. Fallback - Could not detect
    log.warning("Failed to detect system timezone using common methods.")
    return None


# --- Data Validation ---


def latlon_str_to_float(coord_str: str) -> float:
    """
    Converts Lat/Lon string (e.g., '43.65N', '79.38W') to float degrees.

    Args:
        coord_str: The coordinate string to parse.

    Returns:
        The coordinate as a float value.

    Raises:
        ValidationError: If the format is invalid or the value is out of range.
    """
    if not isinstance(coord_str, str):
        raise ValidationError(
            f"Invalid input type for coordinate: expected string, got {type(coord_str)}"
        )

    coord_strip = coord_str.strip().upper()
    match = re.match(r"^(\d+(\.\d+)?)([NSEW])$", coord_strip)
    if not match:
        raise ValidationError(
            f"Invalid coordinate format: '{coord_str}'. Use format like '43.65N' or '79.38W'."
        )

    try:
        value = float(match.group(1))
    except ValueError:
        # Should not happen with the regex, but safeguard
        raise ValidationError(
            f"Could not convert value part '{match.group(1)}' to float."
        )

    direction = match.group(3)
    if direction in ("S", "W"):
        value = -value

    # Range check
    if direction in ("N", "S") and not (-90 <= value <= 90):
        raise ValidationError(
            f"Latitude out of range (-90 to 90): {value} ({coord_str})"
        )
    if direction in ("E", "W") and not (-180 <= value <= 180):
        raise ValidationError(
            f"Longitude out of range (-180 to 180): {value} ({coord_str})"
        )

    log.debug(f"Converted coordinate '{coord_str}' to {value}")
    return value


def hex_to_rgba_doubles(hex_color: str) -> list[float]:
    """
    Converts a 6-digit hex color string (#RRGGBB or RRGGBB) to RGBA doubles
    [R, G, B, A] (0.0-1.0), with Alpha always 1.0.

    Args:
        hex_color: The 6-digit hex color string.

    Returns:
        A list of four floats [R, G, B, A] between 0.0 and 1.0.

    Raises:
        ValidationError: If the hex string format is invalid.
    """
    if not isinstance(hex_color, str):
        raise ValidationError(
            f"Invalid input type for hex color: expected string, got {type(hex_color)}"
        )

    hex_strip = hex_color.lstrip("#")
    if not re.match(r"^[0-9a-fA-F]{6}$", hex_strip):
        raise ValidationError(f"Invalid 6-digit hex color format: '{hex_color}'")

    try:
        r = int(hex_strip[0:2], 16) / 255.0
        g = int(hex_strip[2:4], 16) / 255.0
        b = int(hex_strip[4:6], 16) / 255.0
        rgba = [r, g, b, 1.0]  # R, G, B, Alpha
        log.debug(f"Converted hex '{hex_color}' to RGBA {rgba}")
        return rgba
    except ValueError as e:
        # Should not happen with regex, but safeguard
        raise ValidationError(
            f"Could not convert hex components to integer: '{hex_color}' - {e}"
        ) from e


# --- Logging Setup (Simplified for Core Library) ---


def setup_library_logging(level=logging.WARNING):
    """
    Configures basic logging for the fluxfce_core library components.
    This is primarily intended for internal debugging and might be overridden
    by the calling application (GUI/CLI). By default, sets a higher level
    to avoid polluting the output of the consuming application unless
    debugging is explicitly enabled.
    """
    # Configure logging for the entire 'fluxfce_core' package namespace
    package_logger = logging.getLogger("fluxfce_core")

    # Avoid adding multiple handlers if called repeatedly
    if not package_logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter(
            "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
        )
        handler.setFormatter(formatter)
        package_logger.addHandler(handler)

    package_logger.setLevel(level)
    log.info(f"fluxfce_core logging configured to level: {logging.getLevelName(level)}")


# Example of how to potentially enable debug logging from outside:
# import logging
# from fluxfce_core import helpers
# helpers.setup_library_logging(level=logging.DEBUG)


##############
fluxfce_core/__init__.py

# fluxfce_core/__init__.py

# Make exceptions available directly
from .exceptions import (
    CalculationError,
    ConfigError,
    DependencyError,
    FluxFceError,
    SystemdError,
    ValidationError,
    XfceError,
)

# Make public API functions (now via the api.py facade) available
from .api import (
    apply_manual_mode,
    apply_temporary_mode,
    disable_scheduling,
    enable_scheduling,
    get_current_config,
    get_status,
    handle_internal_apply,
    handle_run_login_check,
    handle_schedule_dynamic_transitions_command,
    install_default_background_profiles,  # <-- ADDED THIS LINE
    install_fluxfce,
    save_configuration,
    set_default_from_current,
    uninstall_fluxfce,
)

# --- Make core constants accessible ---
from .config import CONFIG_DIR, CONFIG_FILE, DEFAULT_CONFIG
from .helpers import detect_system_timezone

# --- ADD SYSTEMD CONSTANTS ---
from .systemd import (
    LOGIN_SERVICE_NAME,
    RESUME_SERVICE_NAME,
    SCHEDULER_SERVICE_NAME,
    SCHEDULER_TIMER_NAME,
    SUNRISE_EVENT_TIMER_NAME,
    SUNSET_EVENT_TIMER_NAME,
)

__all__ = [
    # Constants from config.py
    "CONFIG_DIR",
    "CONFIG_FILE",
    "DEFAULT_CONFIG",
    # Constants from systemd.py
    "LOGIN_SERVICE_NAME",
    "RESUME_SERVICE_NAME",
    "SCHEDULER_SERVICE_NAME",
    "SCHEDULER_TIMER_NAME",
    "SUNRISE_EVENT_TIMER_NAME",
    "SUNSET_EVENT_TIMER_NAME",
    # Exceptions
    "CalculationError",
    "ConfigError",
    "DependencyError",
    "FluxFceError",
    "SystemdError",
    "ValidationError",
    "XfceError",
    # API Functions (from api.py facade)
    "apply_manual_mode",
    "apply_temporary_mode",
    "disable_scheduling",
    "enable_scheduling",
    "get_current_config",
    "get_status",
    "install_default_background_profiles",  # <-- AND ADDED THIS LINE
    "install_fluxfce",
    "save_configuration",
    "set_default_from_current",
    "uninstall_fluxfce",
    # Internal Handlers (available for CLI, routed through api.py)
    "handle_internal_apply",
    "handle_run_login_check",
    "handle_schedule_dynamic_transitions_command",
    # Helper Functions
    "detect_system_timezone",
]

##############
fluxfce_core/scheduler.py

# fluxfce_core/scheduler.py
"""
Manages Systemd-based scheduling for FluxFCE.

This module handles the creation and management of dynamic systemd timers
for sunrise/sunset events and the main daily scheduler task.
"""

import logging
from datetime import datetime, timedelta
from typing import Optional

# Imports from within fluxfce_core
from . import config as cfg # For get_current_config via _load_config_with_defaults if not passed
from . import exceptions as exc
from . import helpers, sun, systemd as sysd # Use sysd alias for clarity

# For type hinting configparser object if passed directly
import configparser 

# zoneinfo needed for sun time calculations here
try:
    from zoneinfo import (
        ZoneInfo,
        ZoneInfoNotFoundError,
    )
except ImportError:
    raise ImportError(
        "Required module 'zoneinfo' not found. FluxFCE requires Python 3.9+."
    )

log = logging.getLogger(__name__)

# --- Private Helper to Load Config (if needed, similar to desktop_manager) ---
# This assumes we might need to load config if not passed around explicitly
# Or, these functions can be modified to accept a config_obj if preferred
_cfg_mgr_scheduler = cfg.ConfigManager() # Module-level instance

def _load_scheduler_config() -> configparser.ConfigParser:
    """Loads configuration for scheduler functions."""
    # This reuses the existing ConfigManager logic.
    # No need to re-implement _load_config_with_defaults here if it's generic enough.
    # Let's assume get_current_config from api.py (or its future equivalent) is preferred.
    # For now, we'll replicate a simple load for self-containment,
    # but this could be refactored to use a shared config loading utility.
    try:
        return _cfg_mgr_scheduler.load_config()
    except exc.ConfigError as e:
        log.error(f"Scheduler: Failed to load configuration: {e}")
        raise
    except Exception as e:
        log.exception(f"Scheduler: Unexpected error loading configuration: {e}")
        raise exc.FluxFceError(f"Scheduler: Unexpected error loading configuration: {e}") from e

_sysd_mgr_scheduler = sysd.SystemdManager() # Module-level instance for SystemdManager


# --- Scheduling Functions (Moved from api.py) ---

def handle_schedule_dynamic_transitions_command(
    python_exe_path: str, script_exe_path: str
) -> bool:
    """
    Calculates next sun events, writes dynamic systemd timer files, reloads the
    systemd daemon, and starts the dynamic timers.
    Called by the fluxfce-scheduler.service.
    """
    log.info("Scheduler: Handling 'schedule-dynamic-transitions' command...")
    try:
        # current_config = get_current_config() # Original call
        current_config = _load_scheduler_config() # Use local loader or pass config_obj

        lat_str = current_config.get("Location", "LATITUDE")
        lon_str = current_config.get("Location", "LONGITUDE")
        tz_name = current_config.get("Location", "TIMEZONE")

        if not all([lat_str, lon_str, tz_name, 
                    lat_str != "Not Set", lon_str != "Not Set", tz_name != "Not Set"]):
            raise exc.ConfigError("Scheduler: Location (latitude, longitude, timezone) not fully configured.")

        lat = helpers.latlon_str_to_float(lat_str)
        lon = helpers.latlon_str_to_float(lon_str)
        
        try:
            local_tz = ZoneInfo(tz_name)
        except ZoneInfoNotFoundError as e_tz:
            raise exc.ConfigError(f"Scheduler: Invalid timezone in configuration: {tz_name}") from e_tz

        now_local = datetime.now(local_tz)
        today_local = now_local.date()
        next_event_times: dict[str, Optional[datetime]] = {"day": None, "night": None}

        for day_offset in range(2): # Check today and tomorrow
            target_date = today_local + timedelta(days=day_offset)
            try:
                sun_times = sun.get_sun_times(lat, lon, target_date, tz_name)
                if not next_event_times["day"] and sun_times["sunrise"] > now_local:
                    next_event_times["day"] = sun_times["sunrise"]
                if not next_event_times["night"] and sun_times["sunset"] > now_local:
                    next_event_times["night"] = sun_times["sunset"]
            except exc.CalculationError as e:
                log.warning(f"Scheduler: Could not calculate sun times for {target_date}: {e}")
            if next_event_times["day"] and next_event_times["night"]:
                break
        
        _sysd_mgr_scheduler._run_systemctl(
            ["stop", sysd.SUNRISE_EVENT_TIMER_NAME, sysd.SUNSET_EVENT_TIMER_NAME],
            check_errors=False, capture_output=True
        )

        scheduled_any_timer = False
        utc_tz = ZoneInfo("UTC")

        if next_event_times["day"]:
            utc_event_time = next_event_times["day"].astimezone(utc_tz)
            _sysd_mgr_scheduler.write_dynamic_event_timer_unit_file("day", utc_event_time)
            scheduled_any_timer = True
            log.info(f"Scheduler: Dynamic timer for SUNRISE prepared for: {utc_event_time.isoformat()}")
        else:
            log.warning("Scheduler: No upcoming sunrise event found. Removing existing timer if any.")
            (sysd.SYSTEMD_USER_DIR / sysd.SUNRISE_EVENT_TIMER_NAME).unlink(missing_ok=True)

        if next_event_times["night"]:
            utc_event_time = next_event_times["night"].astimezone(utc_tz)
            _sysd_mgr_scheduler.write_dynamic_event_timer_unit_file("night", utc_event_time)
            scheduled_any_timer = True
            log.info(f"Scheduler: Dynamic timer for SUNSET prepared for: {utc_event_time.isoformat()}")
        else:
            log.warning("Scheduler: No upcoming sunset event found. Removing existing timer if any.")
            (sysd.SYSTEMD_USER_DIR / sysd.SUNSET_EVENT_TIMER_NAME).unlink(missing_ok=True)

        _sysd_mgr_scheduler._run_systemctl(["daemon-reload"], capture_output=True)

        if next_event_times["day"]:
            _sysd_mgr_scheduler._run_systemctl(["start", sysd.SUNRISE_EVENT_TIMER_NAME], check_errors=False, capture_output=True)
        if next_event_times["night"]:
            _sysd_mgr_scheduler._run_systemctl(["start", sysd.SUNSET_EVENT_TIMER_NAME], check_errors=False, capture_output=True)
        
        if not scheduled_any_timer:
            log.warning("Scheduler: No sun event timers could be scheduled (e.g. polar day/night).")
        else:
            log.info("Scheduler: Dynamic event timers (re)written, daemon reloaded, and timers (re)started.")
        return True

    except (exc.ConfigError, exc.ValidationError, exc.SystemdError, exc.FluxFceError) as e:
        log.error(f"Scheduler: Failed to schedule dynamic transitions: {e}")
        return False
    except Exception as e:
        log.exception(f"Scheduler: Unexpected error during 'schedule-dynamic-transitions': {e}")
        return False

def enable_scheduling(
    python_exe_path: str,
    script_exe_path: str,
    # It's good practice for higher-level functions like this to call lower-level ones.
    # We'll need access to the desktop_manager's apply current function.
    # For now, let's assume it will be called from api.py after this returns.
    # Or we could import desktop_manager here if we make it a hard dependency.
    # Let's keep it simple for now and assume api.py handles the apply_current_period.
) -> bool:
    """
    Enables automatic theme transitions:
    1. Defines dynamic event timers for the next sunrise/sunset.
    2. Enables and starts the main daily scheduler timer (`fluxfce-scheduler.timer`).
    """
    # Note: The application of the current theme (via handle_run_login_check)
    # will be handled by the calling function in api.py after this function succeeds.

    log.info("Scheduler: Enabling scheduling with dynamic systemd timers...")
    try:
        define_schedule_ok = handle_schedule_dynamic_transitions_command(
            python_exe_path=python_exe_path, script_exe_path=script_exe_path
        )
        if not define_schedule_ok:
            log.warning("Scheduler: Initial definition of dynamic event timers failed or scheduled nothing, "
                        "but proceeding to enable the main daily scheduler.")

        code, _, stderr = _sysd_mgr_scheduler._run_systemctl(
            ["enable", "--now", sysd.SCHEDULER_TIMER_NAME], capture_output=True
        )
        if code != 0:
            raise exc.SystemdError(
                f"Scheduler: Failed to enable and start main scheduler timer ({sysd.SCHEDULER_TIMER_NAME}): {stderr.strip()}"
            )
        
        log.info(f"Scheduler: Main scheduler ({sysd.SCHEDULER_TIMER_NAME}) enabled; its service runs once now to set schedule.")
        log.info("Scheduler: Scheduling setup completed successfully by scheduler module.")
        return True
        
    except (exc.SystemdError, exc.FluxFceError) as e: 
        log.error(f"Scheduler: Failed to enable scheduling: {e}")
        raise 
    except Exception as e: 
        log.exception(f"Scheduler: Unexpected error enabling scheduling: {e}")
        raise exc.FluxFceError(f"Scheduler: An unexpected error occurred while enabling scheduling: {e}") from e

def disable_scheduling() -> bool:
    """
    Disables automatic theme transitions.
    """
    log.info("Scheduler: Disabling scheduling and removing dynamic systemd timers...")
    try:
        _sysd_mgr_scheduler._run_systemctl(["stop", sysd.SCHEDULER_TIMER_NAME], check_errors=False, capture_output=True)
        _sysd_mgr_scheduler._run_systemctl(["disable", sysd.SCHEDULER_TIMER_NAME], check_errors=False, capture_output=True)
        log.debug(f"Scheduler: Main scheduler timer ({sysd.SCHEDULER_TIMER_NAME}) stopped and disabled.")

        _sysd_mgr_scheduler._run_systemctl(["stop", sysd.SUNRISE_EVENT_TIMER_NAME], check_errors=False, capture_output=True)
        _sysd_mgr_scheduler._run_systemctl(["stop", sysd.SUNSET_EVENT_TIMER_NAME], check_errors=False, capture_output=True)
        log.debug("Scheduler: Dynamic event timers stopped.")

        for timer_name in [sysd.SUNRISE_EVENT_TIMER_NAME, sysd.SUNSET_EVENT_TIMER_NAME]:
            timer_path = sysd.SYSTEMD_USER_DIR / timer_name
            try:
                timer_path.unlink(missing_ok=True)
                log.debug(f"Scheduler: Removed {timer_name} (if existed).")
            except OSError as e:
                log.warning(f"Scheduler: Could not remove {timer_name}: {e}")

        _sysd_mgr_scheduler._run_systemctl(["daemon-reload"], capture_output=True)
        log.debug("Scheduler: Systemd daemon reloaded.")
        
        units_to_reset = [
            sysd.SCHEDULER_TIMER_NAME, 
            sysd.SUNRISE_EVENT_TIMER_NAME, 
            sysd.SUNSET_EVENT_TIMER_NAME,
            sysd.SCHEDULER_SERVICE_NAME 
        ]
        _sysd_mgr_scheduler._run_systemctl(["reset-failed", *units_to_reset], check_errors=False, capture_output=True)

        log.info("Scheduler: Scheduling disabled successfully.")
        return True

    except (exc.SystemdError, exc.FluxFceError) as e:
        log.error(f"Scheduler: Failed to disable scheduling: {e}")
        raise
    except Exception as e:
        log.exception(f"Scheduler: Unexpected error disabling scheduling: {e}")
        raise exc.FluxFceError(f"Scheduler: An unexpected error occurred while disabling scheduling: {e}") from e

##############
fluxfce_core/sun.py

# ~/dev/fluxfce-simplified/fluxfce_core/sun.py
"""
Sunrise and sunset time calculations for FluxFCE.

This module uses an adaptation of the NOAA algorithm to determine civil
twilight (sunrise/sunset) times for a given geographic location and date.
It accounts for timezone conversions to provide local event times.
"""

import logging
import math
from datetime import date, datetime, timedelta, timezone

# zoneinfo is standard library in Python 3.9+
try:
    from zoneinfo import ZoneInfo, ZoneInfoNotFoundError
except ImportError:
    # This is a critical dependency failure if zoneinfo is expected
    raise ImportError(
        "Required module 'zoneinfo' not found. FluxFCE requires Python 3.9+."
    )

# Import custom exceptions from within the same package
from .exceptions import CalculationError, ValidationError

log = logging.getLogger(__name__)


# --- Internal Sun Calculation Algorithm ---


def _noaa_sunrise_sunset(
    *, lat: float, lon: float, target_date: date
) -> tuple[float, float]:
    """
    Internal NOAA algorithm to calculate UTC sunrise/sunset times in minutes past midnight.

    Based on NOAA Javascript: www.esrl.noaa.gov/gmd/grad/solcalc/calcdetails.html

    Args:
        lat: Latitude in decimal degrees (-90 to 90).
        lon: Longitude in decimal degrees (-180 to 180).
        target_date: The specific date for calculation.

    Returns:
        A tuple (sunrise_utc_minutes, sunset_utc_minutes).

    Raises:
        CalculationError: If latitude/longitude are out of range, or for
                          polar day/night conditions where calculation fails.
    """
    log.debug(
        f"Calculating NOAA sun times for lat={lat}, lon={lon}, date={target_date}"
    )
    # Validate latitude/longitude ranges (redundant if called via get_sun_times which validates input strings, but good practice)
    if not (-90 <= lat <= 90):
        raise CalculationError(
            f"Invalid latitude for calculation: {lat}. Must be between -90 and 90."
        )
    if not (-180 <= lon <= 180):
        raise CalculationError(
            f"Invalid longitude for calculation: {lon}. Must be between -180 and 180."
        )

    n = target_date.timetuple().tm_yday  # Day of year
    longitude = lon  # Use validated input directly

    # Equation of Time and Declination (approximation)
    gamma = (2 * math.pi / 365) * (
        n - 1 + (12 - (longitude / 15)) / 24
    )  # Fractional year
    eqtime = 229.18 * (
        0.000075
        + 0.001868 * math.cos(gamma)
        - 0.032077 * math.sin(gamma)
        - 0.014615 * math.cos(2 * gamma)
        - 0.040849 * math.sin(2 * gamma)
    )
    decl = (
        0.006918
        - 0.399912 * math.cos(gamma)
        + 0.070257 * math.sin(gamma)
        - 0.006758 * math.cos(2 * gamma)
        + 0.000907 * math.sin(2 * gamma)
        - 0.002697 * math.cos(3 * gamma)
        + 0.00148 * math.sin(3 * gamma)
    )

    # Hour Angle Calculation
    lat_rad = math.radians(lat)
    # Zenith for sunrise/sunset (geometric center of sun) - 90.833 degrees
    # includes refraction and sun radius adjustment
    cos_zenith = math.cos(math.radians(90.833))
    try:
        # Argument for arccos to find hour angle
        cos_h_arg = (cos_zenith - math.sin(lat_rad) * math.sin(decl)) / (
            math.cos(lat_rad) * math.cos(decl)
        )
    except ZeroDivisionError:
        # This can happen near the poles if cos(decl) is near zero
        raise CalculationError(
            "Division by zero encountered during hour angle calculation (likely near poles)."
        )

    # Check for polar day/night conditions
    if cos_h_arg > 1.0:
        # Sun never rises (polar night)
        raise CalculationError(
            f"Sun never rises on {target_date} at lat {lat} (polar night)."
        )
    if cos_h_arg < -1.0:
        # Sun never sets (polar day)
        raise CalculationError(
            f"Sun never sets on {target_date} at lat {lat} (polar day)."
        )

    try:
        ha_rad = math.acos(cos_h_arg)  # Hour angle in radians
        ha_minutes = 4 * math.degrees(
            ha_rad
        )  # Convert hour angle to minutes (15 deg/hour * 4 min/deg)
    except ValueError as e:
        # Should not happen due to checks above, but safeguard
        raise CalculationError(f"Error calculating arccos for hour angle: {e}") from e

    # Solar noon (in minutes from UTC midnight)
    solar_noon_utc_min = 720 - 4 * longitude - eqtime  # 720 = 12 * 60

    sunrise_utc_min = solar_noon_utc_min - ha_minutes
    sunset_utc_min = solar_noon_utc_min + ha_minutes

    log.debug(
        f"Calculated UTC times (minutes from midnight): sunrise={sunrise_utc_min:.2f}, sunset={sunset_utc_min:.2f}"
    )
    return sunrise_utc_min, sunset_utc_min


# --- Public API for Sun Times ---


def get_sun_times(
    lat: float, lon: float, target_date: date, tz_name: str
) -> dict[str, datetime]:
    """
    Calculates sunrise and sunset times, returning them as timezone-aware datetimes.

    Args:
        lat: Latitude in decimal degrees (-90 to 90).
        lon: Longitude in decimal degrees (-180 to 180).
        target_date: The date for which to calculate times.
        tz_name: The IANA timezone name (e.g., 'America/Toronto').

    Returns:
        A dictionary {'sunrise': datetime_obj, 'sunset': datetime_obj} where
        datetime objects are timezone-aware for the specified tz_name.

    Raises:
        ValidationError: If the timezone name is invalid or not found by zoneinfo.
        CalculationError: If the underlying NOAA calculation fails (e.g., invalid
                          lat/lon passed internally, polar day/night).
    """
    log.debug(
        f"Getting sun times for lat={lat}, lon={lon}, date={target_date}, timezone={tz_name}"
    )
    try:
        tz_info = ZoneInfo(tz_name)
    except ZoneInfoNotFoundError:
        log.error(f"Invalid or unknown IANA Timezone Name: '{tz_name}'")
        raise ValidationError(f"Invalid or unknown IANA Timezone Name: '{tz_name}'")
    except Exception as e:  # Catch other potential zoneinfo errors
        log.error(f"Error loading timezone '{tz_name}': {e}")
        raise ValidationError(f"Error loading timezone '{tz_name}': {e}") from e

    try:
        # Call the internal algorithm
        sunrise_min, sunset_min = _noaa_sunrise_sunset(
            lat=lat, lon=lon, target_date=target_date
        )
    except CalculationError as e:
        # Propagate calculation errors (like polar day/night)
        log.error(f"Sun time calculation failed: {e}")
        raise  # Re-raise the specific CalculationError

    # Convert minutes from UTC midnight to datetime objects
    # Create a UTC midnight datetime for the target date
    utc_midnight = datetime(
        target_date.year, target_date.month, target_date.day, tzinfo=timezone.utc
    )

    # Add the calculated minutes to get the UTC event times
    sunrise_utc_dt = utc_midnight + timedelta(minutes=sunrise_min)
    sunset_utc_dt = utc_midnight + timedelta(minutes=sunset_min)

    # Convert to the target local timezone
    try:
        sunrise_local = sunrise_utc_dt.astimezone(tz_info)
        sunset_local = sunset_utc_dt.astimezone(tz_info)
    except Exception as e:
        # Handle potential errors during timezone conversion (less likely)
        log.exception(
            f"Failed to convert calculated UTC times to timezone '{tz_name}': {e}"
        )
        raise CalculationError(
            f"Failed timezone conversion for '{tz_name}': {e}"
        ) from e

    log.debug(
        f"Calculated local times: sunrise={sunrise_local.isoformat()}, sunset={sunset_local.isoformat()}"
    )
    return {"sunrise": sunrise_local, "sunset": sunset_local}


##############
fluxfce_core/systemd.py

# ~/dev/fluxfce-simplified/fluxfce_core/systemd.py
"""
Systemd user unit management for FluxFCE.

This module is responsible for creating, installing, managing, and removing
the systemd user units (timers and services) required for FluxFCE's
automatic scheduling and theme application on login/resume.
It defines the templates for these units and interacts with `systemctl`.
"""

import logging
import pathlib
import sys
from datetime import datetime # For type hinting in write_dynamic_event_timer_unit_file
from typing import Optional

# Import helpers and exceptions from within the same package
from . import helpers
from .exceptions import DependencyError, SystemdError

log = logging.getLogger(__name__)

# --- Constants ---
_APP_NAME = "fluxfce" # Application name, used in unit descriptions and names
SYSTEMD_USER_DIR = pathlib.Path.home() / ".config" / "systemd" / "user"

# --- Static Unit Names and File Paths ---
SCHEDULER_TIMER_NAME = f"{_APP_NAME}-scheduler.timer"
SCHEDULER_SERVICE_NAME = f"{_APP_NAME}-scheduler.service"
APPLY_TRANSITION_SERVICE_TEMPLATE_NAME = f"{_APP_NAME}-apply-transition@.service"
LOGIN_SERVICE_NAME = f"{_APP_NAME}-login.service"
RESUME_SERVICE_NAME = f"{_APP_NAME}-resume.service"
USER_SLEEP_TARGET_NAME = "sleep.target" # User-level anchor for sleep.target

SCHEDULER_TIMER_FILE = SYSTEMD_USER_DIR / SCHEDULER_TIMER_NAME
SCHEDULER_SERVICE_FILE = SYSTEMD_USER_DIR / SCHEDULER_SERVICE_NAME
APPLY_TRANSITION_SERVICE_TEMPLATE_FILE = SYSTEMD_USER_DIR / APPLY_TRANSITION_SERVICE_TEMPLATE_NAME
LOGIN_SERVICE_FILE = SYSTEMD_USER_DIR / LOGIN_SERVICE_NAME
RESUME_SERVICE_FILE = SYSTEMD_USER_DIR / RESUME_SERVICE_NAME
USER_SLEEP_TARGET_FILE = SYSTEMD_USER_DIR / USER_SLEEP_TARGET_NAME # Path for user-level sleep.target

# --- Dynamic Unit Names (filenames for timers generated at runtime) ---
SUNRISE_EVENT_TIMER_NAME = f"{_APP_NAME}-sunrise-event.timer"
SUNSET_EVENT_TIMER_NAME = f"{_APP_NAME}-sunset-event.timer"

# --- Lists for Management ---
STATIC_UNIT_FILES_MAP = {
    SCHEDULER_TIMER_NAME: SCHEDULER_TIMER_FILE,
    SCHEDULER_SERVICE_NAME: SCHEDULER_SERVICE_FILE,
    APPLY_TRANSITION_SERVICE_TEMPLATE_NAME: APPLY_TRANSITION_SERVICE_TEMPLATE_FILE,
    LOGIN_SERVICE_NAME: LOGIN_SERVICE_FILE,
    RESUME_SERVICE_NAME: RESUME_SERVICE_FILE,
    USER_SLEEP_TARGET_NAME: USER_SLEEP_TARGET_FILE, # Added user-level sleep.target
}

DYNAMIC_EVENT_TIMER_NAMES = [
    SUNRISE_EVENT_TIMER_NAME,
    SUNSET_EVENT_TIMER_NAME,
]

# ALL_POTENTIAL_FLUXFCE_UNIT_NAMES includes all units that fluxfce might create or manage,
# including the user-level sleep.target for cleanup with reset-failed.
ALL_POTENTIAL_FLUXFCE_UNIT_NAMES = [
    SCHEDULER_TIMER_NAME,
    SCHEDULER_SERVICE_NAME,
    f"{_APP_NAME}-apply-transition@day.service",
    f"{_APP_NAME}-apply-transition@night.service",
    LOGIN_SERVICE_NAME,
    RESUME_SERVICE_NAME,
    SUNRISE_EVENT_TIMER_NAME,
    SUNSET_EVENT_TIMER_NAME,
    USER_SLEEP_TARGET_NAME, # Added for reset-failed
]

# --- Unit File Templates ---

_SCHEDULER_TIMER_TEMPLATE = """\
[Unit]
Description={app_name}: Daily Timer to Reschedule Sunrise/Sunset Event Timers
PartOf=timers.target

[Timer]
Unit={scheduler_service_name}
OnCalendar=daily
RandomizedDelaySec=15min
Persistent=true
AccuracySec=1m

[Install]
WantedBy=timers.target
"""

_SCHEDULER_SERVICE_TEMPLATE = """\
[Unit]
Description={app_name}: Daily Service to Reschedule Sunrise/Sunset Event Timers
After=time-set.target

[Service]
Type=oneshot
ExecStart={python_executable} "{script_path}" schedule-dynamic-transitions
StandardOutput=journal
StandardError=journal
"""

_APPLY_TRANSITION_TEMPLATE = """\
[Unit]
Description={app_name}: Apply %I Mode Transition
PartOf=graphical-session.target
After=graphical-session.target xfce4-session.target
ConditionEnvironment=DISPLAY

[Service]
Type=oneshot
ExecStart={python_executable} "{script_path}" internal-apply --mode %i
StandardOutput=journal
StandardError=journal
"""

_LOGIN_SERVICE_TEMPLATE = """\
[Unit]
Description={app_name}: Apply theme on login
After=graphical-session.target xfce4-session.target plasma-workspace.target gnome-session.target
Requires=graphical-session.target
ConditionEnvironment=DISPLAY
[Service]
Type=oneshot
ExecStartPre=/bin/sleep 20
ExecStart={python_executable} "{script_path}" run-login-check
StandardError=journal
[Install]
WantedBy=graphical-session.target
"""

_RESUME_SERVICE_TEMPLATE = """\
[Unit]
Description={app_name} - Apply theme after system resume
After=sleep.target graphical-session.target
Requires=graphical-session.target
ConditionEnvironment=DISPLAY

[Service]
Type=oneshot
ExecStartPre=/bin/sleep 5
ExecStart={python_executable} "{script_path}" run-login-check
StandardError=journal

[Install]
WantedBy=sleep.target
"""

_USER_SLEEP_TARGET_TEMPLATE = """\
[Unit]
Description={app_name} User-Level Sleep Target Anchor
Documentation=man:systemd.special(7)
RefuseManualStart=yes
RefuseManualStop=yes
DefaultDependencies=no

[Install]
"""

_STATIC_UNIT_TEMPLATES = {
    SCHEDULER_TIMER_NAME: _SCHEDULER_TIMER_TEMPLATE,
    SCHEDULER_SERVICE_NAME: _SCHEDULER_SERVICE_TEMPLATE,
    APPLY_TRANSITION_SERVICE_TEMPLATE_NAME: _APPLY_TRANSITION_TEMPLATE,
    LOGIN_SERVICE_NAME: _LOGIN_SERVICE_TEMPLATE,
    RESUME_SERVICE_NAME: _RESUME_SERVICE_TEMPLATE,
    USER_SLEEP_TARGET_NAME: _USER_SLEEP_TARGET_TEMPLATE, # Added template for user sleep.target
}


class SystemdManager:
    """Handles creation, installation, and removal of systemd user units for fluxfce."""

    def __init__(self):
        """Check for systemctl dependency."""
        self.app_name = _APP_NAME
        try:
            helpers.check_dependencies(["systemctl"])
        except DependencyError as e:
            log.error(f"SystemdManager initialization failed: {e}")
            raise SystemdError(f"Cannot initialize SystemdManager: {e}") from e

    def _run_systemctl(
        self, args: list[str], check_errors: bool = True, capture_output: bool = False
    ) -> tuple[int, str, str]:
        """Runs a systemctl --user command."""
        cmd = ["systemctl", "--user", *args]
        try:
            # helpers.run_command captures output if capture_output is True.
            # It handles stripping stdout/stderr.
            code, stdout, stderr = helpers.run_command(cmd, check=False, capture=capture_output)
            if code != 0 and check_errors:
                # Log error only if check_errors is True and command failed.
                # stdout/stderr will be from the captured output if capture_output was True.
                # If not captured, they'll be empty strings from helpers.run_command.
                err_details = stderr.strip() if stderr else stdout.strip() # Prefer stderr for error details
                log.error(
                    f"systemctl --user {' '.join(args)} failed (code {code}). Details: '{err_details}'"
                )
            return code, stdout, stderr # stdout/stderr are already strings
        except FileNotFoundError:
            log.error(f"systemctl command not found when trying to run: systemctl --user {' '.join(args)}")
            raise DependencyError("systemctl command not found.")
        except Exception as e:
            log.exception(f"Unexpected error running systemctl command: systemctl --user {' '.join(args)}")
            raise SystemdError(
                f"Unexpected error running systemctl command 'systemctl --user {' '.join(args)}': {e}"
            ) from e

    def check_user_instance(self) -> bool:
        """
        Checks if the systemd user instance appears to be running and in a usable state.
        Raises SystemdError if the instance is not in a good state.
        """
        log.debug("Checking systemd user instance status...")
        code, stdout, stderr = self._run_systemctl(
            ["is-system-running"], check_errors=False, capture_output=True
        )
        
        status_output = stdout.strip().lower()

        if code == 0: # is-system-running returns 0 for "running", "degraded", etc.
            if status_output == "running":
                log.info(f"Systemd user instance reported: '{status_output}'.")
                return True
            elif status_output == "degraded":
                log.warning(
                    f"Systemd user instance reported: '{status_output}'. "
                    f"{self.app_name} functionality might be limited or unreliable."
                )
                return True # Still allow proceeding but with a stronger warning.
            else:
                # Other states like "stopping", "offline", "initializing", "starting"
                error_msg = (
                    f"Systemd user instance is in an ambiguous state: '{status_output}' (exit code {code}). "
                    f"While not a fatal error state according to 'is-system-running', "
                    f"this state may prevent {self.app_name} from operating correctly. "
                    f"Stderr: '{stderr.strip()}'"
                )
                log.warning(error_msg) 
                return True # Allow proceeding but highlight potential issues.
        else: # Non-zero usually means a more significant issue or "offline"
            error_msg = (
                f"Systemd user instance is not in a usable state "
                f"(command 'is-system-running' exit code: {code}, status: '{status_output}'). "
                f"Stderr: '{stderr.strip()}'. "
                f"{self.app_name} cannot proceed with systemd operations."
            )
            log.error(error_msg)
            raise SystemdError(error_msg)

    def install_units(
        self, script_path: str, python_executable: Optional[str] = None
    ) -> bool:
        """
        Creates and installs the static systemd user units for fluxfce.
        Enables the login, resume, and main scheduler timer services.
        """
        log.info(f"Installing static systemd user units for {self.app_name}...")
        self.check_user_instance()

        py_exe = python_executable or sys.executable
        script_abs_path = str(pathlib.Path(script_path).resolve())

        if not pathlib.Path(py_exe).is_file():
            raise FileNotFoundError(f"Python executable for systemd units not found: {py_exe}")
        if not pathlib.Path(script_abs_path).is_file():
            raise FileNotFoundError(f"Target script for systemd units not found: {script_abs_path}")

        try:
            SYSTEMD_USER_DIR.mkdir(parents=True, exist_ok=True)
            log.debug(f"Ensured systemd user directory exists: {SYSTEMD_USER_DIR}")
        except OSError as e:
            raise SystemdError(
                f"Failed to create systemd user directory {SYSTEMD_USER_DIR}: {e}"
            ) from e

        for unit_name, unit_file_path in STATIC_UNIT_FILES_MAP.items():
            template_content = _STATIC_UNIT_TEMPLATES.get(unit_name)
            if not template_content:
                log.error(f"Internal error: No template found for static unit {unit_name}, skipping.")
                continue
            
            # The user-level sleep.target template does not need these specific format args
            # but format will ignore extra keys.
            formatted_content = template_content.format(
                app_name=self.app_name,
                python_executable=py_exe,
                script_path=script_abs_path,
                scheduler_service_name=SCHEDULER_SERVICE_NAME,
            )
            try:
                unit_file_path.write_text(formatted_content, encoding="utf-8")
                log.info(f"Written systemd unit file: {unit_file_path}")
            except OSError as e:
                raise SystemdError(
                    f"Failed to write systemd unit file {unit_file_path}: {e}"
                ) from e

        reload_code, _, reload_err = self._run_systemctl(["daemon-reload"], capture_output=True)
        if reload_code != 0:
            raise SystemdError(f"systemctl daemon-reload failed: {reload_err.strip()}")
        log.debug("Systemd daemon-reload successful.")

        # Enable essential static units.
        # api.enable_scheduling() will handle --now for SCHEDULER_TIMER_NAME
        # and the setup of dynamic event timers.
        # The user-level sleep.target does not need to be "enabled" itself.
        services_to_enable_on_install = [
            LOGIN_SERVICE_NAME,
            RESUME_SERVICE_NAME,
            SCHEDULER_TIMER_NAME 
        ]
        for service_name in services_to_enable_on_install:
            enable_code, _, enable_err = self._run_systemctl(["enable", service_name], capture_output=True)
            if enable_code != 0:
                # For resume service and sleep.target, a specific warning about non-existent target
                # is now handled by creating the user-level sleep.target.
                # Other enable errors are still critical.
                error_msg = (
                    f"Failed to enable essential systemd unit '{service_name}' during installation. "
                    f"Stderr: '{enable_err.strip()}'. "
                    f"{self.app_name} may not function correctly."
                )
                log.error(error_msg)
                raise SystemdError(error_msg) 
            else:
                log.info(f"Enabled systemd unit: {service_name}")
        
        log.info(f"Static systemd units for {self.app_name} installed and essential services enabled successfully.")
        return True

    def remove_units(self) -> bool:
        """Stops, disables, and removes all static and dynamic fluxfce systemd user units."""
        log.info(f"Removing all {self.app_name} systemd user units...")
        
        units_to_stop_and_disable = [
            SCHEDULER_TIMER_NAME, SCHEDULER_SERVICE_NAME, # Scheduler components
            LOGIN_SERVICE_NAME, RESUME_SERVICE_NAME,      # Login/Resume hooks
            *DYNAMIC_EVENT_TIMER_NAMES,                   # Dynamic sunrise/sunset timers
            # Potentially running instances of the apply transition service
            f"{_APP_NAME}-apply-transition@day.service",
            f"{_APP_NAME}-apply-transition@night.service",
        ]
        
        # Stop units
        for unit_name in units_to_stop_and_disable:
             self._run_systemctl(["stop", unit_name], check_errors=False, capture_output=True)
        log.debug(f"Attempted to stop all potentially running {self.app_name} units/timers.")

        # Disable units that were explicitly enabled (static ones + scheduler timer)
        # Dynamic timers are not "enabled" in the same persistent way.
        # The user-level sleep.target isn't "enabled" either.
        units_to_disable_persistently = [
            SCHEDULER_TIMER_NAME,
            LOGIN_SERVICE_NAME,
            RESUME_SERVICE_NAME
        ]
        for unit_name in units_to_disable_persistently:
            self._run_systemctl(["disable", unit_name], check_errors=False, capture_output=True)
        log.debug(f"Attempted to disable static units: {', '.join(units_to_disable_persistently)}")

        # Remove all files defined in STATIC_UNIT_FILES_MAP (includes user_sleep_target)
        for unit_file_path in STATIC_UNIT_FILES_MAP.values():
            try:
                unit_file_path.unlink(missing_ok=True)
                log.debug(f"Removed unit file: {unit_file_path} (if it existed)")
            except OSError as e:
                log.warning(f"Error removing unit file {unit_file_path}: {e} (continuing)")

        # Remove dynamic timer files
        for dynamic_timer_name in DYNAMIC_EVENT_TIMER_NAMES:
            dynamic_file_path = SYSTEMD_USER_DIR / dynamic_timer_name
            try:
                dynamic_file_path.unlink(missing_ok=True)
                log.debug(f"Removed dynamic timer file: {dynamic_file_path} (if it existed)")
            except OSError as e:
                log.warning(f"Error removing dynamic timer file {dynamic_file_path}: {e} (continuing)")
        
        reload_code, _, reload_err = self._run_systemctl(["daemon-reload"], capture_output=True)
        if reload_code != 0:
            log.warning(f"systemctl daemon-reload failed during unit removal: {reload_err.strip()}. State might be inconsistent.")
        else:
            log.debug("Systemd daemon-reload successful after unit removal.")

        # Use ALL_POTENTIAL_FLUXFCE_UNIT_NAMES for reset-failed
        reset_code, _, reset_err = self._run_systemctl(["reset-failed", *ALL_POTENTIAL_FLUXFCE_UNIT_NAMES], check_errors=False, capture_output=True)
        if reset_code !=0:
            log.debug(f"reset-failed command for some units may have reported issues: {reset_err.strip()}")
        else:
            log.debug(f"Attempted reset-failed for all {self.app_name} units.")
        
        log.info(f"{self.app_name} systemd units removed.")
        return True

    def write_dynamic_event_timer_unit_file(
        self,
        mode: str, 
        utc_execution_time: datetime,
    ) -> bool:
        """
        Creates or overwrites a dynamic event timer file.
        The timer triggers an instance of APPLY_TRANSITION_SERVICE_TEMPLATE_NAME.
        `utc_execution_time` MUST be timezone-aware and set to UTC.
        """
        if mode not in ["day", "night"]:
            log.error(f"Invalid mode '{mode}' specified for dynamic event timer generation.")
            return False # Or raise error

        if utc_execution_time.tzinfo is None or utc_execution_time.tzinfo.utcoffset(utc_execution_time) is None:
            msg = f"utc_execution_time for dynamic timer ({mode}) must be UTC and timezone-aware."
            log.error(msg)
            raise ValueError(msg)

        timer_name = SUNRISE_EVENT_TIMER_NAME if mode == "day" else SUNSET_EVENT_TIMER_NAME
        timer_file_path = SYSTEMD_USER_DIR / timer_name
        
        service_instance_to_trigger = f"{_APP_NAME}-apply-transition@{mode}.service"
        # Systemd OnCalendar expects UTC if the timezone is specified as 'UTC'
        on_calendar_utc_str = utc_execution_time.strftime('%Y-%m-%d %H:%M:%S UTC')

        timer_content = f"""\
[Unit]
Description={self.app_name}: Event Timer for {mode.capitalize()} Transition (Dynamic)
# This timer requires the corresponding apply-transition@mode.service instance
Requires={service_instance_to_trigger}

[Timer]
Unit={service_instance_to_trigger}
OnCalendar={on_calendar_utc_str}
# Run if the machine was off at the scheduled time
Persistent=true
# Timer accuracy
AccuracySec=1s
# Don't wake a sleeping system just for this timer
WakeSystem=false

[Install]
# Dynamic timers are not typically "WantedBy" other targets directly.
# They are started/stopped by the application logic (e.g., via fluxfce-scheduler.service)
"""
        try:
            SYSTEMD_USER_DIR.mkdir(parents=True, exist_ok=True) # Ensure dir exists
            timer_file_path.write_text(timer_content, encoding="utf-8")
            log.info(f"Written dynamic timer file: {timer_file_path} for event at {on_calendar_utc_str}")
            return True
        except OSError as e:
            log.error(f"Failed to write dynamic timer file {timer_file_path}: {e}")
            raise SystemdError(f"Failed to write dynamic timer file {timer_file_path}: {e}") from e
        except ValueError as e: # Catch other errors like strftime issues if any
            log.error(f"Error preparing dynamic timer content for {mode}: {e}")
            raise

##############
fluxfce_core/xfce.py

# ~/dev/fluxfce-simplified/fluxfce_core/xfce.py
"""
XFCE desktop environment interaction for FluxFCE.

This module provides the `XfceHandler` class, which encapsulates interactions
with XFCE settings for GTK theme and screen temperature/brightness.
Backgrounds are handled by the BackgroundManager.
"""

import logging
import re
from typing import Any, Optional

from . import helpers
from .exceptions import DependencyError, ValidationError, XfceError

log = logging.getLogger(__name__)

# --- XFCE Constants ---
XFCONF_THEME_CHANNEL = "xsettings"
XFCONF_THEME_PROPERTY = "/Net/ThemeName"

class XfceHandler:
    """Handles interactions with XFCE GTK theme and xsct."""

    def __init__(self):
        """Check for essential dependencies."""
        try:
            # Note: xfconf-query is still needed for themes
            helpers.check_dependencies(["xfconf-query", "xsct"])
        except DependencyError as e:
            raise XfceError(f"Cannot initialize XfceHandler: {e}") from e

    def get_gtk_theme(self) -> str:
        log.debug(f"Getting GTK theme from {XFCONF_THEME_CHANNEL} {XFCONF_THEME_PROPERTY}")
        cmd = ["xfconf-query", "-c", XFCONF_THEME_CHANNEL, "-p", XFCONF_THEME_PROPERTY]
        code, stdout, stderr = helpers.run_command(cmd, capture=True)
        if code != 0 or not stdout:
            raise XfceError(f"Failed to query GTK theme: {stderr or 'Empty output'}")
        log.info(f"Current GTK theme: {stdout}")
        return stdout

    def set_gtk_theme(self, theme_name: str) -> bool:
        if not theme_name:
            raise ValidationError("Theme name cannot be empty.")
        log.info(f"Setting GTK theme to: {theme_name}")
        cmd = ["xfconf-query", "-c", XFCONF_THEME_CHANNEL, "-p", XFCONF_THEME_PROPERTY, "-s", theme_name]
        code, _, stderr = helpers.run_command(cmd)
        if code != 0:
            raise XfceError(f"Failed to set GTK theme to '{theme_name}': {stderr}")
        return True

    def get_screen_settings(self) -> dict[str, Any]:
        """Gets screen settings by parsing the output of the `xsct` command."""
        log.debug("Getting screen settings via xsct")
        cmd = ["xsct"]
        code, stdout, stderr = helpers.run_command(cmd, capture=True)
        if code != 0 or not stdout:
            if "unknown" in stderr.lower():
                log.info("xsct appears off or not set. Assuming default screen settings.")
            else:
                log.warning(f"xsct command failed or returned empty. Assuming default settings. Stderr: {stderr}")
            return {"temperature": None, "brightness": None}

        temp: Optional[int] = None
        brightness: Optional[float] = None

        # --- START: CORRECTED PARSING LOGIC ---
        # 1. Try a combined regex first, which matches the common single-line output format.
        #    e.g., "Screen 0: temperature ~ 4500 0.85"
        combined_pattern = re.compile(r"temperature\s*[~:]?\s*(\d+)\s+([\d.]+)", re.IGNORECASE)
        combined_match = combined_pattern.search(stdout)

        if combined_match:
            log.debug("Parsing xsct output with combined regex pattern.")
            try:
                temp = int(combined_match.group(1))
                brightness = float(combined_match.group(2))
                log.info(f"Retrieved screen settings: Temp={temp}, Brightness={brightness:.2f}")
                return {"temperature": temp, "brightness": brightness}
            except (ValueError, IndexError) as e:
                log.warning(f"Could not parse values from combined xsct regex match: {e}. Output: '{stdout}'")

        # 2. If combined pattern fails, fall back to separate patterns for resilience.
        #    This handles older or different xsct versions with multi-line output.
        log.debug("Combined regex failed or was incomplete. Trying separate regex patterns as a fallback.")
        temp_pattern = re.compile(r"temperature\s*[~:]?\s*(\d+)", re.IGNORECASE)
        bright_pattern = re.compile(r"brightness\s*[~:]?\s*([\d.]+)", re.IGNORECASE)
        
        temp_match = temp_pattern.search(stdout)
        bright_match = bright_pattern.search(stdout)

        if temp_match:
            try:
                temp = int(temp_match.group(1))
            except (ValueError, IndexError):
                log.warning(f"Could not parse temperature from separate xsct match: '{stdout}'")
        
        if bright_match:
            try:
                brightness = float(bright_match.group(1))
            except (ValueError, IndexError):
                log.warning(f"Could not parse brightness from separate xsct match: '{stdout}'")

        if temp is None and brightness is None:
            log.warning(f"Could not parse temperature or brightness from xsct output. Output: '{stdout}'")

        # --- END: CORRECTED PARSING LOGIC ---
        
        log.info(f"Retrieved screen settings: Temp={temp}, Brightness={brightness}")
        return {"temperature": temp, "brightness": brightness}

    def set_screen_temp(self, temp: Optional[int], brightness: Optional[float]) -> bool:
        if temp is not None and brightness is not None:
            if not (1000 <= temp <= 10000):
                raise ValidationError(f"Temperature value {temp}K is outside typical range (1000-10000).")
            log.info(f"Setting screen: Temp={temp}, Brightness={brightness:.2f}")
            cmd_args = ["xsct", str(temp), f"{brightness:.2f}"]
        else:
            log.info("Resetting screen temperature/brightness (xsct -x)")
            cmd_args = ["xsct", "-x"]
        
        code, _, stderr = helpers.run_command(cmd_args, capture=True)
        if code != 0:
            raise XfceError(f"Failed to set screen via xsct: {stderr}")
        return True

##############
fluxfce_deps_check.py

#!/usr/bin/env python3

import os
import shutil
import subprocess
import sys
from typing import Optional

MIN_PYTHON_VERSION = (3, 9)

# Updated list of command-line dependencies to check
DEPS_TO_CHECK = {
    # command_name: (package_name_suggestion_for_apt, friendly_name)
    "xfconf-query": ("xfce4-utils", "XFCE Configuration tool ('xfconf-query')"),
    "systemctl": ("systemd", "Systemd control tool ('systemctl')"),
    "timedatectl": ("systemd", "Systemd time/date tool ('timedatectl')"),
    "xfdesktop": ("xfdesktop4", "XFCE Desktop manager ('xfdesktop')"),
    "xsct": ("xsct", "Screen Color Temperature tool ('xsct')"),
}

# Fallback package suggestion if xfce4-utils isn't found directly (e.g., part of a meta-package)
XFCE4_UTILS_FALLBACK = "xfce4-session"


# --- Helper Functions ---

def print_info(message: str):
    print(f"[INFO] {message}")

def print_warning(message: str):
    print(f"[WARN] {message}")

def print_error(message: str):
    print(f"[ERROR] {message}")

def print_success(message: str):
    print(f"[OK]   {message}") # Added more space for alignment

def run_command(
    command: list[str], check_exit_code: bool = True, capture_output: bool = False
) -> tuple[int, Optional[str], Optional[str]]:
    """Runs a system command."""
    try:
        process = subprocess.run(
            command,
            check=check_exit_code and not capture_output, # Let CalledProcessError raise if not capturing
            capture_output=capture_output,
            text=True,
            env=os.environ.copy(),
        )
        stdout = process.stdout.strip() if process.stdout else None
        stderr = process.stderr.strip() if process.stderr else None
        
        if capture_output and check_exit_code and process.returncode != 0:
            # Manually raise for captured output if check_exit_code is True and run failed
            raise subprocess.CalledProcessError(
                process.returncode, command, output=stdout, stderr=stderr
            )
        return process.returncode, stdout, stderr
    except FileNotFoundError:
        # This specific error is often critical for expected commands
        print_error(f"Command not found: {command[0]}. Please ensure it is installed and in your PATH.")
        return -1, None, None # Indicate command not found
    except subprocess.CalledProcessError as e:
        stderr_msg = f": {e.stderr}" if e.stderr and e.stderr.strip() else ""
        print_error(
            f"Command '{' '.join(e.cmd)}' failed with exit code {e.returncode}{stderr_msg}"
        )
        return e.returncode, e.stdout, e.stderr
    except Exception as e:
        print_error(
            f"An unexpected error occurred running command '{' '.join(command)}': {e}"
        )
        return -2, None, None # Indicate other unexpected error

def ask_yes_no(prompt: str, default_yes: bool = False) -> bool:
    """Asks a yes/no question and returns True for yes, False for no."""
    suffix = "[Y/n]" if default_yes else "[y/N]"
    while True:
        try:
            response = input(f"{prompt} {suffix}: ").strip().lower()
            if not response:
                return default_yes
            if response in ["y", "yes"]:
                return True
            if response in ["n", "no"]:
                return False
            print_warning("Invalid input. Please enter 'y' or 'n'.")
        except EOFError:
            print()
            return default_yes
        except KeyboardInterrupt:
            print("\nPrompt interrupted. Assuming 'no'.")
            return False

# --- Check Functions ---

def check_python_version() -> bool:
    """Checks if the current Python version meets the minimum requirement."""
    print_info(f"Checking Python version (minimum {MIN_PYTHON_VERSION[0]}.{MIN_PYTHON_VERSION[1]})...")
    if sys.version_info >= MIN_PYTHON_VERSION:
        print_success(f"Python version {sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro} is sufficient.")
        return True
    else:
        print_error(
            f"Python version is {sys.version_info.major}.{sys.version_info.minor}. "
            f"FluxFCE requires Python {MIN_PYTHON_VERSION[0]}.{MIN_PYTHON_VERSION[1]} or newer."
        )
        return False

def check_command_installed(cmd_name: str, friendly_name: str) -> bool:
    """Checks if a command is installed and executable using shutil.which."""
    print_info(f"Checking for {friendly_name} ('{cmd_name}')...")
    path = shutil.which(cmd_name)
    if path:
        print_success(f"{friendly_name} found at: {path}")
        return True
    else:
        print_warning(f"{friendly_name} ('{cmd_name}') NOT found in PATH.")
        return False

# --- Installation Functions ---

def print_manual_xsct_instructions():
    """Prints manual installation instructions for xsct."""
    print_warning("-" * 60)
    print_warning("Manual Installation for 'xsct' might be required.")
    print_warning("If 'sudo apt install xsct' failed or was skipped, you might need to build it from source:")
    print_info("  1. Install build dependencies (example for Debian/Ubuntu):")
    print_info("     sudo apt update")
    print_info("     sudo apt install build-essential libx11-dev libxrandr-dev git")
    print_info("  2. Clone the xsct repository:")
    print_info("     git clone https://github.com/faf0/xsct.git")
    print_info("  3. Compile and install:")
    print_info("     cd xsct")
    print_info("     sudo make install  # Installs to /usr/local/bin by default")
    print_info("     # OR, for user-local install (ensure ~/.local/bin is in PATH):")
    print_info("     # mkdir -p ~/.local/bin && make PREFIX=~/.local install")
    print_warning("-" * 60)

def install_package(
    pkg_name_suggestion: str, cmd_name_being_checked: str, friendly_name: str
) -> bool:
    """
    Attempts to install a package using apt.
    Handles xsct special case for manual instructions.
    Handles xfce4-utils fallback.
    """
    install_prompt = (
        f"Attempt to install '{friendly_name}' (package suggestion: {pkg_name_suggestion}) "
        f"using 'sudo apt install {pkg_name_suggestion}'?"
    )
    if not ask_yes_no(install_prompt, default_yes=True): # Default to yes for convenience
        print_info(f"Skipping installation of {friendly_name}.")
        if cmd_name_being_checked == "xsct":
            print_manual_xsct_instructions()
        return False

    print_info(f"Attempting to install {pkg_name_suggestion}...")
    
    # Offer to run apt update first
    if ask_yes_no("Run 'sudo apt update' first to refresh package lists?", default_yes=True):
        print_info("Running 'sudo apt update'...")
        ret_update, _, _ = run_command(["sudo", "apt", "update"])
        if ret_update != 0:
            print_warning("Failed to run 'sudo apt update'. Package lists may be outdated. Continuing install attempt...")
    else:
        print_info("Skipping 'apt update'.")

    ret_install, _, _ = run_command(["sudo", "apt", "install", "-y", pkg_name_suggestion])
    
    if ret_install == 0:
        print_success(f"Successfully installed package '{pkg_name_suggestion}' for {friendly_name}.")
        # Verify the command is now available
        if shutil.which(cmd_name_being_checked):
            print_success(f"Command '{cmd_name_being_checked}' is now available.")
            return True
        else:
            print_warning(f"Package '{pkg_name_suggestion}' installed, but command '{cmd_name_being_checked}' still not found. This is unexpected.")
            return False # Command still not found
    else:
        print_error(f"Failed to install package '{pkg_name_suggestion}' for {friendly_name}.")
        if cmd_name_being_checked == "xsct":
            print_info("The package 'xsct' might not be available in your system's default repositories or installation failed.")
            print_manual_xsct_instructions()
        elif cmd_name_being_checked == "xfconf-query" and pkg_name_suggestion == "xfce4-utils":
            print_info(f"Trying fallback package '{XFCE4_UTILS_FALLBACK}' for XFCE utilities.")
            # Recursive call for the fallback package.
            return install_package(XFCE4_UTILS_FALLBACK, cmd_name_being_checked, friendly_name)
        return False

# --- Main Logic ---
def main():
    print_info("FluxFCE Dependency Checker for Debian/Ubuntu-based systems")
    print_info("(Focuses on command-line tools needed by FluxFCE core)")
    print_info("=" * 60)

    if not shutil.which("apt"):
        print_warning("This script's package installation suggestions use 'apt'.")
        print_warning("If you are on a non-APT system, you'll need to install dependencies manually.")
        # Continue with checks, but installation attempts might not be relevant.

    if os.geteuid() == 0:
        print_warning(
            "This script is not designed to be run as root, though it will invoke 'sudo' "
            "for package installations if you permit."
        )
        if not ask_yes_no("Continue anyway?", default_yes=False):
            sys.exit(1)

    all_deps_ok_initially = True
    missing_commands_to_resolve: dict[str, tuple[str, str]] = {} # cmd_name: (pkg_suggestion, friendly_name)

    # 1. Check Python Version
    if not check_python_version():
        all_deps_ok_initially = False
        # This is a critical failure for FluxFCE itself.
        print_error("Please upgrade Python before proceeding with FluxFCE installation.")
        # Exiting early if Python version is insufficient, as fluxfce_cli.py won't run.
        # sys.exit(1) # Or choose to report all other missing deps first. Let's report all.

    # 2. Check Commands
    print_info("\n--- Checking for required command-line tools ---")
    for cmd, (pkg_suggestion, friendly) in DEPS_TO_CHECK.items():
        if not check_command_installed(cmd, friendly):
            all_deps_ok_initially = False
            if cmd not in missing_commands_to_resolve: # Avoid duplicates if somehow listed twice
                missing_commands_to_resolve[cmd] = (pkg_suggestion, friendly)
    
    print_info("-" * 60)
    if all_deps_ok_initially:
        print_success("All checked dependencies appear to be OK!")
        print_info("Note: Core system utilities (like 'python3', 'mkdir', 'ln') are assumed to be present.")
        sys.exit(0)
    else:
        print_warning("Some dependencies require attention.")

    # 3. Attempt to Install Missing Items
    if missing_commands_to_resolve:
        print_info("\n--- Attempting to resolve missing dependencies ---")
        # Prioritize xsct for special handling/messaging if apt install fails
        if "xsct" in missing_commands_to_resolve:
            pkg_sugg, friendly_name = missing_commands_to_resolve.pop("xsct")
            install_package(pkg_sugg, "xsct", friendly_name)
            # Re-check xsct specifically, as its installation can be manual
            if check_command_installed("xsct", DEPS_TO_CHECK["xsct"][1]):
                 print_success("'xsct' is now available.")
            else:
                 print_warning("'xsct' still appears to be unavailable after installation attempt.")
                 # Manual instructions were already printed by install_package on failure.

        # Attempt to install other missing packages
        for cmd_name, (pkg_sugg, friendly_name) in missing_commands_to_resolve.items():
            # Check again in case a previous install provided this command (e.g., meta-package)
            if not shutil.which(cmd_name):
                install_package(pkg_sugg, cmd_name, friendly_name)
    else:
        print_info("No missing command-line tools to attempt to install (or user skipped previous prompts).")

    print_info("-" * 60)
    # Final verification
    print_info("Re-verifying all dependencies after installation attempts...")
    final_all_ok = True
    if not check_python_version(): # Re-check Python version
        final_all_ok = False

    for cmd, (_, friendly) in DEPS_TO_CHECK.items():
        if not check_command_installed(cmd, friendly):
            final_all_ok = False
            if cmd == "xsct":
                print_warning(f"'{cmd}' ({friendly}) is still missing. Manual installation might be required (see instructions above if printed).")
            else:
                print_warning(f"'{cmd}' ({friendly}) is still missing. Please install it manually.")


    print_info("-" * 60)
    if final_all_ok:
        print_success("All critical dependencies appear to be satisfied now!")
        sys.exit(0)
    else:
        print_error("One or more critical dependencies are still missing after installation attempts.")
        print_error("Please review the output above and install them manually.")
        sys.exit(1)

if __name__ == "__main__":
    main()

##############
fluxfce_gui.py



##############
pyproject.toml

[tool.ruff]
line-length = 88
indent-width = 4
target-version = "py39"

[tool.ruff.lint]
select = [
    "E", "F", "W", "I", "UP", "B", "C90", "SIM", "TID", "RUF",
]
ignore = ["B008", "E501"]
fixable = ["ALL"]
unfixable = []
dummy-variable-rgx = "^(_+|(_+[a-zA-Z0-9_]*[a-zA-Z0-9]+?))$"

[tool.ruff.lint.isort]
known-first-party = ["fluxfce_core", "fluxfce_dependency_setup"]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
skip-magic-trailing-comma = false
line-ending = "auto"
docstring-code-format = true
docstring-code-line-length = "dynamic"


##############
readme.md

# fluxfce - stable - june9


**Fluxfce** automates switching XFCE desktop appearance (GTK Theme, Background Color/Gradient, Screen Temperature/Brightness) between user-defined Day and Night modes at sunrise and sunset times. It uses an adapted NOAA algorithm to calculate transition times. **Systemd user timers** are used for precise, low-resource scheduling.

This is a refactored and simplified version focusing on core functionality, reliability, and maintainability.

<p align="center">
  <img src="logo.png" alt="fluxfce Logo Placeholder" width="150">
</p>

---

## Features

- **Automatic Switching:** Automatically transitions between Day and Night modes at local sunrise and sunset.
- **Easy Default Setting:** Save your current desktop look as the new default for Day or Night mode (`fluxfce set-default --mode day`).
- **Component Control:** Adjusts:
  - GTK Theme (`Net/ThemeName`)
  - Desktop Background (Solid color or vertical/horizontal gradient via `xfce4-desktop` properties)
  - Screen Temperature & Brightness (via `xsct`)
- **Location Aware:** Calculates sunrise/sunset times based on user-configured latitude, longitude, and IANA timezone.
- **Timezone Detection:** Attempts to automatically detect system timezone during initial install.
- **Low Resource Usage:** Uses systemd user timers, avoiding a persistent custom background daemon.
- **Systemd Integration:** Installs systemd user units (`.timer`, `.service`) for:
    - Daily rescheduling of sunrise/sunset event timers.
    - Triggering theme transitions at precise sunrise/sunset times.
    - Applying the correct theme on login and resume from suspend.
- **Manual Overrides:** Easily force Day or Night mode (`force-day`, `force-night`). Manual overrides disable automatic scheduling.
- **Simple Configuration:** Uses a clear INI file (`~/.config/fluxfce/config.ini`).
- **Status Reporting:** Check current configuration, calculated times, and systemd timer status (`status`).

## Requirements

- **Linux Distribution:** Designed for XFCE distributions with systemd.
  - **Primary Targets:** Ubuntu 22.04+ (Xubuntu), Linux Mint 21.x+ (XFCE), Debian 11+ (XFCE).
  - *May work on other systemd-based XFCE distributions (e.g., Fedora XFCE, Arch XFCE) with adjustments to package names for dependencies.*
- **Desktop Environment:** XFCE 4.x
- **Python:** Python 3.9+ (due to `zoneinfo` usage).
- **System Tools & Services (Dependencies):**
  - **`systemd`:** User instance must be operational.
  - **`xsct`:** For screen temperature and brightness control.
    - Installation on **Ubuntu 24.04 (Noble Numbat) and newer (or equivalent Linux Mint/Debian versions)**:
      ```bash
      sudo apt update
      sudo apt install xsct
      ```
  - **Core XFCE/System Tools** (Usually pre-installed on XFCE systems):
    - `xfconf-query` (from `xfce4-utils` or similar)
    - `xfdesktop` (from `xfdesktop4` or similar, for background reloads)
    - `timedatectl` (part of systemd)

## Installation

1.  **Clone the repository (or download the source code):**

    ```bash
    git clone https://github.com/camdoherty/fluxfce-simplified.git
    cd fluxfce
    ```

2.  **Run the install command:**

    ```bash
    python3 fluxfce_cli.py install
    ```
    The script will:
    - Check for Python version.
    - Check for required system dependencies using `fluxfce_deps_check.py` and guide you through installing missing ones (like `xsct` via `apt`).
    - Prompt you for location (latitude/longitude) and attempt to detect your timezone for accurate sun time calculations if a configuration file doesn't exist.
    - Install systemd user units for automatic operation.
    - Enable scheduling, which sets up timers for the next sunrise/sunset and ensures the current desktop appearance matches the current solar period.

3.  **Make the `fluxfce` command easily accessible (if not using `pip install .` in the future):**

    The `install` script will provide instructions. A common method is:
    - Ensure `~/.local/bin` is in your `PATH`. Add if necessary:
      ```bash
      # Add to your ~/.bashrc or ~/.zshrc, then source it or restart terminal
      export PATH="$HOME/.local/bin:$PATH"
      ```
    - Make the main script executable:
      ```bash
      chmod +x ./fluxfce_cli.py
      ```
    - Create a symbolic link:
      ```bash
      SCRIPT_ABS_PATH=$(readlink -f ./fluxfce_cli.py) # Or use: SCRIPT_ABS_PATH=$(pwd)/fluxfce_cli.py
      mkdir -p ~/.local/bin
      ln -s -f "$SCRIPT_ABS_PATH" ~/.local/bin/fluxfce # -f forces overwrite if symlink exists
      ```

4.  **(Recommended) Configure Day/Night Appearance:**

    Set your desired XFCE theme, background color/gradient, and screen temperature/brightness for **Daytime**, then run:
    ```bash
    fluxfce set-default --mode day
    ```
    Then, set your desired look for **Nighttime**, and run:
    ```bash
    fluxfce set-default --mode night
    ```
    `fluxfce` will save these settings to its configuration file. When `fluxfce enable` is run, or when the scheduled transitions occur, these configured settings will be applied.

## Usage

```bash
fluxfce <command> [options]
```

**Commands:**

- `install` — Performs dependency checks, interactive setup (if needed), installs systemd units, and enables automatic scheduling.
- `uninstall` — Removes systemd units and clears schedule (prompts to remove config).
- `day` — Apply Day Mode settings now without disabling automatic scheduling.
- `night` — Apply Night Mode settings now without disabling automatic scheduling.
- `enable` — Enables automatic scheduling (sets up systemd timers for sunrise/sunset and ensures current appearance matches the solar period).
- `disable` — Disable automatic scheduling (stops and disables relevant systemd timers).
- `status` — Show config, calculated times, and systemd timer/service status.
- `force-day` — Apply Day Mode settings now **and disable** automatic scheduling.
- `force-night` — Apply Night Mode settings now **and disable** automatic scheduling.
- `set-default --mode {day,night}` — Save current desktop look as the new default for Day or Night mode.

**Options:**

- `-h`, `--help` — Show this help message and exit.
- `-v`, `--verbose` — Enable detailed logging output for `fluxfce` operations.

## Configuration

Fluxfce uses an INI file located at `~/.config/fluxfce/config.ini`.
The `fluxfce install` command will help you create this initially. You can edit it manually later.

**Example `config.ini`:**
```ini
[Location]
latitude = 43.65N
longitude = 79.38W
timezone = America/Toronto

[Themes]
light_theme = Adwaita
dark_theme = Adwaita-dark

[BackgroundDay]
bg_dir = v
bg_hex1 = ADD8E6
bg_hex2 = 87CEEB

[ScreenDay]
xsct_temp = 6500
xsct_bright = 1.0

[BackgroundNight]
bg_dir = v
bg_hex1 = 1E1E2E
bg_hex2 = 000000

[ScreenNight]
xsct_temp = 4500
xsct_bright = 0.85
```

- **`bg_dir` (Background Direction):**
  - `s` = Solid color (uses `bg_hex1` only)
  - `h` = Horizontal gradient (uses `bg_hex1` and `bg_hex2`)
  - `v` = Vertical gradient (uses `bg_hex1` and `bg_hex2`)
- **`xsct_temp` (Screen Temperature):** In Kelvin (e.g., 3700, 6500). If empty for Day mode, `xsct` typically resets to its default (temperature and brightness are usually reset together for day mode if either is empty).
- **`xsct_bright` (Screen Brightness):** Factor (e.g., 0.8, 1.0). If empty for Day mode, `xsct` typically resets to its default.

## Troubleshooting

- **Verbose Output:** Always try running `fluxfce` with the `-v` flag first to get more detailed logs:
  ```bash
  fluxfce -v status
  fluxfce -v enable
  # etc.
  ```
- **Dependency Check Script:**
  The `fluxfce install` command runs `fluxfce_deps_check.py` automatically. If you need to re-run it manually (e.g., after system changes):
  ```bash
  python3 ./fluxfce_deps_check.py 
  ```
  (Assuming `fluxfce_deps_check.py` is in the same directory as `fluxfce_cli.py`).

- **Systemd User Units & Timers:**
  - **List FluxFCE Timers:** See if `fluxfce` timers are scheduled and their next run times:
    ```bash
    systemctl --user list-timers --all | grep fluxfce
    ```
  - **Check Status of Specific FluxFCE Units:** (Replace `fluxfce-unit-name` with the actual unit, e.g., `fluxfce-scheduler.timer` or `fluxfce-apply-transition@day.service`)
    ```bash
    systemctl --user status fluxfce-unit-name
    ```
    Common units to check: `fluxfce-scheduler.timer`, `fluxfce-scheduler.service`, `fluxfce-sunrise-event.timer`, `fluxfce-sunset-event.timer`, `fluxfce-apply-transition@day.service`, `fluxfce-apply-transition@night.service`, `fluxfce-login.service`, `fluxfce-resume.service`.
  - **View Journal Logs for Specific Units:** For detailed error messages:
    ```bash
    journalctl --user -u fluxfce-scheduler.service -e --no-pager
    journalctl --user -u fluxfce-apply-transition@day.service -e --no-pager 
    # etc. for other fluxfce units. '-e' jumps to end, '--no-pager' prints to console.
    ```

- **Configuration File Path:** Ensure your config is at `~/.config/fluxfce/config.ini`.

- **Manual Theme Application Test (via Systemd Service):** To test if a specific mode application service is working correctly:
  ```bash
  # Ensure you are in the opposite mode first (e.g., run 'fluxfce force-day')
  # Then to test night mode application:
  systemctl --user start fluxfce-apply-transition@night.service
  # Check your desktop. Then check the journal for this unit if issues occurred:
  # journalctl --user -u fluxfce-apply-transition@night.service -e --no-pager
  ```

## License

MIT
