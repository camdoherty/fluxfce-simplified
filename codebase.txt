##############
./fluxfce_cli.py

#!/usr/bin/env python3

"""
fluxfce (CLI) - Simplified XFCE Theming Tool (Systemd Timer Version)

Command-line interface for managing automatic XFCE theme/background/screen
switching based on sunrise/sunset times using the fluxfce_core library.
This version uses systemd timers for scheduling, replacing atd.
"""

import argparse
import logging
import pathlib
import shutil
import subprocess
import sys

# Import the refactored core library API and exceptions
try:
    import fluxfce_core
    from fluxfce_core import exceptions as core_exc
    # For accessing constants like SCHEDULER_TIMER_NAME etc. directly if needed for output
    from fluxfce_core import (
        SCHEDULER_TIMER_NAME, SCHEDULER_SERVICE_NAME,
        LOGIN_SERVICE_NAME, RESUME_SERVICE_NAME,
        # SUNRISE_EVENT_TIMER_NAME, SUNSET_EVENT_TIMER_NAME # Not directly used in CLI output string formatting yet
    )
    from fluxfce_core import config as core_config # For CONFIG_FILE in enable command
except ImportError as e:
    print(f"Error: Failed to import the fluxfce_core library: {e}", file=sys.stderr)
    print(
        "Ensure fluxfce_core is installed or available in your Python path.",
        file=sys.stderr,
    )
    sys.exit(1)

# --- Global Variables ---
SCRIPT_DIR = pathlib.Path(__file__).resolve().parent
SCRIPT_PATH = str(pathlib.Path(__file__).resolve())
PYTHON_EXECUTABLE = sys.executable
DEPENDENCY_CHECKER_SCRIPT_NAME = "fluxfce_deps_check.py" # Assumed to be updated

log = logging.getLogger("fluxfce_cli")


# --- CLI Logging Setup ---
def setup_cli_logging(verbose: bool):
    """Configures logging for the CLI based on verbosity."""
    cli_log_level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(
        level=logging.WARNING, format="%(levelname)s: %(name)s: %(message)s"
    )

    log.setLevel(cli_log_level)
    if log.hasHandlers():
        log.handlers.clear()

    core_log_level = logging.DEBUG if verbose else logging.WARNING
    core_logger = logging.getLogger("fluxfce_core")
    core_logger.setLevel(core_log_level)
    if not core_logger.hasHandlers(): # Ensure core logger gets a handler if basicConfig didn't cover it
        core_handler = logging.StreamHandler(sys.stderr) # Core logs to stderr by default
        core_formatter = logging.Formatter("%(levelname)s: fluxfce_core: %(message)s")
        core_handler.setFormatter(core_formatter)
        core_logger.addHandler(core_handler)
        core_logger.propagate = False

    if cli_log_level <= logging.INFO:
        info_handler = logging.StreamHandler(sys.stdout)
        info_formatter = logging.Formatter("%(message)s") # CLI info messages are direct
        info_handler.setFormatter(info_formatter)
        info_handler.setLevel(logging.INFO)
        info_handler.addFilter(lambda record: record.levelno == logging.INFO)
        log.addHandler(info_handler)

    # General CLI errors/warnings/debug to stderr
    error_handler = logging.StreamHandler(sys.stderr)
    error_formatter = logging.Formatter("%(levelname)s: %(name)s: %(message)s") # Show CLI name
    error_handler.setFormatter(error_formatter)
    error_handler.setLevel(logging.DEBUG if verbose else logging.WARNING) # Capture debug for verbose
    log.addHandler(error_handler)

    log.propagate = False
    if verbose:
        log.debug("Verbose logging enabled for fluxfce_cli.")
        core_logger.debug("Verbose logging enabled for fluxfce_core (via CLI).")


# --- Output Formatting ---
def print_status(status_data: dict):
    """Formats and prints the status dictionary."""
    log.info("--- fluxfce Status ---")

    log.info("\n[Configuration]")
    if status_data["config"].get("error"):
        log.info(f"  Error loading config: {status_data['config']['error']}")
    else:
        log.info(f"  Location:      {status_data['config'].get('latitude', 'N/A')}, {status_data['config'].get('longitude', 'N/A')}")
        log.info(f"  Timezone:      {status_data['config'].get('timezone', 'N/A')}")
        log.info(f"  Light Theme:   {status_data['config'].get('light_theme', 'N/A')}")
        log.info(f"  Dark Theme:    {status_data['config'].get('dark_theme', 'N/A')}")

    log.info("\n[Calculated Sun Times (Today)]")
    if status_data["sun_times"].get("error"):
        log.info(f"  Error: {status_data['sun_times']['error']}")
    elif status_data["sun_times"].get("sunrise") and status_data["sun_times"].get("sunset"):
        sunrise_dt = status_data["sun_times"]["sunrise"]
        sunset_dt = status_data["sun_times"]["sunset"]
        try:
            log.info(f"  Sunrise:       {sunrise_dt.isoformat(sep=' ', timespec='seconds')}")
            log.info(f"  Sunset:        {sunset_dt.isoformat(sep=' ', timespec='seconds')}")
        except Exception:
            log.info(f"  Sunrise:       {sunrise_dt}")
            log.info(f"  Sunset:        {sunset_dt}")
    else:
        log.info("  Could not be calculated (check config/location).")
    log.info(f"  Current Period:  {status_data.get('current_period', 'unknown').capitalize()}")

    log.info("\n[Systemd Scheduling Timers]")
    schedule_info = status_data.get("schedule", {})
    if schedule_info.get("error"):
        log.info(f"  Error checking systemd timers: {schedule_info['error']}")
    else:
        timers = schedule_info.get("timers", {})
        if not timers and not schedule_info.get("info"): # No timers and no specific info message
             log.info("  Scheduler status unknown or no fluxfce timers found.")
        elif schedule_info.get("info"): # E.g. "No fluxfce timers found or listed."
             log.info(f"  Status: {schedule_info.get('info')}")

        for timer_name, details in timers.items():
            log.info(f"  Timer: {timer_name}")
            log.info(f"    Status:    {details.get('enabled', 'N/A')}, {details.get('active', 'N/A')}")
            log.info(f"    Next Run:  {details.get('next_run', 'N/A')}")
            log.info(f"    Time Left: {details.get('time_left', 'N/A')}")
            log.info(f"    Last Run:  {details.get('last_run', 'N/A')}")
            log.info(f"    Activates: {details.get('activates', 'N/A')}")
        
        is_enabled = any(
            SCHEDULER_TIMER_NAME in name and ("Enabled" in details.get("enabled","") and "Active" in details.get("active",""))
            for name, details in timers.items()
        )
        if not timers and not schedule_info.get("error") and not schedule_info.get("info"):
             log.info("  Status: Disabled (No fluxfce timers configured or found)")
        elif not is_enabled and not schedule_info.get("error"):
            log.info("  Overall Status: Scheduling may be disabled or timers not active.")
            log.info("  (Run 'fluxfce enable' to enable automatic scheduling)")


    log.info("\n[Systemd Services (Login/Resume/Scheduler)]")
    systemd_services = status_data.get("systemd_services", {})
    if systemd_services.get("error"):
        log.info(f"  Error checking systemd services: {systemd_services['error']}")
    else:
        log.info(f"  Scheduler Timer State Checker ({SCHEDULER_SERVICE_NAME}): {systemd_services.get('scheduler_service', 'Unknown')}")
        log.info(f"  Login Service ({LOGIN_SERVICE_NAME}): {systemd_services.get('login_service', 'Unknown')}")
        log.info(f"  Resume Service ({RESUME_SERVICE_NAME}): {systemd_services.get('resume_service', 'Unknown')}")
        log.info("  (For detailed logs/status, use 'systemctl --user status ...' or 'journalctl --user -u ...')")

    log.info("-" * 25)


# --- User Interaction Helper ---
def ask_yes_no_cli(prompt: str, default_yes: bool = False) -> bool:
    """Asks a yes/no question and returns True for yes, False for no."""
    suffix = "[Y/n]" if default_yes else "[y/N]"
    while True:
        try:
            print(f"{prompt} {suffix}: ", end="", flush=True) # Direct print for prompt
            response = input().strip().lower()
            if not response:
                return default_yes
            if response in ["y", "yes"]:
                return True
            if response in ["n", "no"]:
                return False
            print("[WARN] Invalid input. Please enter 'y' or 'n'.") # Direct print for feedback
        except EOFError:
            print()
            return default_yes
        except KeyboardInterrupt:
            print("\nPrompt interrupted. Assuming 'no'.")
            return False


# --- Main Execution Logic ---
def main():
    parser = argparse.ArgumentParser(
        description="fluxfce (CLI): Manage XFCE appearance via sunrise/sunset timing (Systemd Timer Version).",
        formatter_class=argparse.RawTextHelpFormatter,
        epilog="""
Examples:
  fluxfce install          # Interactive setup, install units, and enable scheduling
  fluxfce status           # Show current status and configuration
  fluxfce enable           # Enable automatic scheduling (sets up systemd timers)
  fluxfce disable          # Disable automatic scheduling (clears systemd timers)
  fluxfce force-day        # Apply Day mode now and disable auto switching
  fluxfce force-night      # Apply Night mode now and disable auto switching
  fluxfce set-default --mode day # Save current desktop look as the new Day default
  fluxfce uninstall        # Remove systemd units and clear schedule (prompts for config removal)
""",
    )
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Enable detailed logging output."
    )
    subparsers = parser.add_subparsers(dest="command", title="Commands", required=True)

    subparsers.add_parser("install", help="Install systemd units and enable automatic scheduling.")
    subparsers.add_parser("uninstall", help="Remove systemd units & clear schedule (prompts to remove config).")
    subparsers.add_parser("enable", help="Enable automatic scheduling (configures systemd timers).")
    subparsers.add_parser("disable", help="Disable automatic scheduling (clears relevant systemd timers).")
    subparsers.add_parser("status", help="Show config, calculated times, and schedule status.")
    subparsers.add_parser("force-day", help="Apply Day Mode settings now (disables automatic scheduling).")
    subparsers.add_parser("force-night", help="Apply Night Mode settings now (disables automatic scheduling).")
    
    parser_set_default = subparsers.add_parser(
        "set-default", help="Save current desktop look as the new default for Day or Night mode."
    )
    parser_set_default.add_argument(
        "--mode", choices=["day", "night"], required=True, dest="default_mode",
        help="Specify whether to save as the Day or Night default."
    )

    # Internal commands, hidden from public help
    parser_internal_apply = subparsers.add_parser("internal-apply", help=argparse.SUPPRESS)
    parser_internal_apply.add_argument(
        "--mode", choices=["day", "night"], required=True, dest="internal_mode"
    )
    subparsers.add_parser("schedule-dynamic-transitions", help=argparse.SUPPRESS) # New internal command
    subparsers.add_parser("run-login-check", help=argparse.SUPPRESS)


    args = parser.parse_args()
    setup_cli_logging(args.verbose)
    exit_code = 0

    try:
        log.debug(f"Running command: {args.command}")
        log.debug(f"Script path: {SCRIPT_PATH}")
        log.debug(f"Python executable: {PYTHON_EXECUTABLE}")

        if args.command == "install":
            log.info("--- Step 1: Checking system dependencies ---")
            dependency_checker_script = SCRIPT_DIR / DEPENDENCY_CHECKER_SCRIPT_NAME
            if not dependency_checker_script.exists():
                log.error(f"Dependency checker script '{DEPENDENCY_CHECKER_SCRIPT_NAME}' not found in {SCRIPT_DIR}")
                sys.exit(1)
            
            log.info(f"Executing dependency checker: {dependency_checker_script}...")
            process = subprocess.run([PYTHON_EXECUTABLE, str(dependency_checker_script)], check=False, capture_output=False)
            if process.returncode != 0:
                log.error(f"Dependency check/setup failed (exit code: {process.returncode}). Aborting installation.")
                sys.exit(1)
            log.info("System dependency check passed or issues addressed.")
            log.info("--- Dependency check complete ---")

            log.info("\n--- Step 2: Configuring FluxFCE application settings ---")
            config_existed = fluxfce_core.CONFIG_FILE.exists()
            config_obj = fluxfce_core.get_current_config() # Loads or creates with defaults
            needs_saving = False

            run_interactive_setup = False
            if not config_existed:
                run_interactive_setup = True
                log.info("Configuration file not found. Starting interactive setup.")
            else:
                loc_section = "Location"
                current_lat = config_obj.get(loc_section, "LATITUDE", fallback=None)
                current_lon = config_obj.get(loc_section, "LONGITUDE", fallback=None)
                if (current_lat == core_config.DEFAULT_CONFIG[loc_section]["LATITUDE"] and \
                    current_lon == core_config.DEFAULT_CONFIG[loc_section]["LONGITUDE"]) or \
                   not current_lat or not current_lon:
                    log.info("Existing config found, but location seems default/missing.")
                    if ask_yes_no_cli("Run interactive setup for location/timezone?", default_yes=True):
                        run_interactive_setup = True
                    else:
                        log.info("Skipping interactive setup. Using current/default config values.")
                else:
                    log.info(f"Existing configuration found at {fluxfce_core.CONFIG_FILE}. Using it.")
            
            if run_interactive_setup:
                detected_tz = fluxfce_core.detect_system_timezone()
                current_tz_in_config = config_obj.get("Location", "TIMEZONE", fallback=core_config.DEFAULT_CONFIG["Location"]["TIMEZONE"])
                final_tz = current_tz_in_config

                if detected_tz:
                    print(f"\nDetected system timezone: '{detected_tz}'") # Direct print for interaction
                    if detected_tz != final_tz:
                        if ask_yes_no_cli(f"Use detected timezone '{detected_tz}' (current is '{final_tz}')?", default_yes=True):
                            final_tz = detected_tz
                    else:
                        print(f"Detected timezone matches current/default ('{final_tz}').")
                else:
                    print(f"\nCould not detect system timezone. Current is '{final_tz}'.")
                
                if config_obj.get("Location", "TIMEZONE") != final_tz:
                    config_obj.set("Location", "TIMEZONE", final_tz)
                    needs_saving = True
                print(f"Using timezone: {final_tz}")

                print("\nPlease provide location coordinates (e.g., 43.65N, 79.38W). Press Enter for defaults.")
                prompt_default_lat = config_obj.get("Location", "LATITUDE", fallback=core_config.DEFAULT_CONFIG["Location"]["LATITUDE"])
                prompt_default_lon = config_obj.get("Location", "LONGITUDE", fallback=core_config.DEFAULT_CONFIG["Location"]["LONGITUDE"])
                
                try:
                    lat_input = input(f"Enter Latitude [{prompt_default_lat}]: ").strip()
                    lon_input = input(f"Enter Longitude [{prompt_default_lon}]: ").strip()
                    
                    chosen_lat = lat_input if lat_input else prompt_default_lat
                    chosen_lon = lon_input if lon_input else prompt_default_lon

                    fluxfce_core.helpers.latlon_str_to_float(chosen_lat) # Validate
                    fluxfce_core.helpers.latlon_str_to_float(chosen_lon) # Validate

                    if config_obj.get("Location", "LATITUDE") != chosen_lat or \
                       config_obj.get("Location", "LONGITUDE") != chosen_lon:
                        config_obj.set("Location", "LATITUDE", chosen_lat)
                        config_obj.set("Location", "LONGITUDE", chosen_lon)
                        needs_saving = True
                    print(f"Using coordinates: Latitude={chosen_lat}, Longitude={chosen_lon}")
                except (EOFError, KeyboardInterrupt): print("\nInput skipped. Using previous/default coordinates.")
                except core_exc.ValidationError as e: print(f"\nWarning: Invalid coordinate input ({e}). Using previous/default.")
                except Exception as e_coord: print(f"\nWarning: Unexpected error ({e_coord}). Using previous/default.")
            
            if needs_saving or not config_existed:
                log.info("Saving initial/updated FluxFCE configuration...")
                fluxfce_core.save_configuration(config_obj)
            log.info("--- FluxFCE application configuration complete ---")

            log.info("\n--- Step 3: Installing systemd units ---")
            fluxfce_core.install_fluxfce(script_path=SCRIPT_PATH, python_executable=PYTHON_EXECUTABLE)
            log.info("Static systemd units installed.")

            log.info("\n--- Step 4: Enabling automatic scheduling ---")
            # This will set up initial dynamic timers and enable the main scheduler.timer
            fluxfce_core.enable_scheduling(python_exe_path=PYTHON_EXECUTABLE, script_exe_path=SCRIPT_PATH)
            log.info("Automatic theme scheduling enabled via systemd timers.")

            log.info("\n" + "-" * 45 + "\n fluxfce installed and enabled successfully. \n" + "-" * 45 + "\n")
            # ... (Instructions for PATH setup remain similar) ...
            user_bin_dir = pathlib.Path.home() / ".local" / "bin"
            log.info("IMPORTANT: To run 'fluxfce' easily from your terminal, ensure")
            log.info(f"the script ({pathlib.Path(SCRIPT_PATH).name}) or a symlink to it is in your PATH.")
            log.info(f"Recommended: ln -s -f \"{SCRIPT_PATH}\" \"{user_bin_dir / 'fluxfce'}\" (after ensuring {user_bin_dir} is in PATH)")
            log.info("\nTip: Configure Day/Night appearance using 'fluxfce set-default --mode day|night'.")
            log.info("Check 'fluxfce status' to see the current setup.")

        elif args.command == "uninstall":
            log.info("Starting uninstallation (system components)...")
            # disable_scheduling is now called within uninstall_fluxfce in the API
            fluxfce_core.uninstall_fluxfce()
            log.info("FluxFCE systemd units removed and schedule cleared/dynamic timers removed.")

            config_dir_path = fluxfce_core.CONFIG_DIR
            if config_dir_path.exists():
                log.warning(f"\nConfiguration directory found at: {config_dir_path}")
                if ask_yes_no_cli("Do you want to REMOVE this configuration directory?", default_yes=False):
                    try:
                        shutil.rmtree(config_dir_path)
                        log.info(f"Removed configuration directory: {config_dir_path}")
                    except OSError as e:
                        log.error(f"Error removing config directory {config_dir_path}: {e}")
                else:
                    log.info("Configuration directory kept.")
            log.info("\n--- Uninstallation Complete ---")

        elif args.command == "enable":
            log.info("Enabling scheduling via systemd timers...")
            if not core_config.CONFIG_FILE.exists(): # Use imported core_config
                log.error(f"Configuration file {core_config.CONFIG_FILE} not found.")
                log.error("Please run 'fluxfce install' first or ensure config is in place.")
                exit_code = 1
            else:
                fluxfce_core.enable_scheduling(
                    python_exe_path=PYTHON_EXECUTABLE, script_exe_path=SCRIPT_PATH
                )
                log.info("Automatic theme scheduling enabled using systemd timers.")
                log.info("Run 'fluxfce status' to see scheduled timers.")

        elif args.command == "disable":
            log.info("Disabling scheduling (systemd timers)...")
            fluxfce_core.disable_scheduling()
            log.info("Automatic theme scheduling disabled (main scheduler & dynamic event timers stopped/removed).")

        elif args.command == "status":
            status = fluxfce_core.get_status()
            print_status(status)

        elif args.command == "force-day":
            log.info("Forcing Day mode...")
            fluxfce_core.apply_manual_mode("day") # This also disables scheduling
            log.info("Day mode applied. Automatic scheduling (systemd timers) disabled.")

        elif args.command == "force-night":
            log.info("Forcing Night mode...")
            fluxfce_core.apply_manual_mode("night") # This also disables scheduling
            log.info("Night mode applied. Automatic scheduling (systemd timers) disabled.")

        elif args.command == "set-default":
            mode = args.default_mode
            log.info(f"Setting current look as default for {mode} mode...")
            fluxfce_core.set_default_from_current(mode)
            log.info(f"Current desktop settings saved as default for {mode.capitalize()} mode.")
            log.info("(Run 'fluxfce enable' to (re)activate scheduling with new defaults).")

        elif args.command == "internal-apply":
            mode = args.internal_mode
            log.debug(f"CLI: Executing internal-apply for mode '{mode}' (called by systemd service)")
            success = fluxfce_core.handle_internal_apply(mode)
            exit_code = 0 if success else 1
        
        elif args.command == "schedule-dynamic-transitions": # New internal command
            log.debug("CLI: Executing schedule-dynamic-transitions (called by systemd scheduler service)")
            success = fluxfce_core.handle_schedule_dynamic_transitions_command(
                python_exe_path=PYTHON_EXECUTABLE, script_exe_path=SCRIPT_PATH
            )
            exit_code = 0 if success else 1

        elif args.command == "run-login-check":
            log.debug("CLI: Executing run-login-check (called by systemd login/resume service)")
            success = fluxfce_core.handle_run_login_check()
            exit_code = 0 if success else 1
        else:
            log.error(f"Unknown command: {args.command}")
            parser.print_help(sys.stderr)
            exit_code = 1

    except core_exc.FluxFceError as e:
        log.error(f"FluxFCE Error: {e}", exc_info=args.verbose)
        exit_code = 1
    except Exception as e_main: # Catchall for unexpected errors
        log.error(f"An unexpected error occurred in CLI: {e_main}", exc_info=True)
        exit_code = 1

    sys.exit(exit_code)


if __name__ == "__main__":
    main()
##############
./fluxfce_core/api.py

# ~/dev/fluxfce-simplified/fluxfce_core/api.py

import configparser
import logging
import re # For get_status timer parsing
from datetime import datetime, timedelta
from typing import Any, Optional

# Import core components and exceptions
from . import config as cfg
from . import exceptions as exc
from . import helpers, sun, xfce
# No longer importing scheduler: from . import scheduler as sched
from . import systemd as sysd # Use alias for clarity

# zoneinfo needed here for status/period calculation and sun time calculations
try:
    from zoneinfo import (
        ZoneInfo,
        ZoneInfoNotFoundError,
    )
except ImportError:
    # This should be caught by Python version checks or at a higher level.
    # If fluxfce_core is imported, this implies Python 3.9+
    raise ImportError(
        "Required module 'zoneinfo' not found. FluxFCE requires Python 3.9+."
    )


log = logging.getLogger(__name__)

# --- Internal Helper ---

# Instantiate managers that are reused across API calls
_cfg_mgr = cfg.ConfigManager()
_xfce_handler = xfce.XfceHandler()
_sysd_mgr = sysd.SystemdManager() # Module-level instance for SystemdManager

def _load_config_with_defaults() -> configparser.ConfigParser:
    """Internal helper to load configuration, applying defaults in memory."""
    try:
        return _cfg_mgr.load_config()
    except exc.ConfigError as e:
        log.error(f"API Helper: Failed to load configuration: {e}")
        raise # Re-raise the specific ConfigError
    except Exception as e:
        log.exception(f"API Helper: Unexpected error loading configuration: {e}")
        raise exc.FluxFceError(f"Unexpected error loading configuration: {e}") from e

def _apply_settings_for_mode(mode: str) -> bool:
    """Internal helper to apply all settings for 'day' or 'night'."""
    if mode not in ["day", "night"]:
        raise exc.ValidationError(f"Invalid mode specified for apply: {mode}")

    config_obj = _load_config_with_defaults()
    theme_key = "LIGHT_THEME" if mode == "day" else "DARK_THEME"
    bg_section = "BackgroundDay" if mode == "day" else "BackgroundNight"
    screen_section = "ScreenDay" if mode == "day" else "ScreenNight"

    theme = config_obj.get("Themes", theme_key, fallback=None)
    bg_hex1 = config_obj.get(bg_section, "BG_HEX1", fallback=None)
    bg_hex2 = config_obj.get(bg_section, "BG_HEX2", fallback=None)
    bg_dir = config_obj.get(bg_section, "BG_DIR", fallback=None)
    temp_str = config_obj.get(screen_section, "XSCT_TEMP", fallback=None)
    bright_str = config_obj.get(screen_section, "XSCT_BRIGHT", fallback=None)

    if not theme:
        raise exc.ConfigError(f"Theme '{theme_key}' not configured in [Themes].")

    xsct_temp: Optional[int] = None
    xsct_bright: Optional[float] = None
    try:
        if mode == "day" and (temp_str == "" or bright_str == ""):
            log.info("Day mode specifies resetting screen temperature/brightness.")
        elif (
            temp_str is not None and temp_str != "" and
            bright_str is not None and bright_str != ""
        ):
            xsct_temp = int(temp_str)
            xsct_bright = float(bright_str)
    except (ValueError, TypeError) as e:
        log.warning(
            f"Could not parse screen settings from [{screen_section}]: {e}. Screen settings skipped."
        )

    theme_ok, bg_ok, screen_ok = True, True, True

    try:
        log.info(f"API: Applying theme '{theme}' for mode '{mode}'")
        _xfce_handler.set_gtk_theme(theme)
    except (exc.XfceError, exc.ValidationError) as e:
        log.error(f"API: Failed to set theme: {e}")
        theme_ok = False
        raise exc.FluxFceError(f"Critical failure setting theme '{theme}': {e}") from e

    if bg_hex1 and bg_dir:
        try:
            log.info(
                f"API: Applying background (Dir={bg_dir}, Hex1={bg_hex1}, Hex2={bg_hex2}) for mode '{mode}'"
            )
            _xfce_handler.set_background(bg_hex1, bg_hex2, bg_dir)
        except (exc.XfceError, exc.ValidationError) as e:
            log.error(f"API: Failed to set background: {e}")
            bg_ok = False
    else:
        log.info("API: Background not fully configured, skipping background set.")

    try:
        log.info(
            f"API: Applying screen settings (Temp={xsct_temp}, Bright={xsct_bright}) for mode '{mode}'"
        )
        _xfce_handler.set_screen_temp(xsct_temp, xsct_bright)
    except (exc.XfceError, exc.ValidationError) as e:
        log.error(f"API: Failed to set screen settings: {e}")
        screen_ok = False

    if not theme_ok: return False
    if not bg_ok: log.warning(f"Mode '{mode}' applied, but background setting failed.")
    if not screen_ok: log.warning(f"Mode '{mode}' applied, but screen setting failed.")
    return True


# --- Public API Functions for Config ---
def get_current_config() -> configparser.ConfigParser:
    """Loads the current configuration, applying defaults in memory."""
    log.debug("API: get_current_config called")
    return _load_config_with_defaults()

def save_configuration(config_obj: configparser.ConfigParser) -> bool:
    """Saves the given ConfigParser object to file."""
    log.debug("API: save_configuration called")
    try:
        return _cfg_mgr.save_config(config_obj)
    except exc.ConfigError as e:
        log.error(f"API: Failed to save configuration: {e}")
        raise
    except Exception as e:
        log.exception(f"API: Unexpected error saving configuration: {e}")
        raise exc.FluxFceError(f"Unexpected error saving configuration: {e}") from e

# --- Installation and Uninstallation ---
def install_fluxfce(script_path: str, python_executable: Optional[str] = None) -> bool:
    """
    Handles the installation process: installs static systemd units.
    Configuration is handled separately by the CLI.
    The main scheduler timer is enabled by `enable_scheduling`.
    """
    log.info(f"API: Starting {sysd._APP_NAME} installation (static systemd units).")
    try:
        # SystemdManager instance is module-level: _sysd_mgr
        success = _sysd_mgr.install_units(
            script_path=script_path, python_executable=python_executable
        )
        if success:
            log.info("API: Static systemd units installed successfully.")
            # Note: enable_scheduling() should be called by CLI after this to set up dynamic timers
            # and enable the main scheduler.timer.
            return True
        else:
            # install_units should raise on critical failure.
            raise exc.SystemdError(f"{sysd._APP_NAME} SystemdManager install_units returned False or failed internally.")
    except (exc.SystemdError, FileNotFoundError, exc.DependencyError) as e:
        log.error(f"API: Static systemd unit installation failed: {e}")
        raise
    except Exception as e:
        log.exception(f"API: Unexpected error during {sysd._APP_NAME} installation: {e}")
        raise exc.FluxFceError(f"Unexpected error during {sysd._APP_NAME} installation: {e}") from e

def uninstall_fluxfce() -> bool:
    """
    Handles the uninstallation: removes all systemd units (static and dynamic).
    Config dir removal is handled by CLI.
    """
    log.info(f"API: Starting {sysd._APP_NAME} uninstallation (all systemd units).")
    try:
        # disable_scheduling ensures dynamic timers are stopped and removed first.
        # This is important because remove_units might just delete files without stopping.
        disable_scheduling_ok = True
        try:
            disable_scheduling() # Best effort to clean up dynamic timers
        except Exception as e_disable:
            log.warning(f"API: Error during disable_scheduling in uninstall process (continuing): {e_disable}")
            disable_scheduling_ok = False

        # SystemdManager instance is module-level: _sysd_mgr
        removal_ok = _sysd_mgr.remove_units() # Removes static units and attempts to clean dynamic files
        
        if removal_ok:
            log.info(f"API: {sysd._APP_NAME} systemd units removed successfully.")
            if not disable_scheduling_ok:
                 log.warning("API: Uninstallation completed, but disabling/cleanup of dynamic timers encountered issues.")
            return True
        else:
            # remove_units should raise on critical failure.
            raise exc.SystemdError(f"{sysd._APP_NAME} SystemdManager remove_units returned False or failed critically.")
    except (exc.SystemdError, exc.DependencyError) as e:
        log.error(f"API: Failed to remove {sysd._APP_NAME} systemd units during uninstall: {e}")
        raise
    except Exception as e:
        log.exception(f"API: Unexpected error during {sysd._APP_NAME} uninstallation: {e}")
        raise exc.FluxFceError(f"Unexpected error during {sysd._APP_NAME} uninstallation: {e}") from e


# --- Scheduling API Functions (NEW IMPLEMENTATION) ---

def handle_schedule_dynamic_transitions_command(python_exe_path: str, script_exe_path: str) -> bool:
    """
    Calculates next sun events, writes dynamic systemd timers, and starts them.
    Called by the fluxfce-scheduler.service.
    Paths are passed by the service definition and are absolute.
    """
    log.info("API: Handling schedule-dynamic-transitions command...")
    try:
        current_config = get_current_config()
        lat_str = current_config.get("Location", "LATITUDE")
        lon_str = current_config.get("Location", "LONGITUDE")
        tz_name = current_config.get("Location", "TIMEZONE")

        if not all([lat_str, lon_str, tz_name]):
            raise exc.ConfigError("Location (latitude, longitude, timezone) not fully configured for scheduling.")

        lat = helpers.latlon_str_to_float(lat_str)
        lon = helpers.latlon_str_to_float(lon_str)
        
        try:
            local_tz = ZoneInfo(tz_name)
        except ZoneInfoNotFoundError:
            raise exc.ConfigError(f"Invalid timezone in configuration: {tz_name}")

        now_local = datetime.now(local_tz)
        today_local = now_local.date()
        
        # Store next local event datetimes
        next_event_times: dict[str, Optional[datetime]] = {"day": None, "night": None}

        # Check today and tomorrow for the next relevant sunrise/sunset
        for day_offset in range(2): # 0 for today, 1 for tomorrow
            target_date = today_local + timedelta(days=day_offset)
            try:
                sun_times = sun.get_sun_times(lat, lon, target_date, tz_name)
                
                # If 'day' (sunrise) event for this iteration is in the future and not yet found
                if not next_event_times["day"] and sun_times["sunrise"] > now_local:
                    next_event_times["day"] = sun_times["sunrise"]
                
                # If 'night' (sunset) event for this iteration is in the future and not yet found
                if not next_event_times["night"] and sun_times["sunset"] > now_local:
                    next_event_times["night"] = sun_times["sunset"]
            
            except exc.CalculationError as e: # Handles polar day/night for target_date
                log.warning(f"Could not calculate sun times for {target_date} to determine transitions: {e}")
            
            # If both next events are found, no need to check further days
            if next_event_times["day"] and next_event_times["night"]:
                break
        
        # Stop any existing dynamic timers first for a clean update.
        # This prevents issues if this command runs multiple times before a timer fires.
        _sysd_mgr._run_systemctl(
            ["stop", sysd.SUNRISE_EVENT_TIMER_NAME, sysd.SUNSET_EVENT_TIMER_NAME],
            check_errors=False,
            capture_output=True # Capture output to prevent "Unit not loaded" messages
        )

        scheduled_any_timer = False
        utc_tz = ZoneInfo("UTC")

        # Schedule Sunrise Timer
        if next_event_times["day"]:
            utc_sunrise_event_time = next_event_times["day"].astimezone(utc_tz)
            _sysd_mgr.write_dynamic_event_timer_unit_file("day", utc_sunrise_event_time)
            scheduled_any_timer = True
            log.info(f"Dynamic timer for SUNRISE prepared for: {utc_sunrise_event_time.strftime('%Y-%m-%d %H:%M:%S %Z')}")
        else:
            log.warning("No upcoming sunrise event found to schedule. Removing existing timer if any.")
            (sysd.SYSTEMD_USER_DIR / sysd.SUNRISE_EVENT_TIMER_NAME).unlink(missing_ok=True)

        # Schedule Sunset Timer
        if next_event_times["night"]:
            utc_sunset_event_time = next_event_times["night"].astimezone(utc_tz)
            _sysd_mgr.write_dynamic_event_timer_unit_file("night", utc_sunset_event_time)
            scheduled_any_timer = True
            log.info(f"Dynamic timer for SUNSET prepared for: {utc_sunset_event_time.strftime('%Y-%m-%d %H:%M:%S %Z')}")
        else:
            log.warning("No upcoming sunset event found to schedule. Removing existing timer if any.")
            (sysd.SYSTEMD_USER_DIR / sysd.SUNSET_EVENT_TIMER_NAME).unlink(missing_ok=True)

        # Reload systemd daemon to recognize new/changed timer files
        _sysd_mgr._run_systemctl(["daemon-reload"], capture_output=True)

        # ---> REINSTATE THE START CALLS <---
        # Start the dynamic timers to ensure they are active and counting down.
        # If they were already running, this (after daemon-reload) ensures they use the new schedule.
        # If they weren't, this starts them.
        if next_event_times["day"]:
             _sysd_mgr._run_systemctl(["start", sysd.SUNRISE_EVENT_TIMER_NAME], check_errors=False, capture_output=True) 
        if next_event_times["night"]:
             _sysd_mgr._run_systemctl(["start", sysd.SUNSET_EVENT_TIMER_NAME], check_errors=False, capture_output=True)
        
        if not scheduled_any_timer:
            log.warning("No sun event timers could be scheduled (e.g. polar night/day).")
            return True 
        
        log.info("Dynamic event timers (re)written, daemon reloaded, and timers (re)started.") # Updated log message
        return True

    except (exc.ConfigError, exc.ValidationError, exc.SystemdError, exc.FluxFceError) as e:
        log.error(f"API: Failed to schedule dynamic transitions: {e}")
        return False # Indicate failure to the calling service
    except Exception as e:
        log.exception(f"API: Unexpected error during schedule-dynamic-transitions: {e}")
        return False

def enable_scheduling(python_exe_path: str, script_exe_path: str) -> bool:
    """
    Enables automatic theme transitions:
    1. Sets up initial dynamic event timers for the next sunrise/sunset.
    2. Enables and starts the main daily scheduler timer (fluxfce-scheduler.timer).
    """
    log.info("API: Enabling scheduling with dynamic systemd timers...")
    try:
        # 1. Set up initial dynamic event timers for the immediate next transitions.
        # Paths are needed here as this might be called from CLI directly.
        initial_setup_ok = handle_schedule_dynamic_transitions_command(python_exe_path, script_exe_path)
        if not initial_setup_ok:
            # Log as warning because the main scheduler will still be enabled to try again.
            log.warning("API: Initial setup of dynamic event timers failed or scheduled nothing, "
                        "but proceeding to enable the main daily scheduler.")
            # Depending on desired strictness, one might choose to return False here.
            # However, the daily scheduler should eventually fix it.

        # 2. Enable and --now start the main daily scheduler timer.
        # `--now` ensures that if its OnCalendar=daily already passed for today, it runs immediately
        # to schedule the dynamic timers (redundant if initial_setup_ok, but safe).
        code, _, stderr = _sysd_mgr._run_systemctl(["enable", "--now", sysd.SCHEDULER_TIMER_NAME], capture_output=True)
        if code != 0:
            raise exc.SystemdError(
                f"Failed to enable and start main scheduler timer ({sysd.SCHEDULER_TIMER_NAME}): {stderr.strip()}"
            )
        
        log.info(f"API: Main scheduler ({sysd.SCHEDULER_TIMER_NAME}) enabled and started.")
        log.info("API: Scheduling enabled successfully.")
        return True
        
    except (exc.SystemdError, exc.FluxFceError) as e:
        log.error(f"API: Failed to enable scheduling: {e}")
        raise # Re-raise specific, known errors
    except Exception as e:
        log.exception(f"API: Unexpected error enabling scheduling: {e}")
        # Wrap unexpected errors
        raise exc.FluxFceError(f"An unexpected error occurred while enabling scheduling: {e}") from e

def disable_scheduling() -> bool:
    """
    Disables automatic theme transitions:
    1. Stops and disables the main scheduler timer (fluxfce-scheduler.timer).
    2. Stops and removes the dynamic event timer files (sunrise/sunset).
    3. Reloads the systemd daemon.
    """
    log.info("API: Disabling scheduling and removing dynamic systemd timers...")
    try:
        # 1. Stop and disable the main scheduler timer
        _sysd_mgr._run_systemctl(["stop", sysd.SCHEDULER_TIMER_NAME], check_errors=False, capture_output=True)
        _sysd_mgr._run_systemctl(["disable", sysd.SCHEDULER_TIMER_NAME], check_errors=False, capture_output=True)
        log.debug(f"API: Main scheduler timer ({sysd.SCHEDULER_TIMER_NAME}) stopped and disabled.")

        # 2. Stop the dynamic event timers
        _sysd_mgr._run_systemctl(["stop", sysd.SUNRISE_EVENT_TIMER_NAME], check_errors=False, capture_output=True)
        _sysd_mgr._run_systemctl(["stop", sysd.SUNSET_EVENT_TIMER_NAME], check_errors=False, capture_output=True)
        log.debug("API: Dynamic event timers stopped.")

        # 3. Delete the dynamic event timer files
        sunrise_timer_path = sysd.SYSTEMD_USER_DIR / sysd.SUNRISE_EVENT_TIMER_NAME
        sunset_timer_path = sysd.SYSTEMD_USER_DIR / sysd.SUNSET_EVENT_TIMER_NAME
        
        try:
            sunrise_timer_path.unlink(missing_ok=True)
            log.debug(f"API: Removed {sysd.SUNRISE_EVENT_TIMER_NAME} (if existed).")
        except OSError as e:
            log.warning(f"API: Could not remove {sysd.SUNRISE_EVENT_TIMER_NAME}: {e}")
            
        try:
            sunset_timer_path.unlink(missing_ok=True)
            log.debug(f"API: Removed {sysd.SUNSET_EVENT_TIMER_NAME} (if existed).")
        except OSError as e:
            log.warning(f"API: Could not remove {sysd.SUNSET_EVENT_TIMER_NAME}: {e}")

        # 4. Reload systemd daemon
        _sysd_mgr._run_systemctl(["daemon-reload"], capture_output=True)
        log.debug("API: Systemd daemon reloaded.")
        
        # 5. Reset failed state for these units to clean up systemd's view
        units_to_reset = [
            sysd.SCHEDULER_TIMER_NAME, 
            sysd.SUNRISE_EVENT_TIMER_NAME, 
            sysd.SUNSET_EVENT_TIMER_NAME
        ]
        _sysd_mgr._run_systemctl(["reset-failed", *units_to_reset], check_errors=False, capture_output=True)

        log.info("API: Scheduling disabled successfully.")
        return True

    except (exc.SystemdError, exc.FluxFceError) as e:
        log.error(f"API: Failed to disable scheduling: {e}")
        raise
    except Exception as e:
        log.exception(f"API: Unexpected error disabling scheduling: {e}")
        raise exc.FluxFceError(f"An unexpected error occurred while disabling scheduling: {e}") from e

# --- Manual Mode and Defaults ---
def apply_manual_mode(mode: str) -> bool:
    """Manually applies Day or Night mode settings and disables scheduling."""
    log.info(f"API: Manually applying mode '{mode}' and disabling schedule...")
    apply_ok = False
    try:
        apply_ok = _apply_settings_for_mode(mode)
    except exc.FluxFceError as e:
        log.error(f"API: Failed critical apply step for mode '{mode}': {e}")
        raise

    try:
        disable_ok = disable_scheduling() # Use the updated disable_scheduling
        if not disable_ok:
            log.warning("API: Applied settings, but failed to properly disable/cleanup schedule.")
    except exc.FluxFceError as e: # disable_scheduling can raise FluxFceError
        log.warning(f"API: Applied settings, but an error occurred disabling schedule: {e}")
    
    return apply_ok

def set_default_from_current(mode: str) -> bool:
    """Saves current desktop settings as the new default for Day or Night mode."""
    if mode not in ["day", "night"]:
        raise exc.ValidationError(f"Invalid mode for set-default: {mode}")
    log.info(f"API: Saving current desktop settings as default for mode '{mode}'...")
    try:
        current_theme = _xfce_handler.get_gtk_theme()
        current_bg = None
        try:
            current_bg = _xfce_handler.get_background_settings()
        except exc.XfceError as bg_e:
            log.warning(f"API: Could not get current background settings: {bg_e}. Skipping background save.")
        current_screen = _xfce_handler.get_screen_settings()

        config_obj = _load_config_with_defaults()
        config_changed = False

        theme_key = "LIGHT_THEME" if mode == "day" else "DARK_THEME"
        if config_obj.get("Themes", theme_key, fallback=None) != current_theme:
            _cfg_mgr.set_setting(config_obj, "Themes", theme_key, current_theme)
            config_changed = True

        bg_section = "BackgroundDay" if mode == "day" else "BackgroundNight"
        if current_bg:
            for key, config_key in [("dir", "BG_DIR"), ("hex1", "BG_HEX1"), ("hex2", "BG_HEX2")]:
                new_value = current_bg.get(key)
                current_value = config_obj.get(bg_section, config_key, fallback=None)
                new_value_str = str(new_value) if new_value is not None else ""
                current_value_str = str(current_value) if current_value is not None else ""
                if new_value_str != current_value_str:
                    _cfg_mgr.set_setting(config_obj, bg_section, config_key, new_value_str)
                    config_changed = True
        
        screen_section = "ScreenDay" if mode == "day" else "ScreenNight"
        temp_to_save: Optional[str] = None
        bright_to_save: Optional[str] = None
        if current_screen:
            cur_temp, cur_bright = current_screen.get("temperature"), current_screen.get("brightness")
            if cur_temp is None and cur_bright is None: # xsct is off or reset
                temp_to_save, bright_to_save = "", ""
            elif cur_temp is not None and cur_bright is not None:
                temp_to_save, bright_to_save = str(cur_temp), f"{cur_bright:.2f}"
            else: log.warning("API: Inconsistent screen settings read; not updating defaults.")

        if temp_to_save is not None and bright_to_save is not None:
            if config_obj.get(screen_section, "XSCT_TEMP", fallback=None) != temp_to_save:
                _cfg_mgr.set_setting(config_obj, screen_section, "XSCT_TEMP", temp_to_save)
                config_changed = True
            if config_obj.get(screen_section, "XSCT_BRIGHT", fallback=None) != bright_to_save:
                _cfg_mgr.set_setting(config_obj, screen_section, "XSCT_BRIGHT", bright_to_save)
                config_changed = True

        if config_changed:
            if save_configuration(config_obj):
                log.info(f"API: Successfully saved updated defaults for mode '{mode}'.")
                return True
            return False # save_configuration should raise on failure
        else:
            log.info(f"API: Current settings already match defaults for '{mode}'. No changes made.")
            return True
    except (exc.ValidationError, exc.XfceError, exc.ConfigError) as e:
        log.error(f"API: Failed to set default from current: {e}")
        raise
    except Exception as e:
        log.exception(f"API: Unexpected error setting default from current: {e}")
        raise exc.FluxFceError(f"Unexpected error setting default from current: {e}") from e

# --- Status Function ---
def get_status() -> dict[str, Any]:
    """Retrieves the current status of fluxfce."""
    log.debug("API: Getting status...")
    status: dict[str, Any] = {
        "config": {},
        "sun_times": {"sunrise": None, "sunset": None, "error": None},
        "current_period": "unknown",
        "schedule": {"error": None, "timers": {}}, # Updated for systemd timers
        "systemd_services": {"error": None}, # For login, resume, scheduler *service*
    }

    # 1. Get Config
    try:
        config_obj = get_current_config()
        status["config"]["latitude"] = config_obj.get("Location", "LATITUDE", fallback="Not Set")
        status["config"]["longitude"] = config_obj.get("Location", "LONGITUDE", fallback="Not Set")
        status["config"]["timezone"] = config_obj.get("Location", "TIMEZONE", fallback="Not Set")
        status["config"]["light_theme"] = config_obj.get("Themes", "LIGHT_THEME", fallback="Not Set")
        status["config"]["dark_theme"] = config_obj.get("Themes", "DARK_THEME", fallback="Not Set")
    except exc.FluxFceError as e:
        status["config"]["error"] = str(e)

    # 2. Calculate Sun Times & Current Period
    if "error" not in status["config"]:
        lat_str = status["config"]["latitude"]
        lon_str = status["config"]["longitude"]
        tz_name = status["config"]["timezone"]
        if lat_str and lon_str and tz_name and tz_name != "Not Set" and lat_str !="Not Set" and lon_str != "Not Set":
            try:
                lat = helpers.latlon_str_to_float(lat_str)
                lon = helpers.latlon_str_to_float(lon_str)
                tz_info = ZoneInfo(tz_name)
                today = datetime.now(tz_info).date()
                sun_times_today = sun.get_sun_times(lat, lon, today, tz_name)
                status["sun_times"]["sunrise"] = sun_times_today["sunrise"]
                status["sun_times"]["sunset"] = sun_times_today["sunset"]
                now_local = datetime.now(tz_info)
                status["current_period"] = "day" if sun_times_today["sunrise"] <= now_local < sun_times_today["sunset"] else "night"
            except (exc.ValidationError, exc.CalculationError, ZoneInfoNotFoundError) as e:
                status["sun_times"]["error"] = str(e)
                status["current_period"] = "error"
            except Exception as e: # Catch-all for unexpected issues
                log.exception("API: Unexpected error calculating sun times for status.")
                status["sun_times"]["error"] = f"Unexpected in sun times: {e}"
                status["current_period"] = "error"
        else:
            status["sun_times"]["error"] = "Location/Timezone not fully configured."
            status["current_period"] = "unknown (config incomplete)"
    
    # 3. Get Systemd Timer Schedule Status
    timer_names_to_query = [
        sysd.SCHEDULER_TIMER_NAME,
        sysd.SUNRISE_EVENT_TIMER_NAME,
        sysd.SUNSET_EVENT_TIMER_NAME,
    ]
    try:
        code, stdout_timers, stderr_timers = _sysd_mgr._run_systemctl(
            ["list-timers", "--all", *timer_names_to_query],
            check_errors=False, capture_output=True
        )
        if code != 0 and not ("0 timers listed." in stdout_timers or "No timers found." in stdout_timers) :
            status["schedule"]["error"] = f"Failed to list systemd timers (code {code}): {stderr_timers.strip() or stdout_timers.strip()}"
        
        if stdout_timers:
            parsed_timers = {}
            lines = stdout_timers.strip().split('\n')
            if len(lines) > 1: # Header + data lines
                header_line = lines[0].upper()
                col_indices = { # Store start indices of columns
                    "NEXT": header_line.find("NEXT"),
                    "LEFT": header_line.find("LEFT"),
                    "LAST": header_line.find("LAST"),
                    "PASSED": header_line.find("PASSED"), # Not used by print_status but parsed
                    "UNIT": header_line.find("UNIT"),
                    "ACTIVATES": header_line.find("ACTIVATES"),
                }
                # Filter out -1 (column not found) and sort by index to handle order variations
                sorted_cols = sorted([(name, idx) for name, idx in col_indices.items() if idx != -1], key=lambda item: item[1])

                for line_content in lines[1:]: # Skip header line
                    if not line_content.strip(): continue
                    
                    timer_data_raw = {} # Stores raw data parsed by column name
                    current_unit_name = "Unknown"
                    
                    for i, (col_name, start_idx) in enumerate(sorted_cols):
                        # Determine end_idx for the current field
                        # If it's the last column, take content to the end of the line
                        end_idx = sorted_cols[i+1][1] if i + 1 < len(sorted_cols) else len(line_content)
                        field_value = line_content[start_idx:end_idx].strip()
                        timer_data_raw[col_name.lower()] = field_value
                        if col_name == "UNIT": # UNIT is a guaranteed column name
                            current_unit_name = field_value
                    
                    if current_unit_name != "Unknown" and current_unit_name in timer_names_to_query:
                        # Get enabled/active status (ensure capture_output=True)
                        is_enabled_code, _, _ = _sysd_mgr._run_systemctl(
                            ["is-enabled", current_unit_name], check_errors=False, capture_output=True
                        )
                        is_active_code, _, _ = _sysd_mgr._run_systemctl(
                            ["is-active", current_unit_name], check_errors=False, capture_output=True
                        )
                        
                        # Map raw parsed data to keys expected by print_status in fluxfce_cli.py
                        final_timer_data_for_cli = {
                            "enabled": "Enabled" if is_enabled_code == 0 else "Disabled",
                            "active": "Active" if is_active_code == 0 else "Inactive",
                            "next_run": timer_data_raw.get("next", "N/A"),
                            "time_left": timer_data_raw.get("left", "N/A"),
                            "last_run": timer_data_raw.get("last", "N/A"),
                            "activates": timer_data_raw.get("activates", "N/A")
                            # "passed" is parsed into timer_data_raw.get("passed") but not used by CLI's print_status
                        }
                        parsed_timers[current_unit_name] = final_timer_data_for_cli
            
            status["schedule"]["timers"] = parsed_timers
            if not parsed_timers and not status["schedule"]["error"]:
                status["schedule"]["info"] = "No relevant fluxfce timers found or listed."

    except Exception as e:
        log.exception("API: Unexpected error getting systemd timer schedule status.")
        status["schedule"]["error"] = f"Unexpected error querying timers: {e}"

    # 4. Get Systemd Service Status (Login, Resume, Scheduler Service itself)
    services_to_check = {
        "scheduler_service": sysd.SCHEDULER_SERVICE_NAME,
        "login_service": sysd.LOGIN_SERVICE_NAME,
        "resume_service": sysd.RESUME_SERVICE_NAME,
    }
    for key, unit_name in services_to_check.items():
        try:
            # Ensure capture_output=True
            enabled_code, _, _ = _sysd_mgr._run_systemctl(
                ["is-enabled", unit_name], check_errors=False, capture_output=True
            )
            active_code, _, _ = _sysd_mgr._run_systemctl(
                ["is-active", unit_name], check_errors=False, capture_output=True
            )
            status["systemd_services"][key] = f"{'Enabled' if enabled_code == 0 else 'Disabled'}, {'Active' if active_code == 0 else 'Inactive'}"
        except exc.SystemdError as e: # Should be caught by _run_systemctl if it raises
            status["systemd_services"][key] = f"Error checking: {e}"
            status["systemd_services"]["error"] = status["systemd_services"].get("error","") + f" Error with {key}. "
        except Exception as e: # For unexpected errors not wrapped by _run_systemctl
            log.exception(f"API: Unexpected error getting status for service {unit_name}")
            status["systemd_services"][key] = "Unexpected error checking"
            status["systemd_services"]["error"] = status["systemd_services"].get("error","") + f" Unexpected with {key}. "
            
    return status

# --- Internal Command Handlers (Called by Executable Script / Systemd) ---
def handle_internal_apply(mode: str) -> bool:
    """Called by systemd (fluxfce-apply-transition@.service) to apply mode."""
    log.info(f"API: Internal apply called for mode '{mode}'")
    try:
        return _apply_settings_for_mode(mode)
    except exc.FluxFceError as e:
        log.error(f"API: Error during internal apply for mode '{mode}': {e}")
        return False
    except Exception as e:
        log.exception(f"API: Unexpected error during internal apply for mode '{mode}': {e}")
        return False

def handle_run_login_check() -> bool:
    """
    Called by systemd (fluxfce-login.service, fluxfce-resume.service).
    Determines current period and applies appropriate theme.
    """
    log.info("API: Handling run-login-check command...")
    try:
        config_obj = _load_config_with_defaults()
        lat_str = config_obj.get("Location", "LATITUDE")
        lon_str = config_obj.get("Location", "LONGITUDE")
        tz_name = config_obj.get("Location", "TIMEZONE")
        mode_to_apply = "night" # Default assumption

        if lat_str and lon_str and tz_name and tz_name != "Not Set":
            try:
                lat = helpers.latlon_str_to_float(lat_str)
                lon = helpers.latlon_str_to_float(lon_str)
                tz_info = ZoneInfo(tz_name)
                now_local = datetime.now(tz_info)
                today = now_local.date()
                sun_times = sun.get_sun_times(lat, lon, today, tz_name)
                if sun_times["sunrise"] <= now_local < sun_times["sunset"]:
                    mode_to_apply = "day"
                log.info(f"API: Login check determined current mode: '{mode_to_apply}'")
            except (exc.ValidationError, exc.CalculationError, ZoneInfoNotFoundError) as e:
                log.warning(f"API: Could not determine mode for login check ({e}). Defaulting to '{mode_to_apply}'.")
            except Exception as e_sun: # Catch-all for unexpected issues in sun time logic
                log.exception(f"API: Unexpected error determining mode for login check ({e_sun}). Defaulting to '{mode_to_apply}'.")
        else:
            log.warning("API: Location/Timezone not fully configured for login check. Defaulting to 'night'.")
        
        log.info(f"API: Applying mode '{mode_to_apply}' for login/resume check.")
        return _apply_settings_for_mode(mode_to_apply)

    except exc.FluxFceError as e:
        log.error(f"API: Error during run-login-check: {e}")
        return False
    except Exception as e: # Catch-all for unexpected issues
        log.exception(f"API: Unexpected error during run-login-check: {e}")
        return False
##############
./fluxfce_core/config.py

# ~/dev/fluxfce-simplified/fluxfce_core/config.py

import configparser
import logging
import pathlib

# typing.Dict and typing.Optional will be flagged by ruff (UP006/UP007/UP035)
# and can be changed to dict and | None (or just Optional if Python < 3.10 for return only)
# For now, keeping them as per original file for direct comparison of state file removal.
from typing import Optional

# Import custom exceptions from within the same package
from .exceptions import (
    ConfigError,
)  # ValidationError is not used in this file after changes

log = logging.getLogger(__name__)

# --- Constants ---
APP_NAME = "fluxfce"
CONFIG_DIR = pathlib.Path.home() / ".config" / APP_NAME
CONFIG_FILE = CONFIG_DIR / "config.ini"
# STATE_FILE constant removed

# Default configuration values
DEFAULT_CONFIG: dict[str, dict[str, str]] = (
    {  # Ruff will suggest: dict[str, dict[str, str]]
        "Location": {
            "LATITUDE": "43.65N",  # Toronto Latitude (Example)
            "LONGITUDE": "79.38W",  # Toronto Longitude (Example)
            "TIMEZONE": "America/Toronto",  # IANA Timezone Name
        },
        "Themes": {
            "LIGHT_THEME": "Arc-Lighter",
            "DARK_THEME": "Materia-dark-compact",
        },
        "BackgroundDay": {
            "BG_HEX1": "ADD8E6",
            "BG_HEX2": "87CEEB",
            "BG_DIR": "v",
        },
        "ScreenDay": {
            "XSCT_TEMP": "6500",  # Typically reset, but provide a default value
            "XSCT_BRIGHT": "1.0",  # Typically reset, but provide a default value
        },
        "BackgroundNight": {
            "BG_HEX1": "1E1E2E",
            "BG_HEX2": "000000",
            "BG_DIR": "v",
        },
        "ScreenNight": {
            "XSCT_TEMP": "4500",
            "XSCT_BRIGHT": "0.85",
        },
    }
)


# --- Configuration Manager ---


class ConfigManager:
    """Handles reading/writing config.ini."""  # Docstring updated: "and state file" removed

    def __init__(self):
        """Ensures the configuration directory exists."""
        try:
            CONFIG_DIR.mkdir(parents=True, exist_ok=True)
            log.debug(f"Configuration directory ensured: {CONFIG_DIR}")
        except OSError as e:
            # This is potentially serious, raise it.
            raise ConfigError(
                f"Failed to create configuration directory {CONFIG_DIR}: {e}"
            ) from e

    def _load_ini(self, file_path: pathlib.Path) -> configparser.ConfigParser:
        """Loads an INI file, returning a ConfigParser object."""
        parser = configparser.ConfigParser()
        if file_path.exists():
            try:
                # Handle potential empty file
                if file_path.stat().st_size > 0:
                    read_files = parser.read(file_path, encoding="utf-8")
                    if not read_files:
                        log.warning(
                            f"Config file {file_path} was reported as read, but might be empty or unparseable by configparser."
                        )
                    else:
                        log.debug(f"Loaded config from {file_path}")
                else:
                    log.warning(f"Config file {file_path} is empty.")
            except configparser.Error as e:
                # Raise specific error for parsing issues
                raise ConfigError(
                    f"Could not parse config file {file_path}: {e}"
                ) from e
            except (
                OSError
            ) as e:  # Changed from IOError to OSError for broader catch, though read_text uses OSError
                raise ConfigError(f"Could not read config file {file_path}: {e}") from e
        else:
            log.debug(f"Config file {file_path} not found. Returning empty parser.")

        return parser

    def _save_ini(
        self, parser: configparser.ConfigParser, file_path: pathlib.Path
    ) -> bool:
        """Saves a ConfigParser object to an INI file."""
        try:
            with file_path.open("w", encoding="utf-8") as f:
                parser.write(f)
            log.debug(f"Saved configuration to {file_path}")
            return True
        except OSError as e:  # Changed from IOError to OSError for broader catch
            raise ConfigError(
                f"Failed to write configuration to {file_path}: {e}"
            ) from e

    def load_config(self) -> configparser.ConfigParser:
        """
        Loads the main config.ini (config.CONFIG_FILE).

        Applies default values (from config.DEFAULT_CONFIG) for any missing
        sections or keys directly to the returned ConfigParser object.
        It does *not* automatically save the file after applying defaults;
        the caller can modify further and then call save_config.

        Returns:
            A ConfigParser object representing the configuration.

        Raises:
            ConfigError: If the file cannot be read or parsed.
        """
        parser = self._load_ini(CONFIG_FILE)
        # Apply defaults in memory without saving immediately
        made_changes = False
        for section, defaults in DEFAULT_CONFIG.items():
            if not parser.has_section(section):
                parser.add_section(section)
                made_changes = True
                log.debug(f"Added missing section [{section}] to config object")
            for key, value in defaults.items():
                if not parser.has_option(section, key):
                    parser.set(section, key, value)
                    made_changes = True
                    log.debug(
                        f"Added missing key '{key}' = '{value}' to section [{section}] in config object"
                    )

        if made_changes:
            log.info("Default values applied in memory to the loaded configuration.")
            # Caller must call save_config explicitly if they want to persist these defaults

        return parser

    def save_config(self, config: configparser.ConfigParser) -> bool:
        """
        Saves the provided ConfigParser object to the main config.ini file.

        Args:
            config: The ConfigParser object to save.

        Returns:
            True if saving was successful.

        Raises:
            ConfigError: If the file cannot be written.
        """
        log.info(f"Saving configuration to {CONFIG_FILE}")
        return self._save_ini(config, CONFIG_FILE)

    # --- Presets Removed ---

    def get_setting(
        self,
        config: configparser.ConfigParser,
        section: str,
        key: str,
        default: Optional[str] = None,  # Ruff will suggest: str | None = None
    ) -> Optional[str]:  # Ruff will suggest: str | None
        """Gets a setting value from a ConfigParser object."""
        # Uses configparser's fallback mechanism
        return config.get(section, key, fallback=default)

    def set_setting(
        self, config: configparser.ConfigParser, section: str, key: str, value: str
    ):
        """
        Sets a setting value in a ConfigParser object.
        Creates the section if it doesn't exist.
        """
        if not config.has_section(section):
            log.debug(
                f"Adding section [{section}] to config object for setting key '{key}'"
            )
            config.add_section(section)
        log.debug(f"Setting [{section}] {key} = '{value}' in config object")
        config.set(section, key, value)

##############
./fluxfce_core/exceptions.py

# fluxfce_core/exceptions.py
class FluxFceError(Exception):
    """Base exception for fluxfce core errors."""

    pass


class ConfigError(FluxFceError):
    """Errors related to configuration loading, saving, or validation."""

    pass


class CalculationError(FluxFceError):
    """Errors during sunrise/sunset calculation."""

    pass


class XfceError(FluxFceError):
    """Errors interacting with xfconf-query or xsct."""

    pass


class SchedulerError(FluxFceError):
    """Errors interacting with atd (at, atq, atrm)."""

    pass


class SystemdError(FluxFceError):
    """Errors interacting with systemctl."""

    pass


class DependencyError(FluxFceError):
    """Errors due to missing external command dependencies."""

    pass


class ValidationError(FluxFceError):
    """Errors for invalid user input or data formats."""

    pass

##############
./fluxfce_core/helpers.py

# ~/dev/fluxfce-simplified/fluxfce_core/helpers.py

import logging
import os
import pathlib
import re
import shutil
import subprocess
from typing import Optional

try:
    from zoneinfo import ZoneInfo, ZoneInfoNotFoundError
except ImportError:
    raise ImportError(
        "Required module 'zoneinfo' not found. FluxFCE requires Python 3.9+."
    )
# Import custom exceptions from within the same package
from .exceptions import DependencyError, FluxFceError, ValidationError

# Setup a logger specific to this module for internal debugging
log = logging.getLogger(__name__)

# --- Command Execution ---


def run_command(
    cmd_list: list[str],
    check: bool = False,
    capture: bool = True,
    input_str: Optional[str] = None,
) -> tuple[int, str, str]:
    """
    Runs an external command and returns its status, stdout, and stderr.

    Args:
        cmd_list: The command and its arguments as a list of strings.
        check: If True, raise CalledProcessError if the command returns non-zero.
               (Note: Generally, we'll use check=False and handle errors based
               on the return code in the calling function for more specific
               exception types).
        capture: If True (default), capture stdout and stderr. If False, they are
                 not captured (sent to system stdout/stderr).
        input_str: Optional string to pass as standard input to the command.

    Returns:
        A tuple containing: (return_code, stdout_str, stderr_str).
        stdout_str and stderr_str will be empty if capture=False.

    Raises:
        FileNotFoundError: If the command executable is not found.
        subprocess.CalledProcessError: If check=True and the command fails.
        Exception: For other unexpected subprocess errors.
    """
    log.debug(f"Running command: {' '.join(cmd_list)}")
    stdout_pipe = subprocess.PIPE if capture else None
    stderr_pipe = subprocess.PIPE if capture else None

    try:
        process = subprocess.run(
            cmd_list,
            check=check,  # Let CalledProcessError be raised if check is True
            input=input_str,
            stdout=stdout_pipe,
            stderr=stderr_pipe,
            text=True,
            encoding="utf-8",
        )
        stdout = process.stdout.strip() if process.stdout and capture else ""
        stderr = process.stderr.strip() if process.stderr and capture else ""
        log.debug(f"Command '{cmd_list[0]}' finished with code {process.returncode}")
        if stdout and capture:
            log.debug(f"stdout: {stdout[:200]}...")  # Log truncated stdout
        if stderr and capture:
            log.debug(f"stderr: {stderr[:200]}...")  # Log truncated stderr
        return process.returncode, stdout, stderr
    except FileNotFoundError as e:
        # This specific error is often critical and worth propagating
        log.error(f"Command not found: {cmd_list[0]} - {e}")
        raise FileNotFoundError(
            f"Required command '{cmd_list[0]}' not found in PATH."
        ) from e
    except subprocess.CalledProcessError as e:
        # Log details if check=True caused the exception
        # The caller should handle this if check=True was intentional
        stdout = e.stdout.strip() if e.stdout and capture else ""
        stderr = e.stderr.strip() if e.stderr and capture else ""
        log.warning(
            f"Command failed with exit code {e.returncode}: {' '.join(cmd_list)}"
        )
        if stdout:
            log.warning(f"stdout: {stdout[:200]}...")
        if stderr:
            log.warning(f"stderr: {stderr[:200]}...")
        raise  # Re-raise the original exception if check=True
    except Exception as e:
        log.exception(
            f"An unexpected error occurred running command: {' '.join(cmd_list)} - {e}"
        )
        # Wrap unexpected errors in our base exception type
        raise FluxFceError(
            f"Unexpected error running command '{cmd_list[0]}': {e}"
        ) from e


# --- Dependency Checks ---


def check_dependencies(deps: list[str]) -> bool:
    """
    Checks if required external commands exist in PATH using shutil.which.

    Args:
        deps: A list of command names to check (e.g., ['xfconf-query', 'xsct']).

    Returns:
        True if all dependencies are found.

    Raises:
        DependencyError: If one or more dependencies are not found.
    """
    log.debug(f"Checking for dependencies: {', '.join(deps)}")
    missing = []
    for dep in deps:
        if shutil.which(dep) is None:  # shutil.which returns None if not found
            missing.append(dep)

    if missing:
        error_msg = (
            f"Missing required command(s): {', '.join(missing)}. Please install them."
        )
        log.error(error_msg)
        raise DependencyError(error_msg)

    log.debug(f"All dependencies checked successfully: {', '.join(deps)}")
    return True


def check_atd_service() -> bool:
    """
    Checks if the 'atd' service appears to be running via systemctl.

    Returns:
        True if the service is detected as active.

    Raises:
        DependencyError: If 'systemctl' command is not found.
        FluxFceError: For unexpected errors during the check or if the
                      service is confirmed not to be active.
    """
    log.debug("Checking if atd service is active...")
    # Ensure systemctl exists first
    check_dependencies(["systemctl"])

    try:
        # Check system service first
        code_sys, _, err_sys = run_command(
            ["systemctl", "is-active", "--quiet", "atd.service"]
        )
        # --quiet: return code 0 for active, non-zero otherwise (usually 3 for inactive)

        if code_sys == 0:
            log.debug("System 'atd' service reported as active.")
            return True

        log.debug(
            f"System 'atd' not active (code: {code_sys}). Checking user service..."
        )
        # Check user service as fallback (less common for atd)
        code_user, _, err_user = run_command(
            ["systemctl", "--user", "is-active", "--quiet", "atd.service"]
        )

        if code_user == 0:
            log.debug("User 'atd' service reported as active.")
            return True

        # If neither is active
        error_msg = "The 'atd' service (system or user) is not active. Automatic scheduling requires 'atd'. Please install and enable it (e.g., 'sudo systemctl enable --now atd')."
        log.error(error_msg)
        # Use FluxFceError as it's a runtime state issue, not a missing binary
        raise FluxFceError(error_msg)

    except (
        FileNotFoundError
    ):  # Should be caught by check_dependencies, but belts and suspenders
        raise DependencyError(
            "The 'systemctl' command was not found, cannot check 'atd' status."
        )
    except Exception as e:
        # Catch potential errors from run_command itself or re-raised CalledProcessError
        log.exception(f"Failed to check 'atd' status: {e}")
        raise FluxFceError(f"Failed to check 'atd' status: {e}") from e


# --- Detect timezone ---
def detect_system_timezone() -> Optional[str]:
    """
    Attempts to detect the system's configured IANA timezone name.

    Tries methods in order: TZ env var, timedatectl, /etc/localtime symlink, /etc/timezone file.

    Returns:
        The detected IANA timezone name (str) if found and valid, otherwise None.
    """
    log.debug("Attempting to detect system timezone...")

    def _is_valid_timezone(tz_name: Optional[str]) -> bool:
        """Helper to validate a potential timezone name."""
        if not tz_name or not isinstance(tz_name, str):
            return False
        try:
            ZoneInfo(tz_name)
            log.debug(f"Validated timezone '{tz_name}' successfully.")
            return True
        except ZoneInfoNotFoundError:
            log.debug(f"ZoneInfoNotFoundError for '{tz_name}'.")
            return False
        except Exception as e:
            log.warning(f"Error validating timezone '{tz_name}' with ZoneInfo: {e}")
            return False

    # 1. Check TZ environment variable first (overrides system settings)
    tz_env = os.environ.get("TZ")
    if tz_env:
        tz_env_cleaned = tz_env.lstrip(":")
        log.debug(
            f"Found TZ environment variable: '{tz_env}' (cleaned: '{tz_env_cleaned}')"
        )
        if _is_valid_timezone(tz_env_cleaned):
            log.info(f"Using timezone from TZ environment variable: {tz_env_cleaned}")
            return tz_env_cleaned
        else:
            log.warning(
                f"TZ environment variable ('{tz_env}') is set but not a valid timezone name."
            )

    # 2. Try timedatectl (systemd)
    try:
        check_dependencies(["timedatectl"])  # Check if command exists
        cmd = ["timedatectl", "show", "--property=Timezone", "--value"]
        code, stdout, stderr = run_command(cmd)
        if code == 0 and stdout:
            tz_name = stdout.strip()
            log.debug(f"timedatectl returned: '{tz_name}'")
            if _is_valid_timezone(tz_name):
                log.info(f"Detected timezone via timedatectl: {tz_name}")
                return tz_name
            else:
                log.warning(f"timedatectl returned invalid timezone: '{tz_name}'")
        else:
            log.debug(f"timedatectl command failed or returned empty (code: {code})")
    except DependencyError:
        log.debug("timedatectl command not found, skipping.")
    except Exception as e:
        log.warning(f"Error running timedatectl: {e}")

    # 3. Try /etc/localtime symlink
    localtime_path = pathlib.Path("/etc/localtime")
    if localtime_path.is_symlink():
        try:
            target = localtime_path.readlink()  # Read the target path object
            zoneinfo_dir = pathlib.Path("/usr/share/zoneinfo")
            if not target.is_absolute():
                target = (localtime_path.parent / target).resolve()
            if zoneinfo_dir in target.parents or str(target).startswith(
                str(zoneinfo_dir)
            ):
                try:
                    tz_name = str(target.relative_to(zoneinfo_dir))
                    log.debug(
                        f"/etc/localtime points to '{target}', relative zoneinfo path: '{tz_name}'"
                    )
                    if _is_valid_timezone(tz_name):
                        log.info(
                            f"Detected timezone via /etc/localtime symlink: {tz_name}"
                        )
                        return tz_name
                    else:
                        log.warning(
                            f"Extracted path '{tz_name}' from /etc/localtime link is not a valid timezone."
                        )
                except ValueError:
                    log.warning(
                        f"Could not determine relative path for localtime target '{target}' within '{zoneinfo_dir}'."
                    )
            else:
                log.debug(
                    f"/etc/localtime target '{target}' is outside standard zoneinfo directory."
                )
        except OSError as e:
            log.warning(f"Could not read /etc/localtime symlink: {e}")
        except Exception as e:
            log.exception(f"Unexpected error processing /etc/localtime link: {e}")

    # 4. Try /etc/timezone file (Debian/Ubuntu)
    timezone_path = pathlib.Path("/etc/timezone")
    if timezone_path.is_file():
        try:
            content = timezone_path.read_text(encoding="utf-8").strip()
            if content:
                tz_name = content.splitlines()[0].split()[0]
                log.debug(f"Read from /etc/timezone: '{tz_name}'")
                if _is_valid_timezone(tz_name):
                    log.info(f"Detected timezone via /etc/timezone file: {tz_name}")
                    return tz_name
                else:
                    log.warning(
                        f"Content of /etc/timezone ('{tz_name}') is not a valid timezone."
                    )
            else:
                log.debug("/etc/timezone file is empty.")
        except OSError as e:
            log.warning(f"Could not read /etc/timezone: {e}")
        except Exception as e:
            log.exception(f"Unexpected error processing /etc/timezone: {e}")

    # 5. Fallback - Could not detect
    log.warning("Failed to detect system timezone using common methods.")
    return None


# --- Data Validation ---


def latlon_str_to_float(coord_str: str) -> float:
    """
    Converts Lat/Lon string (e.g., '43.65N', '79.38W') to float degrees.

    Args:
        coord_str: The coordinate string to parse.

    Returns:
        The coordinate as a float value.

    Raises:
        ValidationError: If the format is invalid or the value is out of range.
    """
    if not isinstance(coord_str, str):
        raise ValidationError(
            f"Invalid input type for coordinate: expected string, got {type(coord_str)}"
        )

    coord_strip = coord_str.strip().upper()
    match = re.match(r"^(\d+(\.\d+)?)([NSEW])$", coord_strip)
    if not match:
        raise ValidationError(
            f"Invalid coordinate format: '{coord_str}'. Use format like '43.65N' or '79.38W'."
        )

    try:
        value = float(match.group(1))
    except ValueError:
        # Should not happen with the regex, but safeguard
        raise ValidationError(
            f"Could not convert value part '{match.group(1)}' to float."
        )

    direction = match.group(3)
    if direction in ("S", "W"):
        value = -value

    # Range check
    if direction in ("N", "S") and not (-90 <= value <= 90):
        raise ValidationError(
            f"Latitude out of range (-90 to 90): {value} ({coord_str})"
        )
    if direction in ("E", "W") and not (-180 <= value <= 180):
        raise ValidationError(
            f"Longitude out of range (-180 to 180): {value} ({coord_str})"
        )

    log.debug(f"Converted coordinate '{coord_str}' to {value}")
    return value


def hex_to_rgba_doubles(hex_color: str) -> list[float]:
    """
    Converts a 6-digit hex color string (#RRGGBB or RRGGBB) to RGBA doubles
    [R, G, B, A] (0.0-1.0), with Alpha always 1.0.

    Args:
        hex_color: The 6-digit hex color string.

    Returns:
        A list of four floats [R, G, B, A] between 0.0 and 1.0.

    Raises:
        ValidationError: If the hex string format is invalid.
    """
    if not isinstance(hex_color, str):
        raise ValidationError(
            f"Invalid input type for hex color: expected string, got {type(hex_color)}"
        )

    hex_strip = hex_color.lstrip("#")
    if not re.match(r"^[0-9a-fA-F]{6}$", hex_strip):
        raise ValidationError(f"Invalid 6-digit hex color format: '{hex_color}'")

    try:
        r = int(hex_strip[0:2], 16) / 255.0
        g = int(hex_strip[2:4], 16) / 255.0
        b = int(hex_strip[4:6], 16) / 255.0
        rgba = [r, g, b, 1.0]  # R, G, B, Alpha
        log.debug(f"Converted hex '{hex_color}' to RGBA {rgba}")
        return rgba
    except ValueError as e:
        # Should not happen with regex, but safeguard
        raise ValidationError(
            f"Could not convert hex components to integer: '{hex_color}' - {e}"
        ) from e


# --- Logging Setup (Simplified for Core Library) ---


def setup_library_logging(level=logging.WARNING):
    """
    Configures basic logging for the fluxfce_core library components.
    This is primarily intended for internal debugging and might be overridden
    by the calling application (GUI/CLI). By default, sets a higher level
    to avoid polluting the output of the consuming application unless
    debugging is explicitly enabled.
    """
    # Configure logging for the entire 'fluxfce_core' package namespace
    package_logger = logging.getLogger("fluxfce_core")

    # Avoid adding multiple handlers if called repeatedly
    if not package_logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter(
            "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
        )
        handler.setFormatter(formatter)
        package_logger.addHandler(handler)

    package_logger.setLevel(level)
    log.info(f"fluxfce_core logging configured to level: {logging.getLevelName(level)}")


# Example of how to potentially enable debug logging from outside:
# import logging
# from fluxfce_core import helpers
# helpers.setup_library_logging(level=logging.DEBUG)

##############
./fluxfce_core/__init__.py

# ~/dev/fluxfce-simplified/fluxfce_core/__init__.py

# Make exceptions available directly via fluxfce_core.FluxFceError etc.
# Make public API functions available directly via fluxfce_core.get_status etc.
from .api import (
    apply_manual_mode,
    disable_scheduling,
    enable_scheduling,
    get_current_config,
    get_status,
    # Internal handlers needed by the CLI/script entry point
    handle_internal_apply,
    handle_run_login_check,
    handle_schedule_dynamic_transitions_command, # <--- CORRECTED NAME
    install_fluxfce,
    save_configuration,
    set_default_from_current,
    uninstall_fluxfce,
)

# --- Make core constants accessible ---
from .config import CONFIG_DIR, CONFIG_FILE
from .exceptions import (
    CalculationError,
    ConfigError,
    DependencyError,
    FluxFceError,
    # SchedulerError, # No longer needed as scheduler.py is removed
    SystemdError,
    ValidationError,
    XfceError,
)

# --- Make selected helper functions accessible ---
from .helpers import detect_system_timezone

# --- ADD SYSTEMD CONSTANTS ---
from .systemd import (
    LOGIN_SERVICE_NAME,
    RESUME_SERVICE_NAME,
    SCHEDULER_SERVICE_NAME,
    SCHEDULER_TIMER_NAME,
    # Constants for dynamic timer names are not typically exported here,
    # as they are implementation details of the systemd/api interaction.
)

# Optionally define __all__ to control wildcard imports and document public interface
__all__ = [
    # Constants
    "CONFIG_DIR",
    "CONFIG_FILE",
    "LOGIN_SERVICE_NAME",
    "RESUME_SERVICE_NAME",
    "SCHEDULER_SERVICE_NAME",
    "SCHEDULER_TIMER_NAME",
    # Exceptions
    "CalculationError",
    "ConfigError",
    "DependencyError",
    "FluxFceError",
    # "SchedulerError", # Removed
    "SystemdError",
    "ValidationError",
    "XfceError",
    # API Functions
    "apply_manual_mode",
    "disable_scheduling",
    "enable_scheduling",
    "get_current_config",
    "get_status",
    "install_fluxfce",
    "save_configuration",
    "set_default_from_current",
    "uninstall_fluxfce",
    # Internal Handlers (for CLI use)
    "handle_internal_apply",
    "handle_run_login_check",
    "handle_schedule_dynamic_transitions_command", # <--- CORRECTED NAME
    # Helper Functions
    "detect_system_timezone",
]

##############
./fluxfce_core/sun.py

# ~/dev/fluxfce-simplified/fluxfce_core/sun.py

import logging
import math
from datetime import date, datetime, timedelta, timezone

# zoneinfo is standard library in Python 3.9+
try:
    from zoneinfo import ZoneInfo, ZoneInfoNotFoundError
except ImportError:
    # This is a critical dependency failure if zoneinfo is expected
    raise ImportError(
        "Required module 'zoneinfo' not found. FluxFCE requires Python 3.9+."
    )

# Import custom exceptions from within the same package
from .exceptions import CalculationError, ValidationError

log = logging.getLogger(__name__)


# --- Internal Sun Calculation Algorithm ---


def _noaa_sunrise_sunset(
    *, lat: float, lon: float, target_date: date
) -> tuple[float, float]:
    """
    Internal NOAA algorithm to calculate UTC sunrise/sunset times in minutes past midnight.

    Based on NOAA Javascript: www.esrl.noaa.gov/gmd/grad/solcalc/calcdetails.html

    Args:
        lat: Latitude in decimal degrees (-90 to 90).
        lon: Longitude in decimal degrees (-180 to 180).
        target_date: The specific date for calculation.

    Returns:
        A tuple (sunrise_utc_minutes, sunset_utc_minutes).

    Raises:
        CalculationError: If latitude/longitude are out of range, or for
                          polar day/night conditions where calculation fails.
    """
    log.debug(
        f"Calculating NOAA sun times for lat={lat}, lon={lon}, date={target_date}"
    )
    # Validate latitude/longitude ranges (redundant if called via get_sun_times which validates input strings, but good practice)
    if not (-90 <= lat <= 90):
        raise CalculationError(
            f"Invalid latitude for calculation: {lat}. Must be between -90 and 90."
        )
    if not (-180 <= lon <= 180):
        raise CalculationError(
            f"Invalid longitude for calculation: {lon}. Must be between -180 and 180."
        )

    n = target_date.timetuple().tm_yday  # Day of year
    longitude = lon  # Use validated input directly

    # Equation of Time and Declination (approximation)
    gamma = (2 * math.pi / 365) * (
        n - 1 + (12 - (longitude / 15)) / 24
    )  # Fractional year
    eqtime = 229.18 * (
        0.000075
        + 0.001868 * math.cos(gamma)
        - 0.032077 * math.sin(gamma)
        - 0.014615 * math.cos(2 * gamma)
        - 0.040849 * math.sin(2 * gamma)
    )
    decl = (
        0.006918
        - 0.399912 * math.cos(gamma)
        + 0.070257 * math.sin(gamma)
        - 0.006758 * math.cos(2 * gamma)
        + 0.000907 * math.sin(2 * gamma)
        - 0.002697 * math.cos(3 * gamma)
        + 0.00148 * math.sin(3 * gamma)
    )

    # Hour Angle Calculation
    lat_rad = math.radians(lat)
    # Zenith for sunrise/sunset (geometric center of sun) - 90.833 degrees
    # includes refraction and sun radius adjustment
    cos_zenith = math.cos(math.radians(90.833))
    try:
        # Argument for arccos to find hour angle
        cos_h_arg = (cos_zenith - math.sin(lat_rad) * math.sin(decl)) / (
            math.cos(lat_rad) * math.cos(decl)
        )
    except ZeroDivisionError:
        # This can happen near the poles if cos(decl) is near zero
        raise CalculationError(
            "Division by zero encountered during hour angle calculation (likely near poles)."
        )

    # Check for polar day/night conditions
    if cos_h_arg > 1.0:
        # Sun never rises (polar night)
        raise CalculationError(
            f"Sun never rises on {target_date} at lat {lat} (polar night)."
        )
    if cos_h_arg < -1.0:
        # Sun never sets (polar day)
        raise CalculationError(
            f"Sun never sets on {target_date} at lat {lat} (polar day)."
        )

    try:
        ha_rad = math.acos(cos_h_arg)  # Hour angle in radians
        ha_minutes = 4 * math.degrees(
            ha_rad
        )  # Convert hour angle to minutes (15 deg/hour * 4 min/deg)
    except ValueError as e:
        # Should not happen due to checks above, but safeguard
        raise CalculationError(f"Error calculating arccos for hour angle: {e}") from e

    # Solar noon (in minutes from UTC midnight)
    solar_noon_utc_min = 720 - 4 * longitude - eqtime  # 720 = 12 * 60

    sunrise_utc_min = solar_noon_utc_min - ha_minutes
    sunset_utc_min = solar_noon_utc_min + ha_minutes

    log.debug(
        f"Calculated UTC times (minutes from midnight): sunrise={sunrise_utc_min:.2f}, sunset={sunset_utc_min:.2f}"
    )
    return sunrise_utc_min, sunset_utc_min


# --- Public API for Sun Times ---


def get_sun_times(
    lat: float, lon: float, target_date: date, tz_name: str
) -> dict[str, datetime]:
    """
    Calculates sunrise and sunset times, returning them as timezone-aware datetimes.

    Args:
        lat: Latitude in decimal degrees (-90 to 90).
        lon: Longitude in decimal degrees (-180 to 180).
        target_date: The date for which to calculate times.
        tz_name: The IANA timezone name (e.g., 'America/Toronto').

    Returns:
        A dictionary {'sunrise': datetime_obj, 'sunset': datetime_obj} where
        datetime objects are timezone-aware for the specified tz_name.

    Raises:
        ValidationError: If the timezone name is invalid or not found by zoneinfo.
        CalculationError: If the underlying NOAA calculation fails (e.g., invalid
                          lat/lon passed internally, polar day/night).
    """
    log.debug(
        f"Getting sun times for lat={lat}, lon={lon}, date={target_date}, timezone={tz_name}"
    )
    try:
        tz_info = ZoneInfo(tz_name)
    except ZoneInfoNotFoundError:
        log.error(f"Invalid or unknown IANA Timezone Name: '{tz_name}'")
        raise ValidationError(f"Invalid or unknown IANA Timezone Name: '{tz_name}'")
    except Exception as e:  # Catch other potential zoneinfo errors
        log.error(f"Error loading timezone '{tz_name}': {e}")
        raise ValidationError(f"Error loading timezone '{tz_name}': {e}") from e

    try:
        # Call the internal algorithm
        sunrise_min, sunset_min = _noaa_sunrise_sunset(
            lat=lat, lon=lon, target_date=target_date
        )
    except CalculationError as e:
        # Propagate calculation errors (like polar day/night)
        log.error(f"Sun time calculation failed: {e}")
        raise  # Re-raise the specific CalculationError

    # Convert minutes from UTC midnight to datetime objects
    # Create a UTC midnight datetime for the target date
    utc_midnight = datetime(
        target_date.year, target_date.month, target_date.day, tzinfo=timezone.utc
    )

    # Add the calculated minutes to get the UTC event times
    sunrise_utc_dt = utc_midnight + timedelta(minutes=sunrise_min)
    sunset_utc_dt = utc_midnight + timedelta(minutes=sunset_min)

    # Convert to the target local timezone
    try:
        sunrise_local = sunrise_utc_dt.astimezone(tz_info)
        sunset_local = sunset_utc_dt.astimezone(tz_info)
    except Exception as e:
        # Handle potential errors during timezone conversion (less likely)
        log.exception(
            f"Failed to convert calculated UTC times to timezone '{tz_name}': {e}"
        )
        raise CalculationError(
            f"Failed timezone conversion for '{tz_name}': {e}"
        ) from e

    log.debug(
        f"Calculated local times: sunrise={sunrise_local.isoformat()}, sunset={sunset_local.isoformat()}"
    )
    return {"sunrise": sunrise_local, "sunset": sunset_local}

##############
./fluxfce_core/systemd.py

# ~/dev/fluxfce-simplified/fluxfce_core/systemd.py

import logging
import pathlib
import sys
from datetime import datetime # For type hinting in write_dynamic_event_timer_unit_file
from typing import Optional

# Import helpers and exceptions from within the same package
from . import helpers
from .exceptions import DependencyError, SystemdError

log = logging.getLogger(__name__)

# --- Constants ---
_APP_NAME = "fluxfce" # Application name, used in unit descriptions and names
SYSTEMD_USER_DIR = pathlib.Path.home() / ".config" / "systemd" / "user"

# --- Static Unit Names and File Paths ---
SCHEDULER_TIMER_NAME = f"{_APP_NAME}-scheduler.timer"
SCHEDULER_SERVICE_NAME = f"{_APP_NAME}-scheduler.service"
APPLY_TRANSITION_SERVICE_TEMPLATE_NAME = f"{_APP_NAME}-apply-transition@.service"
LOGIN_SERVICE_NAME = f"{_APP_NAME}-login.service"
RESUME_SERVICE_NAME = f"{_APP_NAME}-resume.service"
USER_SLEEP_TARGET_NAME = "sleep.target" # User-level anchor for sleep.target

SCHEDULER_TIMER_FILE = SYSTEMD_USER_DIR / SCHEDULER_TIMER_NAME
SCHEDULER_SERVICE_FILE = SYSTEMD_USER_DIR / SCHEDULER_SERVICE_NAME
APPLY_TRANSITION_SERVICE_TEMPLATE_FILE = SYSTEMD_USER_DIR / APPLY_TRANSITION_SERVICE_TEMPLATE_NAME
LOGIN_SERVICE_FILE = SYSTEMD_USER_DIR / LOGIN_SERVICE_NAME
RESUME_SERVICE_FILE = SYSTEMD_USER_DIR / RESUME_SERVICE_NAME
USER_SLEEP_TARGET_FILE = SYSTEMD_USER_DIR / USER_SLEEP_TARGET_NAME # Path for user-level sleep.target

# --- Dynamic Unit Names (filenames for timers generated at runtime) ---
SUNRISE_EVENT_TIMER_NAME = f"{_APP_NAME}-sunrise-event.timer"
SUNSET_EVENT_TIMER_NAME = f"{_APP_NAME}-sunset-event.timer"

# --- Lists for Management ---
STATIC_UNIT_FILES_MAP = {
    SCHEDULER_TIMER_NAME: SCHEDULER_TIMER_FILE,
    SCHEDULER_SERVICE_NAME: SCHEDULER_SERVICE_FILE,
    APPLY_TRANSITION_SERVICE_TEMPLATE_NAME: APPLY_TRANSITION_SERVICE_TEMPLATE_FILE,
    LOGIN_SERVICE_NAME: LOGIN_SERVICE_FILE,
    RESUME_SERVICE_NAME: RESUME_SERVICE_FILE,
    USER_SLEEP_TARGET_NAME: USER_SLEEP_TARGET_FILE, # Added user-level sleep.target
}

DYNAMIC_EVENT_TIMER_NAMES = [
    SUNRISE_EVENT_TIMER_NAME,
    SUNSET_EVENT_TIMER_NAME,
]

# ALL_POTENTIAL_FLUXFCE_UNIT_NAMES includes all units that fluxfce might create or manage,
# including the user-level sleep.target for cleanup with reset-failed.
ALL_POTENTIAL_FLUXFCE_UNIT_NAMES = [
    SCHEDULER_TIMER_NAME,
    SCHEDULER_SERVICE_NAME,
    f"{_APP_NAME}-apply-transition@day.service",
    f"{_APP_NAME}-apply-transition@night.service",
    LOGIN_SERVICE_NAME,
    RESUME_SERVICE_NAME,
    SUNRISE_EVENT_TIMER_NAME,
    SUNSET_EVENT_TIMER_NAME,
    USER_SLEEP_TARGET_NAME, # Added for reset-failed
]

# --- Unit File Templates ---

_SCHEDULER_TIMER_TEMPLATE = """\
[Unit]
Description={app_name}: Daily Timer to Reschedule Sunrise/Sunset Event Timers
PartOf=timers.target

[Timer]
Unit={scheduler_service_name}
OnCalendar=daily
RandomizedDelaySec=15min
Persistent=true
AccuracySec=1m

[Install]
WantedBy=timers.target
"""

_SCHEDULER_SERVICE_TEMPLATE = """\
[Unit]
Description={app_name}: Daily Service to Reschedule Sunrise/Sunset Event Timers
After=time-set.target

[Service]
Type=oneshot
ExecStart={python_executable} "{script_path}" schedule-dynamic-transitions
StandardOutput=journal
StandardError=journal
"""

_APPLY_TRANSITION_TEMPLATE = """\
[Unit]
Description={app_name}: Apply %I Mode Transition
PartOf=graphical-session.target
After=graphical-session.target xfce4-session.target
ConditionEnvironment=DISPLAY

[Service]
Type=oneshot
ExecStart={python_executable} "{script_path}" internal-apply --mode %i
StandardOutput=journal
StandardError=journal
"""

_LOGIN_SERVICE_TEMPLATE = """\
[Unit]
Description={app_name} - Apply theme on login
After=graphical-session.target plasma-workspace.target gnome-session.target
Requires=graphical-session.target
[Service]
Type=oneshot
ExecStartPre=/bin/sleep 20
ExecStart={python_executable} "{script_path}" run-login-check
StandardError=journal
[Install]
WantedBy=graphical-session.target
"""

_RESUME_SERVICE_TEMPLATE = """\
[Unit]
Description={app_name} - Apply theme after system resume
After=sleep.target graphical-session.target
Requires=graphical-session.target

[Service]
Type=oneshot
ExecStartPre=/bin/sleep 5
ExecStart={python_executable} "{script_path}" run-login-check
StandardError=journal

[Install]
WantedBy=sleep.target
"""

_USER_SLEEP_TARGET_TEMPLATE = """\
[Unit]
Description={app_name} User-Level Sleep Target Anchor
Documentation=man:systemd.special(7)
RefuseManualStart=yes
RefuseManualStop=yes
DefaultDependencies=no

[Install]
"""

_STATIC_UNIT_TEMPLATES = {
    SCHEDULER_TIMER_NAME: _SCHEDULER_TIMER_TEMPLATE,
    SCHEDULER_SERVICE_NAME: _SCHEDULER_SERVICE_TEMPLATE,
    APPLY_TRANSITION_SERVICE_TEMPLATE_NAME: _APPLY_TRANSITION_TEMPLATE,
    LOGIN_SERVICE_NAME: _LOGIN_SERVICE_TEMPLATE,
    RESUME_SERVICE_NAME: _RESUME_SERVICE_TEMPLATE,
    USER_SLEEP_TARGET_NAME: _USER_SLEEP_TARGET_TEMPLATE, # Added template for user sleep.target
}


class SystemdManager:
    """Handles creation, installation, and removal of systemd user units for fluxfce."""

    def __init__(self):
        """Check for systemctl dependency."""
        self.app_name = _APP_NAME
        try:
            helpers.check_dependencies(["systemctl"])
        except DependencyError as e:
            log.error(f"SystemdManager initialization failed: {e}")
            raise SystemdError(f"Cannot initialize SystemdManager: {e}") from e

    def _run_systemctl(
        self, args: list[str], check_errors: bool = True, capture_output: bool = False
    ) -> tuple[int, str, str]:
        """Runs a systemctl --user command."""
        cmd = ["systemctl", "--user", *args]
        try:
            # helpers.run_command captures output if capture_output is True.
            # It handles stripping stdout/stderr.
            code, stdout, stderr = helpers.run_command(cmd, check=False, capture=capture_output)
            if code != 0 and check_errors:
                # Log error only if check_errors is True and command failed.
                # stdout/stderr will be from the captured output if capture_output was True.
                # If not captured, they'll be empty strings from helpers.run_command.
                err_details = stderr.strip() if stderr else stdout.strip() # Prefer stderr for error details
                log.error(
                    f"systemctl --user {' '.join(args)} failed (code {code}). Details: '{err_details}'"
                )
            return code, stdout, stderr # stdout/stderr are already strings
        except FileNotFoundError:
            log.error(f"systemctl command not found when trying to run: systemctl --user {' '.join(args)}")
            raise DependencyError("systemctl command not found.")
        except Exception as e:
            log.exception(f"Unexpected error running systemctl command: systemctl --user {' '.join(args)}")
            raise SystemdError(
                f"Unexpected error running systemctl command 'systemctl --user {' '.join(args)}': {e}"
            ) from e

    def check_user_instance(self) -> bool:
        """
        Checks if the systemd user instance appears to be running and in a usable state.
        Raises SystemdError if the instance is not in a good state.
        """
        log.debug("Checking systemd user instance status...")
        code, stdout, stderr = self._run_systemctl(
            ["is-system-running"], check_errors=False, capture_output=True
        )
        
        status_output = stdout.strip().lower()

        if code == 0: # is-system-running returns 0 for "running", "degraded", etc.
            if status_output in ["running", "degraded"]: # "degraded" is often acceptable
                log.info(f"Systemd user instance reported: '{status_output}'.")
                return True
            else:
                # States like "stopping", "offline", "initializing", "starting" might be problematic
                error_msg = (
                    f"Systemd user instance is in state '{status_output}' (code {code}), "
                    f"which might not be fully usable. Stderr: '{stderr.strip()}'. "
                    f"{self.app_name} operations might be affected."
                )
                log.warning(error_msg) # Warn instead of raising error for ambiguous states
                return True # Allow proceeding but with a warning.
        else: # Non-zero usually means a more significant issue or "offline"
            error_msg = (
                f"Systemd user instance is not in a usable state "
                f"(command 'is-system-running' exit code: {code}, status: '{status_output}'). "
                f"Stderr: '{stderr.strip()}'. "
                f"{self.app_name} cannot proceed with systemd operations."
            )
            log.error(error_msg)
            raise SystemdError(error_msg)

    def install_units(
        self, script_path: str, python_executable: Optional[str] = None
    ) -> bool:
        """
        Creates and installs the static systemd user units for fluxfce.
        Enables the login, resume, and main scheduler timer services.
        """
        log.info(f"Installing static systemd user units for {self.app_name}...")
        self.check_user_instance()

        py_exe = python_executable or sys.executable
        script_abs_path = str(pathlib.Path(script_path).resolve())

        if not pathlib.Path(py_exe).is_file():
            raise FileNotFoundError(f"Python executable for systemd units not found: {py_exe}")
        if not pathlib.Path(script_abs_path).is_file():
            raise FileNotFoundError(f"Target script for systemd units not found: {script_abs_path}")

        try:
            SYSTEMD_USER_DIR.mkdir(parents=True, exist_ok=True)
            log.debug(f"Ensured systemd user directory exists: {SYSTEMD_USER_DIR}")
        except OSError as e:
            raise SystemdError(
                f"Failed to create systemd user directory {SYSTEMD_USER_DIR}: {e}"
            ) from e

        for unit_name, unit_file_path in STATIC_UNIT_FILES_MAP.items():
            template_content = _STATIC_UNIT_TEMPLATES.get(unit_name)
            if not template_content:
                log.error(f"Internal error: No template found for static unit {unit_name}, skipping.")
                continue
            
            # The user-level sleep.target template does not need these specific format args
            # but format will ignore extra keys.
            formatted_content = template_content.format(
                app_name=self.app_name,
                python_executable=py_exe,
                script_path=script_abs_path,
                scheduler_service_name=SCHEDULER_SERVICE_NAME,
            )
            try:
                unit_file_path.write_text(formatted_content, encoding="utf-8")
                log.info(f"Written systemd unit file: {unit_file_path}")
            except OSError as e:
                raise SystemdError(
                    f"Failed to write systemd unit file {unit_file_path}: {e}"
                ) from e

        reload_code, _, reload_err = self._run_systemctl(["daemon-reload"], capture_output=True)
        if reload_code != 0:
            raise SystemdError(f"systemctl daemon-reload failed: {reload_err.strip()}")
        log.debug("Systemd daemon-reload successful.")

        # Enable essential static units.
        # api.enable_scheduling() will handle --now for SCHEDULER_TIMER_NAME
        # and the setup of dynamic event timers.
        # The user-level sleep.target does not need to be "enabled" itself.
        services_to_enable_on_install = [
            LOGIN_SERVICE_NAME,
            RESUME_SERVICE_NAME,
            SCHEDULER_TIMER_NAME 
        ]
        for service_name in services_to_enable_on_install:
            enable_code, _, enable_err = self._run_systemctl(["enable", service_name], capture_output=True)
            if enable_code != 0:
                # For resume service and sleep.target, a specific warning about non-existent target
                # is now handled by creating the user-level sleep.target.
                # Other enable errors are still critical.
                error_msg = (
                    f"Failed to enable essential systemd unit '{service_name}' during installation. "
                    f"Stderr: '{enable_err.strip()}'. "
                    f"{self.app_name} may not function correctly."
                )
                log.error(error_msg)
                raise SystemdError(error_msg) 
            else:
                log.info(f"Enabled systemd unit: {service_name}")
        
        log.info(f"Static systemd units for {self.app_name} installed and essential services enabled successfully.")
        return True

    def remove_units(self) -> bool:
        """Stops, disables, and removes all static and dynamic fluxfce systemd user units."""
        log.info(f"Removing all {self.app_name} systemd user units...")
        
        units_to_stop_and_disable = [
            SCHEDULER_TIMER_NAME, SCHEDULER_SERVICE_NAME, # Scheduler components
            LOGIN_SERVICE_NAME, RESUME_SERVICE_NAME,      # Login/Resume hooks
            *DYNAMIC_EVENT_TIMER_NAMES,                   # Dynamic sunrise/sunset timers
            # Potentially running instances of the apply transition service
            f"{_APP_NAME}-apply-transition@day.service",
            f"{_APP_NAME}-apply-transition@night.service",
        ]
        
        # Stop units
        for unit_name in units_to_stop_and_disable:
             self._run_systemctl(["stop", unit_name], check_errors=False, capture_output=True)
        log.debug(f"Attempted to stop all potentially running {self.app_name} units/timers.")

        # Disable units that were explicitly enabled (static ones + scheduler timer)
        # Dynamic timers are not "enabled" in the same persistent way.
        # The user-level sleep.target isn't "enabled" either.
        units_to_disable_persistently = [
            SCHEDULER_TIMER_NAME,
            LOGIN_SERVICE_NAME,
            RESUME_SERVICE_NAME
        ]
        for unit_name in units_to_disable_persistently:
            self._run_systemctl(["disable", unit_name], check_errors=False, capture_output=True)
        log.debug(f"Attempted to disable static units: {', '.join(units_to_disable_persistently)}")

        # Remove all files defined in STATIC_UNIT_FILES_MAP (includes user_sleep_target)
        for unit_file_path in STATIC_UNIT_FILES_MAP.values():
            try:
                unit_file_path.unlink(missing_ok=True)
                log.debug(f"Removed unit file: {unit_file_path} (if it existed)")
            except OSError as e:
                log.warning(f"Error removing unit file {unit_file_path}: {e} (continuing)")

        # Remove dynamic timer files
        for dynamic_timer_name in DYNAMIC_EVENT_TIMER_NAMES:
            dynamic_file_path = SYSTEMD_USER_DIR / dynamic_timer_name
            try:
                dynamic_file_path.unlink(missing_ok=True)
                log.debug(f"Removed dynamic timer file: {dynamic_file_path} (if it existed)")
            except OSError as e:
                log.warning(f"Error removing dynamic timer file {dynamic_file_path}: {e} (continuing)")
        
        reload_code, _, reload_err = self._run_systemctl(["daemon-reload"], capture_output=True)
        if reload_code != 0:
            log.warning(f"systemctl daemon-reload failed during unit removal: {reload_err.strip()}. State might be inconsistent.")
        else:
            log.debug("Systemd daemon-reload successful after unit removal.")

        # Use ALL_POTENTIAL_FLUXFCE_UNIT_NAMES for reset-failed
        reset_code, _, reset_err = self._run_systemctl(["reset-failed", *ALL_POTENTIAL_FLUXFCE_UNIT_NAMES], check_errors=False, capture_output=True)
        if reset_code !=0:
            log.debug(f"reset-failed command for some units may have reported issues: {reset_err.strip()}")
        else:
            log.debug(f"Attempted reset-failed for all {self.app_name} units.")
        
        log.info(f"{self.app_name} systemd units removed.")
        return True

    def write_dynamic_event_timer_unit_file(
        self,
        mode: str, 
        utc_execution_time: datetime,
    ) -> bool:
        """
        Creates or overwrites a dynamic event timer file.
        The timer triggers an instance of APPLY_TRANSITION_SERVICE_TEMPLATE_NAME.
        `utc_execution_time` MUST be timezone-aware and set to UTC.
        """
        if mode not in ["day", "night"]:
            log.error(f"Invalid mode '{mode}' specified for dynamic event timer generation.")
            return False # Or raise error

        if utc_execution_time.tzinfo is None or utc_execution_time.tzinfo.utcoffset(utc_execution_time) is None:
            msg = f"utc_execution_time for dynamic timer ({mode}) must be UTC and timezone-aware."
            log.error(msg)
            raise ValueError(msg)

        timer_name = SUNRISE_EVENT_TIMER_NAME if mode == "day" else SUNSET_EVENT_TIMER_NAME
        timer_file_path = SYSTEMD_USER_DIR / timer_name
        
        service_instance_to_trigger = f"{_APP_NAME}-apply-transition@{mode}.service"
        # Systemd OnCalendar expects UTC if the timezone is specified as 'UTC'
        on_calendar_utc_str = utc_execution_time.strftime('%Y-%m-%d %H:%M:%S UTC')

        timer_content = f"""\
[Unit]
Description={self.app_name}: Event Timer for {mode.capitalize()} Transition (Dynamic)
# This timer requires the corresponding apply-transition@mode.service instance
Requires={service_instance_to_trigger}
# If the service it triggers is removed/fails, this timer might also be affected.
# PartOf can be used if desired, but Requires is explicit for the specific instance.

[Timer]
Unit={service_instance_to_trigger}
OnCalendar={on_calendar_utc_str}
Persistent=true  # So it runs if the machine was off at the scheduled time
AccuracySec=1s   # Timer accuracy
WakeSystem=false # Don't wake the system just for this timer

[Install]
# Dynamic timers are not typically "WantedBy" other targets directly.
# They are started/stopped by the application logic (e.g., via fluxfce-scheduler.service)
"""
        try:
            SYSTEMD_USER_DIR.mkdir(parents=True, exist_ok=True) # Ensure dir exists
            timer_file_path.write_text(timer_content, encoding="utf-8")
            log.info(f"Written dynamic timer file: {timer_file_path} for event at {on_calendar_utc_str}")
            return True
        except OSError as e:
            log.error(f"Failed to write dynamic timer file {timer_file_path}: {e}")
            raise SystemdError(f"Failed to write dynamic timer file {timer_file_path}: {e}") from e
        except ValueError as e: # Catch other errors like strftime issues if any
            log.error(f"Error preparing dynamic timer content for {mode}: {e}")
            raise
##############
./fluxfce_core/xfce.py

# ~/dev/fluxfce-simplified/fluxfce_core/xfce.py

import logging
import re
import subprocess
import time
from typing import Any, Optional

# Import helpers and exceptions from within the same package
from . import helpers
from .exceptions import DependencyError, ValidationError, XfceError

log = logging.getLogger(__name__)

# --- XFCE Constants ---
XFCONF_CHANNEL = "xfce4-desktop"
XFCONF_THEME_CHANNEL = "xsettings"
XFCONF_THEME_PROPERTY = "/Net/ThemeName"


class XfceHandler:
    """Handles interactions with XFCE settings via xfconf-query and xsct."""

    def __init__(self):
        """Check for essential dependencies."""
        # Check dependencies needed by most methods during instantiation
        try:
            helpers.check_dependencies(["xfconf-query", "xsct"])
            # xfdesktop is checked only when reload is called
        except DependencyError as e:
            # Make dependency issues during init fatal for this handler
            raise XfceError(f"Cannot initialize XfceHandler: {e}") from e

    def find_desktop_paths(self) -> list[str]:
        """
        Finds relevant XFCE desktop property base paths for background settings.

        These paths usually correspond to specific monitor/workspace combinations.

        Returns:
            A sorted list of base property paths (e.g., '/backdrop/screen0/monitorDP-1/workspace0').

        Raises:
            XfceError: If xfconf-query fails or no background paths can be found.
        """
        log.debug(f"Querying {XFCONF_CHANNEL} for background property paths...")
        cmd = ["xfconf-query", "-c", XFCONF_CHANNEL, "-l"]
        try:
            code, stdout, stderr = helpers.run_command(cmd)
            if code != 0:
                raise XfceError(
                    f"Failed to list xfconf properties in channel {XFCONF_CHANNEL}: {stderr} (code: {code})"
                )

            paths = set()
            # Prioritize monitor + workspace combo paths
            prop_pattern = re.compile(
                r"(/backdrop/screen\d+/[\w-]+/workspace\d+)/last-image$"
            )
            for line in stdout.splitlines():
                match = prop_pattern.match(line.strip())
                if match:
                    paths.add(match.group(1))

            # Fallback to monitor level only if no workspace paths found
            if not paths:
                log.debug(
                    "No workspace-specific paths found, checking monitor-level paths."
                )
                monitor_pattern = re.compile(
                    r"(/backdrop/screen\d+/[\w-]+)/last-image$"
                )
                for line in stdout.splitlines():
                    match = monitor_pattern.match(line.strip())
                    # Ensure it's not a parent of an already found workspace path
                    if match and match.group(1) not in [
                        p.rsplit("/", 1)[0] for p in paths if "/" in p
                    ]:
                        paths.add(match.group(1))

            if not paths:
                # Last resort default check (less reliable) - adapted from original
                default_path_guess = (
                    "/backdrop/screen0/monitorHDMI-0/workspace0"  # Example
                )
                cmd_check = [
                    "xfconf-query",
                    "-c",
                    XFCONF_CHANNEL,
                    "-p",
                    f"{default_path_guess}/last-image",
                ]
                code_check, _, _ = helpers.run_command(
                    cmd_check, capture=False
                )  # Don't capture, just check exit code
                if code_check == 0:
                    log.warning(
                        f"Could not detect specific paths, using default guess: {default_path_guess}"
                    )
                    paths.add(default_path_guess)
                else:
                    raise XfceError(
                        "Could not find any XFCE background property paths (checked workspace, monitor, and default guess)."
                    )

            sorted_paths = sorted(list(paths))
            log.info(
                f"Found {len(sorted_paths)} potential background paths: {sorted_paths}"
            )
            return sorted_paths

        except Exception as e:
            if isinstance(e, XfceError):
                raise  # Re-raise our specific errors
            log.exception(f"Error finding desktop paths: {e}")
            raise XfceError(
                f"An unexpected error occurred while finding desktop paths: {e}"
            ) from e

    def get_gtk_theme(self) -> str:
        """
        Gets the current GTK theme name using xfconf-query.

        Returns:
            The current GTK theme name.

        Raises:
            XfceError: If the xfconf-query command fails.
        """
        log.debug(
            f"Getting GTK theme from {XFCONF_THEME_CHANNEL} {XFCONF_THEME_PROPERTY}"
        )
        cmd = ["xfconf-query", "-c", XFCONF_THEME_CHANNEL, "-p", XFCONF_THEME_PROPERTY]
        try:
            code, stdout, stderr = helpers.run_command(cmd)
            if code != 0:
                raise XfceError(f"Failed to query GTK theme: {stderr} (code: {code})")
            if not stdout:
                raise XfceError(
                    "GTK theme query returned success code but empty output."
                )
            log.info(f"Current GTK theme: {stdout}")
            return stdout
        except Exception as e:
            if isinstance(e, XfceError):
                raise
            log.exception(f"Error getting GTK theme: {e}")
            raise XfceError(
                f"An unexpected error occurred while getting GTK theme: {e}"
            ) from e

    def set_gtk_theme(self, theme_name: str) -> bool:
        """
        Sets the GTK theme using xfconf-query.

        Args:
            theme_name: The name of the theme to set.

        Returns:
            True if the command executes successfully (code 0).

        Raises:
            XfceError: If the xfconf-query command fails (returns non-zero).
            ValidationError: If theme_name is empty.
        """
        if not theme_name:
            raise ValidationError("Theme name cannot be empty.")

        log.info(f"Setting GTK theme to: {theme_name}")
        cmd = [
            "xfconf-query",
            "-c",
            XFCONF_THEME_CHANNEL,
            "-p",
            XFCONF_THEME_PROPERTY,
            "-s",
            theme_name,
        ]
        try:
            code, _, stderr = helpers.run_command(cmd)
            if code != 0:
                raise XfceError(
                    f"Failed to set GTK theme to '{theme_name}': {stderr} (code: {code})"
                )
            log.debug(f"Successfully set GTK theme to '{theme_name}'")
            return True
        except Exception as e:
            if isinstance(e, (XfceError, ValidationError)):
                raise
            log.exception(f"Error setting GTK theme: {e}")
            raise XfceError(
                f"An unexpected error occurred while setting GTK theme: {e}"
            ) from e

    def get_background_settings(self) -> dict[str, Any]:
        """
        Gets background settings (style, colors) from the first detected path.

        Returns:
            A dictionary containing:
            {'hex1': str, 'hex2': str|None, 'dir': 's'|'h'|'v'}
            'hex2' is None for solid colors ('s').
            Returns None only if background is not set to 'Color' mode.

        Raises:
            XfceError: If paths cannot be found, essential properties cannot be read,
                       or parsing fails critically.
        """
        paths = self.find_desktop_paths()  # Raises XfceError if none found
        base_path = paths[0]  # Use the first path for consistency
        log.debug(f"Getting background settings from primary path: {base_path}")

        settings = {"hex1": None, "hex2": None, "dir": None}

        def _get_xfconf_prop(prop_name: str) -> Optional[str]:
            """Internal helper to get a single string property value."""
            prop_path = f"{base_path}/{prop_name}"
            cmd = ["xfconf-query", "-c", XFCONF_CHANNEL, "-p", prop_path]
            try:
                code, stdout, stderr = helpers.run_command(cmd)
                if code != 0:
                    # Don't raise if property simply doesn't exist, just return None
                    if "does not exist" in stderr.lower():
                        log.debug(f"Property {prop_path} does not exist.")
                        return None
                    raise XfceError(
                        f"xfconf-query failed for '{prop_path}': {stderr} (code: {code})"
                    )
                return stdout.strip()
            except Exception as e:
                if isinstance(e, XfceError):
                    raise
                log.exception(f"Unexpected error getting property {prop_path}: {e}")
                raise XfceError(
                    f"Unexpected error getting property {prop_path}: {e}"
                ) from e

        def _parse_rgba_output(prop_name: str) -> Optional[list[float]]:
            """Parses multi-line xfconf-query output for rgba arrays."""
            prop_path = f"{base_path}/{prop_name}"
            cmd = ["xfconf-query", "-c", XFCONF_CHANNEL, "-p", prop_path]
            code, stdout, stderr = helpers.run_command(cmd)
            if code != 0:
                if "does not exist" in stderr.lower():
                    log.warning(f"RGBA property {prop_path} does not exist.")
                    return None
                log.warning(
                    f"Could not query {prop_name} from {base_path}: {stderr} (code: {code})"
                )
                return None  # Non-critical if rgba isn't set, maybe

            float_values = []
            # Match lines containing only a float/int number (more robust)
            num_pattern = re.compile(r"^\s*(-?\d+(\.\d+)?)\s*$")
            for line in stdout.splitlines():
                match = num_pattern.match(line)
                if match:
                    try:
                        float_values.append(float(match.group(1)))
                    except ValueError:  # Should not happen with regex
                        continue
            if len(float_values) == 4:
                log.debug(f"Parsed {prop_name} values: {float_values}")
                return float_values
            else:
                log.warning(
                    f"Could not parse 4 float values from {prop_name} output ({len(float_values)} found). Output:\n{stdout}"
                )
                return None

        def _floats_to_hex(rgba_floats: Optional[list[float]]) -> Optional[str]:
            """Converts list of [r,g,b,a] floats (0.0-1.0) to 6-digit Hex."""
            if not rgba_floats or len(rgba_floats) != 4:
                return None
            try:
                r = int(rgba_floats[0] * 255 + 0.5)
                g = int(rgba_floats[1] * 255 + 0.5)
                b = int(rgba_floats[2] * 255 + 0.5)
                # Clamp values to 0-255 range
                r = max(0, min(255, r))
                g = max(0, min(255, g))
                b = max(0, min(255, b))
                hex_str = f"{r:02X}{g:02X}{b:02X}"
                log.debug(f"Converted floats {rgba_floats} to hex '{hex_str}'")
                return hex_str
            except (ValueError, TypeError, IndexError) as e:
                log.error(f"Error converting float list {rgba_floats} to hex: {e}")
                return None  # Conversion error

        # --- Main Logic ---
        try:
            image_style = _get_xfconf_prop("image-style")
            color_style = _get_xfconf_prop("color-style")

            # Check if background is set to 'Color' mode (image-style = 1)
            if image_style != "1":
                log.info(
                    f"Background image-style is not 'Color' (value: {image_style}). Cannot get color settings."
                )
                # Return an empty dict or specific indicator? Let's raise.
                raise XfceError(
                    f"Background mode is not 'Color' (image-style={image_style})."
                )

            if color_style is None:
                raise XfceError(
                    f"Could not retrieve essential 'color-style' property from {base_path}."
                )

            # Get RGBA1 and convert to Hex1
            rgba1_floats = _parse_rgba_output("rgba1")
            settings["hex1"] = _floats_to_hex(rgba1_floats)
            if not settings["hex1"]:
                raise XfceError(
                    "Failed to parse or convert primary background color (rgba1)."
                )

            # Determine direction and get secondary color if needed
            if color_style == "0":  # Solid
                settings["dir"] = "s"
                settings["hex2"] = None  # Explicitly None
            elif color_style in ("1", "2"):  # Horizontal or Vertical gradient
                settings["dir"] = "h" if color_style == "1" else "v"
                rgba2_floats = _parse_rgba_output("rgba2")
                settings["hex2"] = _floats_to_hex(rgba2_floats)
                if not settings["hex2"]:
                    # Don't fail if secondary fails, just log and set hex2 to None
                    log.warning(
                        "Failed to parse or convert secondary gradient color (rgba2). Treating as solid."
                    )
                    settings["hex2"] = (
                        None  # Fallback, might mismatch 'dir' but safer than error
                    )
                    # Or should we try to make hex2 = hex1? Maybe just None is better.
            else:
                raise XfceError(f"Unknown background color-style found: {color_style}")

            log.info(
                f"Retrieved background: Dir={settings['dir']}, Hex1={settings['hex1']}, Hex2={settings.get('hex2', 'N/A')}"
            )
            return settings

        except Exception as e:
            if isinstance(e, XfceError):
                raise
            log.exception(f"Error getting background settings: {e}")
            raise XfceError(
                f"An unexpected error occurred getting background settings: {e}"
            ) from e

    def set_background(self, hex1: str, hex2: Optional[str], direction: str) -> bool:
        log.info(f"Setting background: Dir={direction}, Hex1={hex1}, Hex2={hex2}")
        # find_desktop_paths() should return a list of paths to try.
        # If single-workspace-mode is true, it should ideally prioritize the per-monitor path
        # of the active primary display. This might require find_desktop_paths() to be smarter.
        # For now, let's assume find_desktop_paths() returns the paths bg-setter.sh would act on.
        paths = self.find_desktop_paths()
        if not paths:
            # This was already there, find_desktop_paths raises XfceError if none found
            # but good to have a check.
            raise XfceError("No desktop paths found by find_desktop_paths to apply background settings.")

        try:
            rgba1_list = helpers.hex_to_rgba_doubles(hex1)
        except ValidationError as e:
            raise ValidationError(f"Invalid format for hex1 '{hex1}': {e}") from e

        rgba2_list = None
        if direction in ("h", "v"):
            if not hex2:
                raise ValidationError("Gradient direction specified but hex2 is missing.")
            try:
                rgba2_list = helpers.hex_to_rgba_doubles(hex2)
            except ValidationError as e:
                raise ValidationError(f"Invalid format for hex2 '{hex2}': {e}") from e
        elif direction == "s":
            if hex2 is not None:
                log.warning(f"Ignoring hex2='{hex2}' because direction='s' (solid) was specified.")
        else:
            raise ValidationError(f"Invalid background direction: '{direction}'. Must be 's', 'h', or 'v'.")

        image_style_val = "1"  # Color mode
        color_style_val = "0"  # Solid
        if direction == "h":
            color_style_val = "1"
        elif direction == "v":
            color_style_val = "2"

        overall_success = True
        for base_path in paths:
            log.debug(f"Applying background settings to XFCE path: {base_path}")
            path_applied_successfully = True

            # Commands to execute for this path
            cmds_for_path = []

            # 0. (Optional but good practice) Clear image-path
            cmds_for_path.append(
                ["xfconf-query", "-c", XFCONF_CHANNEL, "-p", f"{base_path}/image-path", "-n", "-t", "string", "-s", ""]
            )

            # 1. Set image-style
            cmds_for_path.append(
                ["xfconf-query", "-c", XFCONF_CHANNEL, "-p", f"{base_path}/image-style", "-n", "-t", "int", "-s", image_style_val]
            )
            # 2. Set color-style
            cmds_for_path.append(
                ["xfconf-query", "-c", XFCONF_CHANNEL, "-p", f"{base_path}/color-style", "-n", "-t", "int", "-s", color_style_val]
            )

            # 3. Reset and set rgba1
            cmds_for_path.append(["xfconf-query", "-c", XFCONF_CHANNEL, "-p", f"{base_path}/rgba1", "-r"]) # RESET
            cmd_rgba1_set = ["xfconf-query", "-c", XFCONF_CHANNEL, "-p", f"{base_path}/rgba1", "-n"] # Use -n to create if -r made it not exist
            for val_component in rgba1_list:
                cmd_rgba1_set.extend(["-t", "double", "-s", f"{val_component:.6f}"])
            cmds_for_path.append(cmd_rgba1_set)

            # 4. Reset and set/clear rgba2
            cmds_for_path.append(["xfconf-query", "-c", XFCONF_CHANNEL, "-p", f"{base_path}/rgba2", "-r"]) # RESET
            if rgba2_list: # If gradient, set new rgba2
                cmd_rgba2_set = ["xfconf-query", "-c", XFCONF_CHANNEL, "-p", f"{base_path}/rgba2", "-n"]
                for val_component in rgba2_list:
                    cmd_rgba2_set.extend(["-t", "double", "-s", f"{val_component:.6f}"])
                cmds_for_path.append(cmd_rgba2_set)
            # If not gradient (solid), rgba2 remains reset (deleted).

            # 5. Set last-image
            cmds_for_path.append(
                ["xfconf-query", "-c", XFCONF_CHANNEL, "-p", f"{base_path}/last-image", "-n", "-t", "string", "-s", ""]
            )

            # Execute all commands for this path
            for cmd in cmds_for_path:
                # Allow reset commands to "fail" if property doesn't exist, don't check errors for -r
                check_cmd_errors = not ("-r" in cmd)
                
                # For setting commands, use --create like bg-setter.sh implies for robustness if -n isn't enough
                # However, the current fluxfce structure uses -n with -t type -s val... which is also valid for creation.
                # The key was the reset. Let's stick to current -n for creation after reset.
                # If issues persist, one could change -n to --create and adjust cmd construction.

                code, stdout, stderr = helpers.run_command(cmd, check=False) # check=False, handle manually
                
                if code != 0:
                    # If a reset command fails because property doesn't exist, that's okay.
                    if "-r" in cmd and ("property" in stderr.lower() and "does not exist" in stderr.lower()):
                        log.debug(f"Property {cmd[4]} did not exist for reset (ignoring): {stderr}")
                    else:
                        log.error(f"Failed command for {base_path}: {' '.join(cmd)} - Code: {code}, Stderr: {stderr}")
                        path_applied_successfully = False
                        overall_success = False
                        break # Stop processing commands for this failed path

            if not path_applied_successfully:
                log.warning(f"Settings failed to apply completely for path: {base_path}")

        # Reload desktop once after trying all paths
        self.reload_xfdesktop()

        if not overall_success:
            raise XfceError("Background settings failed for one or more properties/paths. Check logs.")

        log.info("Background settings applied attempt completed for all detected paths.")
        return overall_success   

    def get_screen_settings(self) -> dict[str, Any]:
        """
        Gets screen temperature and brightness via xsct. Attempts different parsing
        strategies based on common xsct output formats.

        Returns:
            A dictionary {'temperature': int|None, 'brightness': float|None}.
            Returns None for values if xsct is off, fails to report, or output
            cannot be parsed.

        Raises:
            XfceError: If the xsct command fails unexpectedly.
        """
        log.debug("Getting screen settings via xsct")
        cmd = ["xsct"]
        try:
            code, stdout, stderr = helpers.run_command(cmd)

            if code != 0:
                # Check if stderr indicates expected "off" states or usage errors
                if (
                    "unknown" in stderr.lower()
                    or "usage:" in stderr.lower()
                    or "failed" in stderr.lower()
                ):
                    log.info(
                        "xsct appears off or failed to query. Assuming default screen settings."
                    )
                    return {"temperature": None, "brightness": None}
                else:
                    # Unexpected error from xsct
                    raise XfceError(
                        f"xsct command failed unexpectedly (code {code}): {stderr}"
                    )

            temp = None
            brightness = None

            # --- Strategy 1: Combined Regex (Handles 'temp ~ TTTT B.BB') ---
            # Match pattern like: Screen #: temperature ~ <temp_digits> <brightness_float>
            combined_match = re.search(
                r"temperature\s+~\s+(\d+)\s+([\d.]+)", stdout, re.IGNORECASE
            )
            if combined_match:
                log.debug("xsct output matched combined regex pattern.")
                try:
                    temp = int(combined_match.group(1))
                    brightness = float(combined_match.group(2))
                    log.info(
                        f"Retrieved screen settings (combined): Temp={temp}, Brightness={brightness:.2f}"
                    )
                    return {"temperature": temp, "brightness": brightness}
                except (ValueError, IndexError) as e:
                    log.warning(
                        f"Could not parse values from combined xsct regex match: {e}. Output: '{stdout}'"
                    )
                    # Fall through to Strategy 2 if parsing combined match failed

            # --- Strategy 2: Separate Regexes (Handles 'Temp: TTTTK\nBright: B.BB') ---
            if temp is None or brightness is None:  # Only proceed if Strategy 1 failed
                log.debug(
                    "Combined regex failed or produced invalid values, trying separate regexes."
                )
                temp_match = re.search(
                    r"(?:temperature|temp)\s*[:~]?\s*(\d+)K?", stdout, re.IGNORECASE
                )
                bright_match = re.search(
                    r"(?:brightness|bright)\s*[:~]?\s*([\d.]+)", stdout, re.IGNORECASE
                )

                if temp_match:
                    try:
                        temp = int(temp_match.group(1))
                    except (ValueError, IndexError):
                        log.warning(
                            f"Could not parse temperature from separate xsct regex match: '{stdout}'"
                        )
                else:
                    log.warning(
                        f"Could not find temperature pattern using separate regex: '{stdout}'"
                    )

                if bright_match:
                    try:
                        brightness = float(bright_match.group(1))
                    except (ValueError, IndexError):
                        log.warning(
                            f"Could not parse brightness from separate xsct regex match: '{stdout}'"
                        )
                else:
                    # This is the warning you were seeing previously
                    log.warning(
                        f"Could not find brightness pattern using separate regex: '{stdout}'"
                    )

                # Return values only if *both* were successfully parsed separately
                if temp is not None and brightness is not None:
                    log.info(
                        f"Retrieved screen settings (separate): Temp={temp}, Brightness={brightness:.2f}"
                    )
                    return {"temperature": temp, "brightness": brightness}

            # --- Fallback: Parsing failed ---
            log.info(
                f"Could not parse both temp/brightness from xsct output using known patterns. Assuming default. Output: '{stdout}'"
            )
            return {"temperature": None, "brightness": None}

        except XfceError:
            raise  # Re-raise specific XfceErrors
        except Exception as e:
            log.exception(f"Error getting screen settings: {e}")
            raise XfceError(
                f"An unexpected error occurred getting screen settings: {e}"
            ) from e

    def set_screen_temp(self, temp: Optional[int], brightness: Optional[float]) -> bool:
        """
        Sets screen temperature/brightness using xsct.

        Args:
            temp: Temperature in Kelvin (e.g., 4500), or None to reset.
            brightness: Brightness (e.g., 0.85), or None to reset.
                        If one is None, both are treated as None for reset.

        Returns:
            True if the command executes successfully.

        Raises:
            XfceError: If the xsct command fails.
            ValidationError: If temp/brightness values are unreasonable (basic check).
        """
        if temp is not None and brightness is not None:
            # Basic sanity checks
            if not (1000 <= temp <= 10000):
                # Raise validation error for clearly bad values
                raise ValidationError(
                    f"Temperature value {temp}K is outside the typical range (1000-10000)."
                )
            if not (0.1 <= brightness <= 2.0):
                # Warn for brightness as it's sometimes allowed outside 0-1
                log.warning(
                    f"Brightness value {brightness} is outside the typical range (0.1-2.0)."
                )
                # raise ValidationError(f"Brightness value {brightness} is outside the typical range (0.1-2.0).")

            log.info(f"Setting screen: Temp={temp}, Brightness={brightness:.2f}")
            cmd = ["xsct", str(temp), f"{brightness:.2f}"]
        else:
            log.info("Resetting screen temperature/brightness (xsct -x)")
            cmd = ["xsct", "-x"]

        try:
            code, _, stderr = helpers.run_command(cmd)
            if code != 0:
                raise XfceError(
                    f"Failed to set screen temperature/brightness via xsct: {stderr} (code: {code})"
                )
            log.debug("Successfully set screen temperature/brightness.")
            return True
        except Exception as e:
            if isinstance(e, (XfceError, ValidationError)):
                raise
            log.exception(f"Error setting screen temperature/brightness: {e}")
            raise XfceError(
                f"An unexpected error occurred setting screen temperature/brightness: {e}"
            ) from e

    def reload_xfdesktop(self):
        """Reloads the xfdesktop process to apply potential background changes."""
        log.debug("Reloading xfdesktop...")
        cmd = ["xfdesktop", "--reload"]
        try:
            # Check if command exists first
            helpers.check_dependencies(["xfdesktop"])
            # Run in background, don't wait, ignore output/errors as it's best-effort
            subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            time.sleep(0.5)  # Brief pause allow process to start
            log.debug("xfdesktop --reload command issued.")
        except DependencyError:
            log.warning("xfdesktop command not found, skipping reload.")
        except Exception as e:
            log.warning(f"Exception trying to reload xfdesktop: {e}")
##############
./fluxfce_deps_check.py

#!/usr/bin/env python3

import os
import shutil
import subprocess
import sys
from typing import Optional

MIN_PYTHON_VERSION = (3, 9)

# Updated list of command-line dependencies to check
DEPS_TO_CHECK = {
    # command_name: (package_name_suggestion_for_apt, friendly_name)
    "xfconf-query": ("xfce4-utils", "XFCE Configuration tool ('xfconf-query')"),
    "systemctl": ("systemd", "Systemd control tool ('systemctl')"),
    "timedatectl": ("systemd", "Systemd time/date tool ('timedatectl')"),
    "xfdesktop": ("xfdesktop4", "XFCE Desktop manager ('xfdesktop')"),
    "xsct": ("xsct", "Screen Color Temperature tool ('xsct')"),
}

# Fallback package suggestion if xfce4-utils isn't found directly (e.g., part of a meta-package)
XFCE4_UTILS_FALLBACK = "xfce4-session"


# --- Helper Functions ---

def print_info(message: str):
    print(f"[INFO] {message}")

def print_warning(message: str):
    print(f"[WARN] {message}")

def print_error(message: str):
    print(f"[ERROR] {message}")

def print_success(message: str):
    print(f"[OK]   {message}") # Added more space for alignment

def run_command(
    command: list[str], check_exit_code: bool = True, capture_output: bool = False
) -> tuple[int, Optional[str], Optional[str]]:
    """Runs a system command."""
    try:
        process = subprocess.run(
            command,
            check=check_exit_code and not capture_output, # Let CalledProcessError raise if not capturing
            capture_output=capture_output,
            text=True,
            env=os.environ.copy(),
        )
        stdout = process.stdout.strip() if process.stdout else None
        stderr = process.stderr.strip() if process.stderr else None
        
        if capture_output and check_exit_code and process.returncode != 0:
            # Manually raise for captured output if check_exit_code is True and run failed
            raise subprocess.CalledProcessError(
                process.returncode, command, output=stdout, stderr=stderr
            )
        return process.returncode, stdout, stderr
    except FileNotFoundError:
        # This specific error is often critical for expected commands
        print_error(f"Command not found: {command[0]}. Please ensure it is installed and in your PATH.")
        return -1, None, None # Indicate command not found
    except subprocess.CalledProcessError as e:
        stderr_msg = f": {e.stderr}" if e.stderr and e.stderr.strip() else ""
        print_error(
            f"Command '{' '.join(e.cmd)}' failed with exit code {e.returncode}{stderr_msg}"
        )
        return e.returncode, e.stdout, e.stderr
    except Exception as e:
        print_error(
            f"An unexpected error occurred running command '{' '.join(command)}': {e}"
        )
        return -2, None, None # Indicate other unexpected error

def ask_yes_no(prompt: str, default_yes: bool = False) -> bool:
    """Asks a yes/no question and returns True for yes, False for no."""
    suffix = "[Y/n]" if default_yes else "[y/N]"
    while True:
        try:
            response = input(f"{prompt} {suffix}: ").strip().lower()
            if not response:
                return default_yes
            if response in ["y", "yes"]:
                return True
            if response in ["n", "no"]:
                return False
            print_warning("Invalid input. Please enter 'y' or 'n'.")
        except EOFError:
            print()
            return default_yes
        except KeyboardInterrupt:
            print("\nPrompt interrupted. Assuming 'no'.")
            return False

# --- Check Functions ---

def check_python_version() -> bool:
    """Checks if the current Python version meets the minimum requirement."""
    print_info(f"Checking Python version (minimum {MIN_PYTHON_VERSION[0]}.{MIN_PYTHON_VERSION[1]})...")
    if sys.version_info >= MIN_PYTHON_VERSION:
        print_success(f"Python version {sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro} is sufficient.")
        return True
    else:
        print_error(
            f"Python version is {sys.version_info.major}.{sys.version_info.minor}. "
            f"FluxFCE requires Python {MIN_PYTHON_VERSION[0]}.{MIN_PYTHON_VERSION[1]} or newer."
        )
        return False

def check_command_installed(cmd_name: str, friendly_name: str) -> bool:
    """Checks if a command is installed and executable using shutil.which."""
    print_info(f"Checking for {friendly_name} ('{cmd_name}')...")
    path = shutil.which(cmd_name)
    if path:
        print_success(f"{friendly_name} found at: {path}")
        return True
    else:
        print_warning(f"{friendly_name} ('{cmd_name}') NOT found in PATH.")
        return False

# --- Installation Functions ---

def print_manual_xsct_instructions():
    """Prints manual installation instructions for xsct."""
    print_warning("-" * 60)
    print_warning("Manual Installation for 'xsct' might be required.")
    print_warning("If 'sudo apt install xsct' failed or was skipped, you might need to build it from source:")
    print_info("  1. Install build dependencies (example for Debian/Ubuntu):")
    print_info("     sudo apt update")
    print_info("     sudo apt install build-essential libx11-dev libxrandr-dev git")
    print_info("  2. Clone the xsct repository:")
    print_info("     git clone https://github.com/faf0/xsct.git")
    print_info("  3. Compile and install:")
    print_info("     cd xsct")
    print_info("     sudo make install  # Installs to /usr/local/bin by default")
    print_info("     # OR, for user-local install (ensure ~/.local/bin is in PATH):")
    print_info("     # mkdir -p ~/.local/bin && make PREFIX=~/.local install")
    print_warning("-" * 60)

def install_package(
    pkg_name_suggestion: str, cmd_name_being_checked: str, friendly_name: str
) -> bool:
    """
    Attempts to install a package using apt.
    Handles xsct special case for manual instructions.
    Handles xfce4-utils fallback.
    """
    install_prompt = (
        f"Attempt to install '{friendly_name}' (package suggestion: {pkg_name_suggestion}) "
        f"using 'sudo apt install {pkg_name_suggestion}'?"
    )
    if not ask_yes_no(install_prompt, default_yes=True): # Default to yes for convenience
        print_info(f"Skipping installation of {friendly_name}.")
        if cmd_name_being_checked == "xsct":
            print_manual_xsct_instructions()
        return False

    print_info(f"Attempting to install {pkg_name_suggestion}...")
    
    # Offer to run apt update first
    if ask_yes_no("Run 'sudo apt update' first to refresh package lists?", default_yes=True):
        print_info("Running 'sudo apt update'...")
        ret_update, _, _ = run_command(["sudo", "apt", "update"])
        if ret_update != 0:
            print_warning("Failed to run 'sudo apt update'. Package lists may be outdated. Continuing install attempt...")
    else:
        print_info("Skipping 'apt update'.")

    ret_install, _, _ = run_command(["sudo", "apt", "install", "-y", pkg_name_suggestion])
    
    if ret_install == 0:
        print_success(f"Successfully installed package '{pkg_name_suggestion}' for {friendly_name}.")
        # Verify the command is now available
        if shutil.which(cmd_name_being_checked):
            print_success(f"Command '{cmd_name_being_checked}' is now available.")
            return True
        else:
            print_warning(f"Package '{pkg_name_suggestion}' installed, but command '{cmd_name_being_checked}' still not found. This is unexpected.")
            return False # Command still not found
    else:
        print_error(f"Failed to install package '{pkg_name_suggestion}' for {friendly_name}.")
        if cmd_name_being_checked == "xsct":
            print_info("The package 'xsct' might not be available in your system's default repositories or installation failed.")
            print_manual_xsct_instructions()
        elif cmd_name_being_checked == "xfconf-query" and pkg_name_suggestion == "xfce4-utils":
            print_info(f"Trying fallback package '{XFCE4_UTILS_FALLBACK}' for XFCE utilities.")
            # Recursive call for the fallback package.
            return install_package(XFCE4_UTILS_FALLBACK, cmd_name_being_checked, friendly_name)
        return False

# --- Main Logic ---
def main():
    print_info("FluxFCE Dependency Checker for Debian/Ubuntu-based systems")
    print_info("(Focuses on command-line tools needed by FluxFCE core)")
    print_info("=" * 60)

    if not shutil.which("apt"):
        print_warning("This script's package installation suggestions use 'apt'.")
        print_warning("If you are on a non-APT system, you'll need to install dependencies manually.")
        # Continue with checks, but installation attempts might not be relevant.

    if os.geteuid() == 0:
        print_warning(
            "This script is not designed to be run as root, though it will invoke 'sudo' "
            "for package installations if you permit."
        )
        if not ask_yes_no("Continue anyway?", default_yes=False):
            sys.exit(1)

    all_deps_ok_initially = True
    missing_commands_to_resolve: dict[str, tuple[str, str]] = {} # cmd_name: (pkg_suggestion, friendly_name)

    # 1. Check Python Version
    if not check_python_version():
        all_deps_ok_initially = False
        # This is a critical failure for FluxFCE itself.
        print_error("Please upgrade Python before proceeding with FluxFCE installation.")
        # Exiting early if Python version is insufficient, as fluxfce_cli.py won't run.
        # sys.exit(1) # Or choose to report all other missing deps first. Let's report all.

    # 2. Check Commands
    print_info("\n--- Checking for required command-line tools ---")
    for cmd, (pkg_suggestion, friendly) in DEPS_TO_CHECK.items():
        if not check_command_installed(cmd, friendly):
            all_deps_ok_initially = False
            if cmd not in missing_commands_to_resolve: # Avoid duplicates if somehow listed twice
                missing_commands_to_resolve[cmd] = (pkg_suggestion, friendly)
    
    print_info("-" * 60)
    if all_deps_ok_initially:
        print_success("All checked dependencies appear to be OK!")
        print_info("Note: Core system utilities (like 'python3', 'mkdir', 'ln') are assumed to be present.")
        sys.exit(0)
    else:
        print_warning("Some dependencies require attention.")

    # 3. Attempt to Install Missing Items
    if missing_commands_to_resolve:
        print_info("\n--- Attempting to resolve missing dependencies ---")
        # Prioritize xsct for special handling/messaging if apt install fails
        if "xsct" in missing_commands_to_resolve:
            pkg_sugg, friendly_name = missing_commands_to_resolve.pop("xsct")
            install_package(pkg_sugg, "xsct", friendly_name)
            # Re-check xsct specifically, as its installation can be manual
            if check_command_installed("xsct", DEPS_TO_CHECK["xsct"][1]):
                 print_success("'xsct' is now available.")
            else:
                 print_warning("'xsct' still appears to be unavailable after installation attempt.")
                 # Manual instructions were already printed by install_package on failure.

        # Attempt to install other missing packages
        for cmd_name, (pkg_sugg, friendly_name) in missing_commands_to_resolve.items():
            # Check again in case a previous install provided this command (e.g., meta-package)
            if not shutil.which(cmd_name):
                install_package(pkg_sugg, cmd_name, friendly_name)
    else:
        print_info("No missing command-line tools to attempt to install (or user skipped previous prompts).")

    print_info("-" * 60)
    # Final verification
    print_info("Re-verifying all dependencies after installation attempts...")
    final_all_ok = True
    if not check_python_version(): # Re-check Python version
        final_all_ok = False

    for cmd, (_, friendly) in DEPS_TO_CHECK.items():
        if not check_command_installed(cmd, friendly):
            final_all_ok = False
            if cmd == "xsct":
                print_warning(f"'{cmd}' ({friendly}) is still missing. Manual installation might be required (see instructions above if printed).")
            else:
                print_warning(f"'{cmd}' ({friendly}) is still missing. Please install it manually.")


    print_info("-" * 60)
    if final_all_ok:
        print_success("All critical dependencies appear to be satisfied now!")
        sys.exit(0)
    else:
        print_error("One or more critical dependencies are still missing after installation attempts.")
        print_error("Please review the output above and install them manually.")
        sys.exit(1)

if __name__ == "__main__":
    main()
##############
./fluxfce_gui.py


##############
./hand-over-prompt.md

**Project Handover: fluxfce-simplified v0.1**

**Context:**
You are taking over development for `fluxfce-simplified` (v0.1), a Python CLI tool designed to automatically switch the XFCE desktop appearance (GTK theme, background color/gradient, screen temperature/brightness via `xsct`) based on calculated local sunrise and sunset times.

**Your Role & Required Skills:**
You are a software engineer and Linux system administrator. You possess deep knowledge of:
*   Python (3.9+)
*   Linux Command-Line Tools: `xfconf-query`, `xsct`, **`systemctl`**, `journalctl`, `timedatectl`, `git`, `make`, standard shell utilities.
*   XFCE Desktop Environment: Configuration concepts (`xfconf`), theming.
*   Systemd: User sessions, `.service` and `.timer` units, targets (esp. `sleep.target`, `graphical-session.target`), `journalctl`.
*   Software Architecture: Separation of concerns, API design.
*   Debugging Techniques: Analyzing logs, tracebacks, system states.

**Codebase:**
*   The codebase for `fluxfce-simplified` v0.1 is included as `codebase.txt` accompanying this prompt.

**Tasks:**
*   Analyze and review the codebase, ensuring you have a thorough understanding of the intended functionality of fluxfce-simplified.
*   **Focus on code related to installation (ie `fluxfce install`), and the setup and creation systemd units. Assist with debugging and resoloving the following:**

```
~  fluxfce install
...
--- Step 3: Installing systemd units ---
Created symlink /home/cad/.config/systemd/user/graphical-session.target.wants/fluxfce-login.service  /home/cad/.config/systemd/user/fluxfce-login.service.
Created symlink /home/cad/.config/systemd/user/suspend.target.wants/fluxfce-resume.service  /home/cad/.config/systemd/user/fluxfce-resume.service.
Unit /home/cad/.config/systemd/user/fluxfce-resume.service is added as a dependency to a non-existent unit suspend.target. # note this issue
Created symlink /home/cad/.config/systemd/user/timers.target.wants/fluxfce-scheduler.timer  /home/cad/.config/systemd/user/fluxfce-scheduler.timer.
Static systemd units installed.

--- Step 4: Enabling automatic scheduling ---
Failed to stop fluxfce-sunrise-event.timer: Unit fluxfce-sunrise-event.timer not loaded. # note this line
Failed to stop fluxfce-sunset-event.timer: Unit fluxfce-sunset-event.timer not loaded. # note this line
Automatic theme scheduling enabled via systemd timers.
```

**Note:**
*   It may be necessary to do research to determine the correct approach to craeting the dynamic systemd units.




**Your objective**
*   Assist in debugging fluxfce-simplified





**Core Goal of `fluxfce`:**
To automatically apply user-defined "Day" and "Night" appearance settings (Theme, Background, Screen Temp) at the correct local sunrise and sunset times, while remaining reliable across logins, reboots, and suspend/resume cycles, using minimal system resources when idle.

**Architecture Overview:**
The project is split into two main parts:
1.  `fluxfce_core` (Python Package): Contains all backend logic, isolated from the UI.
    *   `api.py`: Public functions acting as the interface for external callers.
    *   `config.py`: `ConfigManager` class, handles `config.ini` (no presets).
    *   `exceptions.py`: Custom exception classes.
    *   `helpers.py`: Utility functions (`run_command`, validators, timezone detection).
    *   `scheduler.py`: `AtdScheduler` class, manages `at` jobs.
    *   `sun.py`: Sunrise/sunset calculation logic.
    *   `systemd.py`: `SystemdManager` class, manages systemd user units.
    *   `xfce.py`: `XfceHandler` class, interacts with `xfconf-query` and `xsct`.
    *   `__init__.py`: Exports the public API elements.
2.  `fluxfce_cli.py`: The command-line interface script. Uses `argparse`, calls functions from `fluxfce_core`, handles user output and error reporting.

**Key Features Implemented (v0.1):**
*   `install`: Sets up systemd units, creates default config (detects TZ, prompts coords), enables scheduling.
*   `uninstall`: Removes systemd units, clears schedule, prompts to remove config dir.
*   `enable`: Enables automatic scheduling (sets N-day `at` job buffer).
*   `disable`: Disables automatic scheduling (clears `at` jobs).
*   `status`: Shows current configuration, calculated sun times, schedule, systemd status.
*   `force-day`/`force-night`: Applies the specified mode now and disables automatic scheduling.
*   `set-default --mode <day|night>`: Saves the *current* desktop appearance as the default for the specified mode in `config.ini`.
*   Automatic theme application on Login and Resume via dedicated systemd services (`run-login-check` command).

**Key Features Explicitly REMOVED from original design:**
*   Preset system (`save`, `apply`, etc.)
*   Direct component setters (`set background`, `set theme`)
*   `config --get/--set` command
*   `toggle` command
*   State file (`~/.config/fluxfce/state`) - Deemed redundant.

**Technical Details & Design Decisions:**
*   **Scheduling:** Uses a **daily systemd user timer** (`fluxfce-scheduler.timer` with `Persistent=true`) which triggers a service (`fluxfce-scheduler.service`) to run `fluxfce schedule-jobs`. This calculates sunrise/sunset for the next **N=7 days** and schedules ~14 individual `at` jobs using `atd`. This provides robustness against missed scheduler runs. *Alternatives (daemon, chaining `at`, long-term pre-calc) were evaluated and rejected due to fragility, complexity, or lack of significant benefit.*
*   **Environment for `atd`:** `xsct` and `xfconf-query` need `DISPLAY`/`XAUTHORITY`. The `scheduler.schedule_transitions` function attempts to fetch these using `systemctl --user show-environment` and injects them as `export` commands into the script run by the `at` job.
*   **Resume Handling:** A dedicated systemd user service (`fluxfce-resume.service`) triggered by `sleep.target` runs the `run-login-check` command after resuming from suspend/hibernate to ensure the correct theme is applied.
*   **`xsct` Installation:** Requires manual compilation/installation from source (`https://github.com/faf0/xsct.git`) as it's typically not in package repositories.
*   **Configuration:** Single `config.ini` file. Edits should be reflected automatically within ~24hrs (by daily scheduler) or immediately upon next `enable` command.



**Config File:**
*   **Example Config File:**
```
~/.config/fluxfce/config.ini
[Location]
latitude = 43.65N
longitude = 79.38W
timezone = America/Toronto

[Themes]
light_theme = Adwaita
dark_theme = Adwaita-dark

[BackgroundDay]
bg_hex1 = ADD8E6
bg_hex2 = 87CEEB
bg_dir = v

[ScreenDay]
xsct_temp = 6500
xsct_bright = 1.0

[BackgroundNight]
bg_hex1 = 1E1E2E
bg_hex2 = 000000
bg_dir = v

[ScreenNight]
xsct_temp = 4500
xsct_bright = 0.85
```



**Please procceed**


   development task will likely involve addressing the "Known Issues / Immediate Next Steps", starting with **implementing automated tests** for the `fluxfce_core` library or creating the **packaging setup** (`pyproject.toml`). Await further instructions on which to prioritize.



**Known Issues / Immediate Next Steps:**
1.  **Automated Testing:** The project completely lacks automated tests (unit/integration). This is the highest priority before adding significant new features or distributing widely.
2.  **Packaging:** No `pyproject.toml` or `setup.py` exists. Installation relies on manual PATH setup (symlink recommended). Proper packaging using `pip` is needed.
3.  **Documentation:** Docstrings within `fluxfce_core` are sparse. The `README.md` needs review and potentially minor updates based on the final code state.
4.  **Real-world Testing:** Needs more testing across different XFCE versions, login managers, and suspend/resume scenarios. Confirm `xsct` env injection works reliably across systems.

##############
./readme.md

# fluxfce - XFCE Auto-Theming Utility

**Fluxfce** automates switching XFCE desktop appearance (GTK Theme, Background Color/Gradient, Screen Temperature/Brightness) between configured Day and Night modes based on local sunrise and sunset times. It uses an adapted NOAA algorithm to calculate transition times. Systemd and the `atd` scheduler are used for precise, low-resource scheduling.

This is a refactored and simplified version focusing on core functionality, reliability, and maintainability.

<p align="center">
  <img src="logo.png" alt="fluxfce Logo Placeholder" width="150">
</p>

---

## Features

- **Automatic Switching:** Automatically transitions between Day and Night modes at local sunrise and sunset.
- **Component Control:** Adjusts:
  - GTK Theme (`Net/ThemeName`)
  - Desktop Background (Solid color or vertical/horizontal gradient via `xfce4-desktop` properties)
  - Screen Temperature & Brightness (via `xsct`)
  - *(Support for background image switching is planned for a future version)*
- **Location Aware:** Calculates sunrise/sunset times based on user-configured latitude, longitude, and IANA timezone.
- **Timezone Detection:** Attempts to automatically detect system timezone during initial install.
- **Low Resource Usage:** Uses the system `atd` service for scheduling transitions, avoiding a persistent background daemon.
- **Systemd Integration:** Installs systemd user units (`.timer`, `.service`) for reliable daily rescheduling and applying the correct theme on login and resume from suspend.
- **Manual Overrides:** Easily force Day or Night mode (`force-day`, `force-night`). Manual overrides temporarily disable automatic scheduling.
- **Simple Configuration:** Uses a clear INI file (`~/.config/fluxfce/config.ini`).
- **Easy Default Setting:** Save your current desktop look as the new default for Day or Night mode (`set-default`).
- **Status Reporting:** Check current configuration, calculated times, and scheduled jobs (`status`).

## Requirements

- **Linux Distribution:** Designed for systemd-based distributions with XFCE.
  - **Primary Targets:** Ubuntu 22.04+ (Xubuntu), Linux Mint 21.x+ (XFCE), Debian 11+ (XFCE).
  - *May work on other systemd-based XFCE distributions (e.g., Fedora XFCE, Arch XFCE) with adjustments to package names for dependencies.*
- **Desktop Environment:** XFCE 4.x
- **Python:** Python 3.9+ (due to `zoneinfo` usage).
- **System Tools & Services (Dependencies):**
  - **`atd` service:** For scheduling transitions.
    - Installation: Usually via the `at` package (e.g., `sudo apt install at`).
    - Activation: Must be enabled and running (e.g., `sudo systemctl enable --now atd`).
  - **`xsct`:** For screen temperature and brightness control.
    - Installation on **Ubuntu 24.04 (Noble Numbat) and newer (or equivalent Linux Mint/Debian versions)**:
      ```bash
      sudo apt update
      sudo apt install xsct
      ```
    - Installation on **older Ubuntu/Debian versions (e.g., Ubuntu 22.04, Debian 11) or if `apt install xsct` fails**:
      `xsct` typically requires manual compilation from source:
      1.  Install build dependencies:
          ```bash
          sudo apt update
          sudo apt install build-essential libx11-dev libxrandr-dev git
          ```
      2.  Clone, compile, and install `xsct`:
          ```bash
          git clone https://github.com/faf0/xsct.git
          cd xsct
          sudo make install  # Installs to /usr/local/bin by default
          ```
          *(Alternatively, install to `~/.local/bin`: `make PREFIX=~/.local install` and ensure `~/.local/bin` is in your PATH)*
  - **Core XFCE/System Tools** (Usually pre-installed on XFCE systems):
    - `xfconf-query` (from `xfce4-utils` or similar)
    - `xfdesktop` (from `xfdesktop4` or similar, for background reloads)
    - `systemctl`, `timedatectl` (part of systemd)
    - `at`, `atq`, `atrm` (from the `at` package)

## Installation

1.  **Clone the repository (or download the source code):**
    ```bash
    git clone https://github.com/yourusername/fluxfce.git # Replace with actual URL
    cd fluxfce
    ```

2.  **Run the install command:**
    ```bash
    python3 fluxfce_cli.py install
    ```
    The script will:
    *   Check for Python version.
    *   Check for required system dependencies and guide you through installing missing ones (like `at` or `xsct` via `apt`, or provide manual instructions for `xsct`).
    *   Prompt you for location (latitude/longitude) and attempt to detect your timezone for accurate sun time calculations if a configuration file doesn't exist.
    *   Install systemd user units for automatic operation.
    *   Enable scheduling.

3.  **Make the `fluxfce` command easily accessible (if not using `pip install .` in the future):**
    The `install` script will provide instructions. A common method is:
    *   Ensure `~/.local/bin` is in your `PATH`. Add if necessary:
        ```bash
        # Add to your ~/.bashrc or ~/.zshrc, then source it or restart terminal
        export PATH="$HOME/.local/bin:$PATH"
        ```
    *   Make the main script executable:
        ```bash
        chmod +x ./fluxfce_cli.py
        ```    *   Create a symbolic link:
        ```bash
        SCRIPT_ABS_PATH=$(readlink -f ./fluxfce_cli.py) # Or use: SCRIPT_ABS_PATH=$(pwd)/fluxfce_cli.py
        mkdir -p ~/.local/bin
        ln -s "$SCRIPT_ABS_PATH" ~/.local/bin/fluxfce
        ```

4.  **(Recommended) Configure Day/Night Appearance:**
    Set your desired XFCE theme, background color/gradient, and screen temperature/brightness for **Daytime**, then run:
    ```bash
    fluxfce set-default --mode day
    ```
    Then, set your desired look for **Nighttime**, and run:
    ```bash
    fluxfce set-default --mode night
    ```
    `fluxfce` will save these settings to its configuration file.

## Usage

```bash
fluxfce <command> [options]
```

**Commands:**
- `install`  Performs dependency checks, interactive setup (if needed), installs systemd units, and enables automatic scheduling.
- `uninstall`  Removes systemd units and clears schedule (prompts to remove config).
- `enable`  Enables automatic scheduling (schedules transitions).
- `disable`  Disable automatic scheduling (clears scheduled transitions).
- `status`  Show config, calculated times, and schedule status.
- `force-day`  Apply Day Mode settings now (disables automatic scheduling).
- `force-night`  Apply Night Mode settings now (disables automatic scheduling).
- `set-default --mode {day,night}`  Save current desktop look as the new default for Day or Night mode.

**Options:**
- `-h`, `--help`  Show this help message and exit.
- `-v`, `--verbose`  Enable detailed logging output for `fluxfce` operations.

## Configuration

Fluxfce uses an INI file located at `~/.config/fluxfce/config.ini`.
The `fluxfce install` command will help you create this initially. You can edit it manually later.

**Example `config.ini`:**
```ini
[Location]
latitude = 43.65N
longitude = 79.38W
timezone = America/Toronto

[Themes]
light_theme = Adwaita
dark_theme = Adwaita-dark

[BackgroundDay]
bg_dir = v
bg_hex1 = ADD8E6
bg_hex2 = 87CEEB

[ScreenDay]
xsct_temp = 6500
xsct_bright = 1.0

[BackgroundNight]
bg_dir = v
bg_hex1 = 1E1E2E
bg_hex2 = 000000

[ScreenNight]
xsct_temp = 4500
xsct_bright = 0.85
```

- **`bg_dir` (Background Direction):**
  - `s` = Solid color (uses `bg_hex1` only)
  - `h` = Horizontal gradient (uses `bg_hex1` and `bg_hex2`)
  - `v` = Vertical gradient (uses `bg_hex1` and `bg_hex2`)
- **`xsct_temp` (Screen Temperature):** In Kelvin (e.g., 3700, 6500). If empty for Day mode, `xsct` typically resets to its default.
- **`xsct_bright` (Screen Brightness):** Factor (e.g., 0.8, 1.0). If empty for Day mode, `xsct` typically resets to its default.

## Troubleshooting

- **Verbose Output:** Always try running `fluxfce` with the `-v` flag first to get more detailed logs:
  ```bash
  fluxfce -v status
  fluxfce -v enable
  ```
- **Dependency Check Script:**
  If you suspect system dependencies are the issue, and if the `fluxfce install` guidance wasn't sufficient, you can re-run the dependency check. If a separate script (e.g., `fluxfce_dependency_setup.py`) was provided with fluxfce:
  ```bash
  python3 /path/to/fluxfce_dependency_setup.py
  ```
  Otherwise, the `fluxfce install` command itself performs these checks.

- **Check `atd` Service:**
  ```bash
  sudo systemctl status atd
  ```
  Ensure it's active and enabled. If not:
  ```bash
  sudo apt install at # If not installed
  sudo systemctl enable --now atd
  ```

- **Check `at` Queue:** See if `fluxfce` jobs are scheduled:
  ```bash
  atq
  ```

- **Systemd User Units:** Check the status of `fluxfce`'s own services:
  ```bash
  systemctl --user status fluxfce-scheduler.timer fluxfce-scheduler.service fluxfce-login.service fluxfce-resume.service
  ```

- **View Journal Logs:** For more detailed error messages from `fluxfce` services:
  ```bash
  journalctl --user -u fluxfce-scheduler.timer
  journalctl --user -u fluxfce-scheduler.service
  journalctl --user -u fluxfce-login.service
  journalctl --user -u fluxfce-resume.service
  journalctl --user -t fluxfce-atjob # For output from the actual theme transitions
  ```

- **Configuration File Path:** Ensure your config is at `~/.config/fluxfce/config.ini`.

## License

MIT

##############
