##############
fluxfce_cli.py

#!/usr/bin/env python3

"""
fluxfce (CLI) - Simplified XFCE Theming Tool (Systemd Timer Version)

Command-line interface for managing automatic XFCE theme/background/screen
switching based on sunrise/sunset times using the fluxfce_core library.
This version uses systemd timers for scheduling, replacing atd.
"""

import argparse
import logging
import pathlib
import shutil
import subprocess
import sys

# Import the refactored core library API and exceptions
try:
    import fluxfce_core
    from fluxfce_core import exceptions as core_exc
    # For accessing constants like SCHEDULER_TIMER_NAME etc. directly if needed for output
    from fluxfce_core import (
        SCHEDULER_TIMER_NAME, SCHEDULER_SERVICE_NAME,
        LOGIN_SERVICE_NAME, RESUME_SERVICE_NAME,
        # SUNRISE_EVENT_TIMER_NAME, SUNSET_EVENT_TIMER_NAME # Not directly used in CLI output string formatting yet
    )
    from fluxfce_core import config as core_config # For CONFIG_FILE in enable command
except ImportError as e:
    print(f"Error: Failed to import the fluxfce_core library: {e}", file=sys.stderr)
    print(
        "Ensure fluxfce_core is installed or available in your Python path.",
        file=sys.stderr,
    )
    sys.exit(1)

# --- Global Variables ---
SCRIPT_DIR = pathlib.Path(__file__).resolve().parent
SCRIPT_PATH = str(pathlib.Path(__file__).resolve())
PYTHON_EXECUTABLE = sys.executable
DEPENDENCY_CHECKER_SCRIPT_NAME = "fluxfce_deps_check.py" # Assumed to be updated

log = logging.getLogger("fluxfce_cli")


# --- CLI Logging Setup ---
def setup_cli_logging(verbose: bool):
    """Configures logging for the CLI based on verbosity."""
    cli_log_level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(
        level=logging.WARNING, format="%(levelname)s: %(name)s: %(message)s"
    )

    log.setLevel(cli_log_level)
    if log.hasHandlers():
        log.handlers.clear()

    core_log_level = logging.DEBUG if verbose else logging.WARNING
    core_logger = logging.getLogger("fluxfce_core")
    core_logger.setLevel(core_log_level)
    if not core_logger.hasHandlers(): # Ensure core logger gets a handler if basicConfig didn't cover it
        core_handler = logging.StreamHandler(sys.stderr) # Core logs to stderr by default
        core_formatter = logging.Formatter("%(levelname)s: fluxfce_core: %(message)s")
        core_handler.setFormatter(core_formatter)
        core_logger.addHandler(core_handler)
        core_logger.propagate = False

    if cli_log_level <= logging.INFO:
        info_handler = logging.StreamHandler(sys.stdout)
        info_formatter = logging.Formatter("%(message)s") # CLI info messages are direct
        info_handler.setFormatter(info_formatter)
        info_handler.setLevel(logging.INFO)
        info_handler.addFilter(lambda record: record.levelno == logging.INFO)
        log.addHandler(info_handler)

    # General CLI errors/warnings/debug to stderr
    error_handler = logging.StreamHandler(sys.stderr)
    error_formatter = logging.Formatter("%(levelname)s: %(name)s: %(message)s") # Show CLI name
    error_handler.setFormatter(error_formatter)
    error_handler.setLevel(logging.DEBUG if verbose else logging.WARNING) # Capture debug for verbose
    log.addHandler(error_handler)

    log.propagate = False
    if verbose:
        log.debug("Verbose logging enabled for fluxfce_cli.")
        core_logger.debug("Verbose logging enabled for fluxfce_core (via CLI).")


# --- Output Formatting ---
def print_status(status_data: dict):
    """Formats and prints the status dictionary."""
    log.info("--- fluxfce Status ---")

    log.info("\n[Configuration]")
    if status_data["config"].get("error"):
        log.info(f"  Error loading config: {status_data['config']['error']}")
    else:
        log.info(f"  Location:      {status_data['config'].get('latitude', 'N/A')}, {status_data['config'].get('longitude', 'N/A')}")
        log.info(f"  Timezone:      {status_data['config'].get('timezone', 'N/A')}")
        log.info(f"  Light Theme:   {status_data['config'].get('light_theme', 'N/A')}")
        log.info(f"  Dark Theme:    {status_data['config'].get('dark_theme', 'N/A')}")

    log.info("\n[Calculated Sun Times (Today)]")
    if status_data["sun_times"].get("error"):
        log.info(f"  Error: {status_data['sun_times']['error']}")
    elif status_data["sun_times"].get("sunrise") and status_data["sun_times"].get("sunset"):
        sunrise_dt = status_data["sun_times"]["sunrise"]
        sunset_dt = status_data["sun_times"]["sunset"]
        try:
            log.info(f"  Sunrise:       {sunrise_dt.isoformat(sep=' ', timespec='seconds')}")
            log.info(f"  Sunset:        {sunset_dt.isoformat(sep=' ', timespec='seconds')}")
        except Exception:
            log.info(f"  Sunrise:       {sunrise_dt}")
            log.info(f"  Sunset:        {sunset_dt}")
    else:
        log.info("  Could not be calculated (check config/location).")
    log.info(f"  Current Period:  {status_data.get('current_period', 'unknown').capitalize()}")

    log.info("\n[Systemd Scheduling Timers]")
    schedule_info = status_data.get("schedule", {})
    if schedule_info.get("error"):
        log.info(f"  Error checking systemd timers: {schedule_info['error']}")
    else:
        timers = schedule_info.get("timers", {})
        if not timers and not schedule_info.get("info"): # No timers and no specific info message
             log.info("  Scheduler status unknown or no fluxfce timers found.")
        elif schedule_info.get("info"): # E.g. "No fluxfce timers found or listed."
             log.info(f"  Status: {schedule_info.get('info')}")

        for timer_name, details in timers.items():
            log.info(f"  Timer: {timer_name}")
            log.info(f"    Status:    {details.get('enabled', 'N/A')}, {details.get('active', 'N/A')}")
            log.info(f"    Next Run:  {details.get('next_run', 'N/A')}")
            #log.info(f"    Time Left: {details.get('time_left', 'N/A')}")
            log.info(f"    Last Run:  {details.get('last_run', 'N/A')}")
            log.info(f"    Activates: {details.get('activates', 'N/A')}")
        
        is_enabled = any(
            SCHEDULER_TIMER_NAME in name and ("Enabled" in details.get("enabled","") and "Active" in details.get("active",""))
            for name, details in timers.items()
        )
        if not timers and not schedule_info.get("error") and not schedule_info.get("info"):
             log.info("  Status: Disabled (No fluxfce timers configured or found)")
        elif not is_enabled and not schedule_info.get("error"):
            log.info("  Overall Status: Scheduling may be disabled or timers not active.")
            log.info("  (Run 'fluxfce enable' to enable automatic scheduling)")


    log.info("\n[Systemd Services (Login/Resume/Scheduler)]")
    systemd_services = status_data.get("systemd_services", {})
    if systemd_services.get("error"):
        log.info(f"  Error checking systemd services: {systemd_services['error']}")
    else:
        log.info(f"  Scheduler Timer State Checker ({SCHEDULER_SERVICE_NAME}): {systemd_services.get('scheduler_service', 'Unknown')}")
        log.info(f"  Login Service ({LOGIN_SERVICE_NAME}): {systemd_services.get('login_service', 'Unknown')}")
        log.info(f"  Resume Service ({RESUME_SERVICE_NAME}): {systemd_services.get('resume_service', 'Unknown')}")
        log.info("  (For detailed logs/status, use 'systemctl --user status ...' or 'journalctl --user -u ...')")

    log.info("-" * 25)


# --- User Interaction Helper ---
def ask_yes_no_cli(prompt: str, default_yes: bool = False) -> bool:
    """Asks a yes/no question and returns True for yes, False for no."""
    suffix = "[Y/n]" if default_yes else "[y/N]"
    while True:
        try:
            print(f"{prompt} {suffix}: ", end="", flush=True) # Direct print for prompt
            response = input().strip().lower()
            if not response:
                return default_yes
            if response in ["y", "yes"]:
                return True
            if response in ["n", "no"]:
                return False
            print("[WARN] Invalid input. Please enter 'y' or 'n'.") # Direct print for feedback
        except EOFError:
            print()
            return default_yes
        except KeyboardInterrupt:
            print("\nPrompt interrupted. Assuming 'no'.")
            return False


# --- Main Execution Logic ---
def main():
    """Parses command-line arguments and dispatches to appropriate command handlers."""
    parser = argparse.ArgumentParser(
        description="fluxfce (CLI): Manage XFCE appearance via sunrise/sunset timing (Systemd Timer Version).",
        formatter_class=argparse.RawTextHelpFormatter,
        epilog="""
Examples:
  fluxfce install          # Interactive setup, install units, and enable scheduling
  fluxfce status           # Show current status and configuration
  fluxfce enable           # Enable automatic scheduling (sets up systemd timers)
  fluxfce disable          # Disable automatic scheduling (clears systemd timers)
  fluxfce force-day        # Apply Day mode now and disable auto switching
  fluxfce force-night      # Apply Night mode now and disable auto switching
  fluxfce set-default --mode day # Save current desktop look as the new Day default
  fluxfce uninstall        # Remove systemd units and clear schedule (prompts for config removal)
""",
    )
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Enable detailed logging output."
    )
    subparsers = parser.add_subparsers(dest="command", title="Commands", required=True)

    subparsers.add_parser("install", help="Install systemd units and enable automatic scheduling.")
    subparsers.add_parser("uninstall", help="Remove systemd units & clear schedule (prompts to remove config).")
    subparsers.add_parser("enable", help="Enable automatic scheduling (configures systemd timers).")
    subparsers.add_parser("disable", help="Disable automatic scheduling (clears relevant systemd timers).")
    subparsers.add_parser("status", help="Show config, calculated times, and schedule status.")
    subparsers.add_parser("force-day", help="Apply Day Mode settings now (disables automatic scheduling).")
    subparsers.add_parser("force-night", help="Apply Night Mode settings now (disables automatic scheduling).")
    
    parser_set_default = subparsers.add_parser(
        "set-default", help="Save current desktop look as the new default for Day or Night mode."
    )
    parser_set_default.add_argument(
        "--mode", choices=["day", "night"], required=True, dest="default_mode",
        help="Specify whether to save as the Day or Night default."
    )

    # Internal commands, hidden from public help
    parser_internal_apply = subparsers.add_parser("internal-apply", help=argparse.SUPPRESS)
    parser_internal_apply.add_argument(
        "--mode", choices=["day", "night"], required=True, dest="internal_mode"
    )
    subparsers.add_parser("schedule-dynamic-transitions", help=argparse.SUPPRESS) # New internal command
    subparsers.add_parser("run-login-check", help=argparse.SUPPRESS)


    args = parser.parse_args()
    setup_cli_logging(args.verbose)
    exit_code = 0

    try:
        log.debug(f"Running command: {args.command}")
        log.debug(f"Script path: {SCRIPT_PATH}")
        log.debug(f"Python executable: {PYTHON_EXECUTABLE}")

        if args.command == "install":
            log.info("--- Step 1: Checking system dependencies ---")
            dependency_checker_script = SCRIPT_DIR / DEPENDENCY_CHECKER_SCRIPT_NAME
            if not dependency_checker_script.exists():
                log.error(f"Dependency checker script '{DEPENDENCY_CHECKER_SCRIPT_NAME}' not found in {SCRIPT_DIR}")
                sys.exit(1)
            
            log.info(f"Executing dependency checker: {dependency_checker_script}...")
            process = subprocess.run([PYTHON_EXECUTABLE, str(dependency_checker_script)], check=False, capture_output=False)
            if process.returncode != 0:
                log.error(f"Dependency check/setup failed (exit code: {process.returncode}). Aborting installation.")
                sys.exit(1)
            log.info("System dependency check passed or issues addressed.")
            log.info("--- Dependency check complete ---")

            log.info("\n--- Step 2: Configuring FluxFCE application settings ---")
            config_existed = fluxfce_core.CONFIG_FILE.exists()
            config_obj = fluxfce_core.get_current_config() # Loads or creates with defaults
            needs_saving = False

            run_interactive_setup = False
            if not config_existed:
                run_interactive_setup = True
                log.info("Configuration file not found. Starting interactive setup.")
            else:
                loc_section = "Location"
                current_lat = config_obj.get(loc_section, "LATITUDE", fallback=None)
                current_lon = config_obj.get(loc_section, "LONGITUDE", fallback=None)
                if (current_lat == core_config.DEFAULT_CONFIG[loc_section]["LATITUDE"] and \
                    current_lon == core_config.DEFAULT_CONFIG[loc_section]["LONGITUDE"]) or \
                   not current_lat or not current_lon:
                    log.info("Existing config found, but location seems default/missing.")
                    if ask_yes_no_cli("Run interactive setup for location/timezone?", default_yes=True):
                        run_interactive_setup = True
                    else:
                        log.info("Skipping interactive setup. Using current/default config values.")
                else:
                    log.info(f"Existing configuration found at {fluxfce_core.CONFIG_FILE}. Using it.")
            
            if run_interactive_setup:
                detected_tz = fluxfce_core.detect_system_timezone()
                current_tz_in_config = config_obj.get("Location", "TIMEZONE", fallback=core_config.DEFAULT_CONFIG["Location"]["TIMEZONE"])
                final_tz = current_tz_in_config

                if detected_tz:
                    print(f"\nDetected system timezone: '{detected_tz}'") # Direct print for interaction
                    if detected_tz != final_tz:
                        if ask_yes_no_cli(f"Use detected timezone '{detected_tz}' (current is '{final_tz}')?", default_yes=True):
                            final_tz = detected_tz
                    else:
                        print(f"Detected timezone matches current/default ('{final_tz}').")
                else:
                    print(f"\nCould not detect system timezone. Current is '{final_tz}'.")
                
                if config_obj.get("Location", "TIMEZONE") != final_tz:
                    config_obj.set("Location", "TIMEZONE", final_tz)
                    needs_saving = True
                print(f"Using timezone: {final_tz}")

                print("\nPlease provide location coordinates (e.g., 43.65N, 79.38W). Press Enter for defaults.")
                prompt_default_lat = config_obj.get("Location", "LATITUDE", fallback=core_config.DEFAULT_CONFIG["Location"]["LATITUDE"])
                prompt_default_lon = config_obj.get("Location", "LONGITUDE", fallback=core_config.DEFAULT_CONFIG["Location"]["LONGITUDE"])
                
                try:
                    lat_input = input(f"Enter Latitude [{prompt_default_lat}]: ").strip()
                    lon_input = input(f"Enter Longitude [{prompt_default_lon}]: ").strip()
                    
                    chosen_lat = lat_input if lat_input else prompt_default_lat
                    chosen_lon = lon_input if lon_input else prompt_default_lon

                    fluxfce_core.helpers.latlon_str_to_float(chosen_lat) # Validate
                    fluxfce_core.helpers.latlon_str_to_float(chosen_lon) # Validate

                    if config_obj.get("Location", "LATITUDE") != chosen_lat or \
                       config_obj.get("Location", "LONGITUDE") != chosen_lon:
                        config_obj.set("Location", "LATITUDE", chosen_lat)
                        config_obj.set("Location", "LONGITUDE", chosen_lon)
                        needs_saving = True
                    print(f"Using coordinates: Latitude={chosen_lat}, Longitude={chosen_lon}")
                except (EOFError, KeyboardInterrupt): print("\nInput skipped. Using previous/default coordinates.")
                except core_exc.ValidationError as e: print(f"\nWarning: Invalid coordinate input ({e}). Using previous/default.")
                except Exception as e_coord: print(f"\nWarning: Unexpected error ({e_coord}). Using previous/default.")
            
            if needs_saving or not config_existed:
                log.info("Saving initial/updated FluxFCE configuration...")
                fluxfce_core.save_configuration(config_obj)
            log.info("--- FluxFCE application configuration complete ---")

            log.info("\n--- Step 3: Installing systemd units ---")
            fluxfce_core.install_fluxfce(script_path=SCRIPT_PATH, python_executable=PYTHON_EXECUTABLE)
            log.info("Static systemd units installed.")

            log.info("\n--- Step 4: Enabling automatic scheduling ---")
            # This will set up initial dynamic timers and enable the main scheduler.timer
            fluxfce_core.enable_scheduling(python_exe_path=PYTHON_EXECUTABLE, script_exe_path=SCRIPT_PATH)
            log.info("Automatic theme scheduling enabled via systemd timers.")

            log.info("\n" + "-" * 45 + "\n fluxfce installed and enabled successfully. \n" + "-" * 45 + "\n")
            # ... (Instructions for PATH setup remain similar) ...
            user_bin_dir = pathlib.Path.home() / ".local" / "bin"
            log.info("IMPORTANT: To run 'fluxfce' easily from your terminal, ensure")
            log.info(f"the script ({pathlib.Path(SCRIPT_PATH).name}) or a symlink to it is in your PATH.")
            log.info(f"Recommended: ln -s -f \"{SCRIPT_PATH}\" \"{user_bin_dir / 'fluxfce'}\" (after ensuring {user_bin_dir} is in PATH)")
            log.info("\nTip: Configure Day/Night appearance using 'fluxfce set-default --mode day|night'.")
            log.info("Check 'fluxfce status' to see the current setup.")

        elif args.command == "uninstall":
            log.info("Starting uninstallation (system components)...")
            # disable_scheduling is now called within uninstall_fluxfce in the API
            fluxfce_core.uninstall_fluxfce()
            log.info("FluxFCE systemd units removed and schedule cleared/dynamic timers removed.")

            config_dir_path = fluxfce_core.CONFIG_DIR
            if config_dir_path.exists():
                log.warning(f"\nConfiguration directory found at: {config_dir_path}")
                if ask_yes_no_cli("Do you want to REMOVE this configuration directory?", default_yes=False):
                    try:
                        shutil.rmtree(config_dir_path)
                        log.info(f"Removed configuration directory: {config_dir_path}")
                    except OSError as e:
                        log.error(f"Error removing config directory {config_dir_path}: {e}")
                else:
                    log.info("Configuration directory kept.")
            log.info("\n--- Uninstallation Complete ---")

        elif args.command == "enable":
            log.info("Enabling scheduling via systemd timers...")
            if not core_config.CONFIG_FILE.exists(): # Use imported core_config
                log.error(f"Configuration file {core_config.CONFIG_FILE} not found.")
                log.error("Please run 'fluxfce install' first or ensure config is in place.")
                exit_code = 1
            else:
                fluxfce_core.enable_scheduling(
                    python_exe_path=PYTHON_EXECUTABLE, script_exe_path=SCRIPT_PATH
                )
                log.info("Automatic theme scheduling enabled using systemd timers.")
                log.info("Run 'fluxfce status' to see scheduled timers.")

        elif args.command == "disable":
            log.info("Disabling scheduling (systemd timers)...")
            fluxfce_core.disable_scheduling()
            log.info("Automatic theme scheduling disabled (main scheduler & dynamic event timers stopped/removed).")

        elif args.command == "status":
            status = fluxfce_core.get_status()
            print_status(status)

        elif args.command == "force-day":
            log.info("Forcing Day mode...")
            fluxfce_core.apply_manual_mode("day") # This also disables scheduling
            log.info("Day mode applied. Automatic scheduling (systemd timers) disabled.")

        elif args.command == "force-night":
            log.info("Forcing Night mode...")
            fluxfce_core.apply_manual_mode("night") # This also disables scheduling
            log.info("Night mode applied. Automatic scheduling (systemd timers) disabled.")

        elif args.command == "set-default":
            mode = args.default_mode
            log.info(f"Setting current look as default for {mode} mode...")
            fluxfce_core.set_default_from_current(mode)
            log.info(f"Current desktop settings saved as default for {mode.capitalize()} mode.")
            log.info("(Run 'fluxfce enable' to (re)activate scheduling with new defaults).")

        elif args.command == "internal-apply":
            mode = args.internal_mode
            log.debug(f"CLI: Executing internal-apply for mode '{mode}' (called by systemd service)")
            success = fluxfce_core.handle_internal_apply(mode)
            exit_code = 0 if success else 1
        
        elif args.command == "schedule-dynamic-transitions": # New internal command
            log.debug("CLI: Executing schedule-dynamic-transitions (called by systemd scheduler service)")
            success = fluxfce_core.handle_schedule_dynamic_transitions_command(
                python_exe_path=PYTHON_EXECUTABLE, script_exe_path=SCRIPT_PATH
            )
            exit_code = 0 if success else 1

        elif args.command == "run-login-check":
            log.debug("CLI: Executing run-login-check (called by systemd login/resume service)")
            success = fluxfce_core.handle_run_login_check()
            exit_code = 0 if success else 1
        else:
            log.error(f"Unknown command: {args.command}")
            parser.print_help(sys.stderr)
            exit_code = 1

    except core_exc.FluxFceError as e:
        log.error(f"FluxFCE Error: {e}", exc_info=args.verbose)
        exit_code = 1
    except Exception as e_main: # Catchall for unexpected errors
        log.error(f"An unexpected error occurred in CLI: {e_main}", exc_info=True)
        exit_code = 1

    sys.exit(exit_code)


if __name__ == "__main__":
    main()

##############
fluxfce_core/api.py

# fluxfce_core/api.py
"""
Public API Facade for the fluxfce_core library.

This module provides the primary interface for external callers (like the CLI)
to interact with the core functionalities of FluxFCE, including configuration,
scheduling, desktop appearance management, and systemd integration.
It orchestrates calls to other internal modules within `fluxfce_core`.
"""

import configparser
import logging
import re 
from datetime import datetime # For get_status, timedelta was only in scheduler
from typing import Any, Optional

# Import core components and exceptions
from . import config as cfg # For ConfigManager instance if api needs one directly
from . import exceptions as exc
from . import helpers, sun, xfce, systemd as sysd # systemd might be needed for constants

# --- NEW IMPORTS from refactored modules ---
from . import desktop_manager # For appearance and related handlers
from . import scheduler       # For scheduling logic

# zoneinfo needed for get_status and potentially other api-level functions if any evolve
try:
    from zoneinfo import (
        ZoneInfo,
        ZoneInfoNotFoundError,
    )
except ImportError: # Should be caught by Python version checks or at a higher level
    raise ImportError(
        "Required module 'zoneinfo' not found. FluxFCE requires Python 3.9+."
    )

log = logging.getLogger(__name__)

# --- Module-level Managers (Primarily for functions still residing in api.py like get_status) ---
# If all logic moves out, these might not be needed here.
_cfg_mgr_api = cfg.ConfigManager()
_sysd_mgr_api = sysd.SystemdManager() # Used by get_status

# --- Public API Functions for Config ---
# These are fundamental and can stay in api.py or move to a config_manager_facade.py
# For now, keeping them here for simplicity of this refactor step.

def get_current_config() -> configparser.ConfigParser:
    """Loads the current configuration, applying defaults in memory."""
    log.debug("API: get_current_config called")
    try:
        # Assuming _cfg_mgr_api is the intended ConfigManager instance for this
        return _cfg_mgr_api.load_config()
    except exc.ConfigError as e:
        log.error(f"API: Failed to load configuration: {e}")
        raise 
    except Exception as e:
        log.exception(f"API: Unexpected error loading configuration: {e}")
        raise exc.FluxFceError(f"Unexpected error loading configuration: {e}") from e

def save_configuration(config_obj: configparser.ConfigParser) -> bool:
    """Saves the given ConfigParser object to file."""
    log.debug("API: save_configuration called")
    try:
        return _cfg_mgr_api.save_config(config_obj)
    except exc.ConfigError as e:
        log.error(f"API: Failed to save configuration: {e}")
        raise
    except Exception as e:
        log.exception(f"API: Unexpected error saving configuration: {e}")
        raise exc.FluxFceError(f"Unexpected error saving configuration: {e}") from e

# --- Installation and Uninstallation ---
# These orchestrate actions from systemd.py and scheduler.py

def install_fluxfce(script_path: str, python_executable: Optional[str] = None) -> bool:
    """
    API Façade: Installs static systemd units.
    The CLI will call enable_scheduling after this.
    """
    log.info(f"API Facade: Installing static systemd units for {sysd._APP_NAME}.")
    try:
        # Use a local SystemdManager instance for this specific task
        install_mgr = sysd.SystemdManager()
        success = install_mgr.install_units(
            script_path=script_path, python_executable=python_executable
        )
        if success:
            log.info("API Facade: Static systemd units installed successfully.")
            return True
        else:
            # install_units should ideally raise on critical failure.
            raise exc.SystemdError(f"API Facade: SystemdManager install_units failed for {sysd._APP_NAME}.")
    except (exc.SystemdError, FileNotFoundError, exc.DependencyError) as e:
        log.error(f"API Facade: Static systemd unit installation failed: {e}")
        raise
    except Exception as e:
        log.exception(f"API Facade: Unexpected error during {sysd._APP_NAME} installation: {e}")
        raise exc.FluxFceError(f"API Facade: Unexpected error during {sysd._APP_NAME} installation: {e}") from e

def uninstall_fluxfce() -> bool:
    """
    API Façade: Disables scheduling and removes all systemd units.
    """
    log.info(f"API Facade: Uninstalling {sysd._APP_NAME} (disabling schedule, removing units).")
    try:
        disable_success = True
        try:
            # Call the scheduler module to handle its part of disabling
            scheduler.disable_scheduling() 
            log.info("API Facade: Scheduling disabled by scheduler module.")
        except Exception as e_disable:
            log.warning(f"API Facade: Error during scheduler.disable_scheduling in uninstall (continuing): {e_disable}")
            disable_success = False # Logged, but uninstallation of files should proceed

        # Remove static unit files via SystemdManager
        uninstall_mgr = sysd.SystemdManager()
        removal_ok = uninstall_mgr.remove_units()
        
        if removal_ok:
            log.info(f"API Facade: Systemd units removed by SystemdManager.")
            if not disable_success:
                 log.warning("API Facade: Uninstallation completed, but disabling/cleanup of schedule encountered issues.")
            return True
        else:
            raise exc.SystemdError(f"API Facade: SystemdManager remove_units failed for {sysd._APP_NAME}.")
    except (exc.SystemdError, exc.DependencyError) as e:
        log.error(f"API Facade: Failed to remove {sysd._APP_NAME} systemd units: {e}")
        raise
    except Exception as e:
        log.exception(f"API Facade: Unexpected error during {sysd._APP_NAME} uninstallation: {e}")
        raise exc.FluxFceError(f"API Facade: Unexpected error during {sysd._APP_NAME} uninstallation: {e}") from e


# --- SCHEDULING FAÇADE ---

def enable_scheduling(python_exe_path: str, script_exe_path: str) -> bool:
    """
    API Façade: Enables scheduling and applies the theme for the current solar period.
    """
    log.info("API Facade: Attempting to enable scheduling...")
    
    # Step 1 & 2: Enable scheduling via the scheduler module
    # This sets up timers and starts the main scheduler.timer --now
    try:
        scheduler_enabled_ok = scheduler.enable_scheduling(
            python_exe_path=python_exe_path, script_exe_path=script_exe_path
        )
    except exc.FluxFceError as e_sched: # Catch errors from scheduler.enable_scheduling
        log.error(f"API Facade: Scheduler module failed to enable scheduling: {e_sched}")
        raise # Re-raise to be caught by CLI
    except Exception as e_sched_unexpected:
        log.exception(f"API Facade: Unexpected error from scheduler.enable_scheduling: {e_sched_unexpected}")
        raise exc.FluxFceError(f"API Facade: Unexpected error from scheduler.enable_scheduling: {e_sched_unexpected}") from e_sched_unexpected


    # Step 3: Explicitly apply the theme for the current actual period.
    log.info("API Facade: Scheduling setup by scheduler module. Applying theme for current solar period...")
    try:
        # desktop_manager.handle_run_login_check() determines current period and applies settings.
        apply_current_ok = desktop_manager.handle_run_login_check()
        if apply_current_ok:
            log.info("API Facade: Theme for current solar period applied successfully.")
        else:
            # This means applying the current theme failed. This is a significant issue.
            log.error("API Facade: FAILED to apply theme for the current solar period after enabling schedule.")
            # Consider if this should make the whole operation fail.
            # For now, scheduling might be enabled, but the state isn't right.
            # The CLI should inform the user. FluxFceError could be raised here.
            # Let's return False to indicate a problem.
            return False 
    except exc.FluxFceError as e_apply_current:
        log.error(f"API Facade: Error applying current theme after enabling scheduling: {e_apply_current}")
        raise # Re-raise to be caught by CLI
    except Exception as e_apply_unexpected:
        log.exception(f"API Facade: Unexpected error applying current theme after enabling scheduling: {e_apply_unexpected}")
        raise exc.FluxFceError(f"Unexpected error applying current theme: {e_apply_unexpected}") from e_apply_unexpected
    
    log.info("API Facade: Scheduling enabled and current theme applied.")
    return True # If we reach here, scheduler setup and current theme application were successful

def disable_scheduling() -> bool:
    """API Façade: Disables scheduling by calling the scheduler module."""
    log.info("API Facade: Calling scheduler.disable_scheduling...")
    return scheduler.disable_scheduling()

def handle_schedule_dynamic_transitions_command(python_exe_path: str, script_exe_path: str) -> bool:
    """API Façade: For CLI internal command to call the scheduler function."""
    log.debug("API Facade: Relaying 'schedule-dynamic-transitions' to scheduler module.")
    return scheduler.handle_schedule_dynamic_transitions_command(python_exe_path, script_exe_path)


# --- DESKTOP APPEARANCE FAÇADE (via desktop_manager) ---

def apply_manual_mode(mode: str) -> bool:
    """
    API Façade: Applies a manual appearance mode and disables scheduling.
    """
    log.info(f"API Facade: Applying manual mode '{mode}' and then disabling scheduling...")
    
    try:
        # Step 1: Apply the visual mode using the desktop manager
        apply_appearance_ok = desktop_manager.apply_mode(mode) 
    except exc.FluxFceError as e_apply: # Catch errors from desktop_manager.apply_manual_mode
        log.error(f"API Facade: desktop_manager.apply_manual_mode('{mode}') failed: {e_apply}")
        # Even if applying appearance fails, still attempt to disable scheduling.
        # But the overall operation has failed.
        try:
            scheduler.disable_scheduling()
        except Exception as e_disable:
            log.warning(f"API Facade: Failed to disable scheduling after failed manual mode apply: {e_disable}")
        raise # Re-raise the original apply error
    except Exception as e_apply_unexpected:
        log.exception(f"API Facade: Unexpected error from desktop_manager.apply_manual_mode('{mode}'): {e_apply_unexpected}")
        try:
            scheduler.disable_scheduling()
        except Exception as e_disable:
            log.warning(f"API Facade: Failed to disable scheduling after unexpected manual mode apply error: {e_disable}")
        raise exc.FluxFceError(f"Unexpected error applying manual mode '{mode}'") from e_apply_unexpected


    # Step 2: Disable scheduling using the scheduler module
    try:
        disable_sched_ok = scheduler.disable_scheduling()
        if not disable_sched_ok:
            log.warning("API Facade: Appearance for manual mode applied, but scheduler.disable_scheduling reported an issue.")
            # If applying appearance was OK, but disabling schedule failed, this is a mixed success.
            # For now, if apply_appearance_ok was true, we return true.
    except exc.FluxFceError as e_disable:
        log.warning(f"API Facade: Appearance for manual mode applied, but scheduler.disable_scheduling failed: {e_disable}")
        # Similar to above, the primary action (applying mode) might have succeeded.
    except Exception as e_disable_unexpected:
        log.exception(f"API Facade: Unexpected error from scheduler.disable_scheduling during manual mode: {e_disable_unexpected}")

    # apply_appearance_ok is True if desktop_manager.apply_manual_mode didn't raise an error
    return apply_appearance_ok

def set_default_from_current(mode: str) -> bool:
    """API Façade: Saves current desktop settings as default via desktop_manager."""
    log.info(f"API Facade: Calling desktop_manager.set_defaults_from_current for mode '{mode}'.")
    return desktop_manager.set_defaults_from_current(mode)


# --- INTERNAL COMMAND HANDLERS FAÇADE (via desktop_manager) ---
# These are called by the CLI for systemd service execution.

def handle_internal_apply(mode: str) -> bool:
    """API Façade: Relays to desktop_manager.handle_internal_apply."""
    log.debug(f"API Facade: Relaying 'internal-apply --mode {mode}' to desktop_manager.")
    return desktop_manager.handle_internal_apply(mode)

def handle_run_login_check() -> bool:
    """API Façade: Relays to desktop_manager.handle_run_login_check."""
    log.debug("API Facade: Relaying 'run-login-check' to desktop_manager.")
    return desktop_manager.handle_run_login_check()
        

# --- STATUS FUNCTION (Remains in api.py as it aggregates from multiple sources) ---
def get_status() -> dict[str, Any]:
    """Retrieves the current status of fluxfce."""
    log.debug("API: Getting status...")
    status: dict[str, Any] = {
        "config": {},
        "sun_times": {"sunrise": None, "sunset": None, "error": None},
        "current_period": "unknown",
        "schedule": {"error": None, "timers": {}},
        "systemd_services": {"error": None},
    }

    # 1. Get Config
    try:
        config_obj = get_current_config()
        status["config"]["latitude"] = config_obj.get("Location", "LATITUDE", fallback="Not Set")
        status["config"]["longitude"] = config_obj.get("Location", "LONGITUDE", fallback="Not Set")
        status["config"]["timezone"] = config_obj.get("Location", "TIMEZONE", fallback="Not Set")
        status["config"]["light_theme"] = config_obj.get("Themes", "LIGHT_THEME", fallback="Not Set")
        status["config"]["dark_theme"] = config_obj.get("Themes", "DARK_THEME", fallback="Not Set")
    except exc.FluxFceError as e: # Catch errors from get_current_config()
        status["config"]["error"] = str(e)
        log.error(f"API Status: Error loading config for status: {e}")


    # 2. Calculate Sun Times & Current Period
    # This part relies on config being loaded.
    if "error" not in status["config"]: # Only proceed if config was loaded
        lat_str = status["config"]["latitude"]
        lon_str = status["config"]["longitude"]
        tz_name = status["config"]["timezone"]
        
        if all([lat_str, lon_str, tz_name, 
                lat_str != "Not Set", lon_str != "Not Set", tz_name != "Not Set"]):
            try:
                # Option 1: Re-use logic from desktop_manager if determine_current_period is there
                # current_period = desktop_manager.determine_current_period(config_obj)
                # status["current_period"] = current_period
                # # Need to get sun_times separately if determine_current_period doesn't return them
                # lat = helpers.latlon_str_to_float(lat_str)
                # lon = helpers.latlon_str_to_float(lon_str)
                # tz_info = ZoneInfo(tz_name)
                # today = datetime.now(tz_info).date()
                # sun_times_today = sun.get_sun_times(lat, lon, today, tz_name)
                # status["sun_times"]["sunrise"] = sun_times_today["sunrise"]
                # status["sun_times"]["sunset"] = sun_times_today["sunset"]

                # Option 2: Keep logic here for now (as in codebase.txt)
                lat = helpers.latlon_str_to_float(lat_str)
                lon = helpers.latlon_str_to_float(lon_str)
                tz_info = ZoneInfo(tz_name)
                now_local = datetime.now(tz_info)
                today = now_local.date()
                sun_times_today = sun.get_sun_times(lat, lon, today, tz_name)
                status["sun_times"]["sunrise"] = sun_times_today["sunrise"]
                status["sun_times"]["sunset"] = sun_times_today["sunset"]
                status["current_period"] = "day" if sun_times_today["sunrise"] <= now_local < sun_times_today["sunset"] else "night"

            except (exc.ValidationError, exc.CalculationError, ZoneInfoNotFoundError) as e_sun:
                status["sun_times"]["error"] = str(e_sun)
                status["current_period"] = "error (sun calculation/config)"
                log.warning(f"API Status: Error calculating sun times/period: {e_sun}")
            except Exception as e_sun_unexpected: 
                log.exception("API Status: Unexpected error calculating sun times/period.")
                status["sun_times"]["error"] = f"Unexpected error in sun times: {e_sun_unexpected}"
                status["current_period"] = "error (unexpected)"
        else:
            status["sun_times"]["error"] = "Location/Timezone not fully configured."
            status["current_period"] = "unknown (config incomplete)"
    else: # Config loading error
        status["sun_times"]["error"] = "Cannot calculate sun times (config error)."
        status["current_period"] = "unknown (config error)"
    
    # 3. Get Systemd Timer Schedule Status
    timer_names_to_query = [
        sysd.SCHEDULER_TIMER_NAME,
        sysd.SUNRISE_EVENT_TIMER_NAME,
        sysd.SUNSET_EVENT_TIMER_NAME,
    ]
    try:
        code, stdout_timers, stderr_timers = _sysd_mgr_api._run_systemctl(
            ["list-timers", "--all", *timer_names_to_query],
            check_errors=False, capture_output=True
        )
        
        if code != 0 and not ("0 timers listed." in stdout_timers or "No timers found." in stdout_timers):
            err_msg = f"Failed to list systemd timers (code {code}): {stderr_timers.strip() or stdout_timers.strip()}"
            status["schedule"]["error"] = err_msg
            log.warning(f"API Status: {err_msg}")
        
        if stdout_timers:
            parsed_timers = {}
            lines = stdout_timers.strip().split('\n')
            # Check if there's a header and at least one data line
            if len(lines) > 1 and "NEXT" in lines[0].upper():
                header_line = lines[0].upper()
                col_indices = {
                    "NEXT": header_line.find("NEXT"), "LEFT": header_line.find("LEFT"),
                    "LAST": header_line.find("LAST"), "PASSED": header_line.find("PASSED"),
                    "UNIT": header_line.find("UNIT"), "ACTIVATES": header_line.find("ACTIVATES"),
                }
                # Filter out columns not found and sort them by their start index
                sorted_cols = sorted([(name, idx) for name, idx in col_indices.items() if idx != -1], key=lambda item: item[1])

                for line_content in lines[1:]: # Skip header line
                    if not line_content.strip() or not any(tn in line_content for tn in timer_names_to_query):
                        continue # Skip empty lines or lines not containing our timer names
                    
                    timer_data_raw = {}
                    current_unit_name = "" # Initialize
                    
                    # Parse line based on detected column positions
                    for i, (col_name, start_idx) in enumerate(sorted_cols):
                        end_idx = sorted_cols[i+1][1] if i + 1 < len(sorted_cols) else len(line_content)
                        field_value = line_content[start_idx:end_idx].strip()
                        timer_data_raw[col_name.lower()] = field_value
                        if col_name == "UNIT": 
                            current_unit_name = field_value
                    
                    if current_unit_name and current_unit_name in timer_names_to_query:
                        is_enabled_code, _, _ = _sysd_mgr_api._run_systemctl(["is-enabled", current_unit_name], check_errors=False, capture_output=True)
                        is_active_code, _, _ = _sysd_mgr_api._run_systemctl(["is-active", current_unit_name], check_errors=False, capture_output=True)
                        
                        parsed_timers[current_unit_name] = {
                            "enabled": "Enabled" if is_enabled_code == 0 else "Disabled",
                            "active": "Active" if is_active_code == 0 else "Inactive",
                            "next_run": timer_data_raw.get("next", "N/A"),
                            "time_left": timer_data_raw.get("left", "N/A"),
                            "last_run": timer_data_raw.get("last", "N/A"),
                            "activates": timer_data_raw.get("activates", "N/A")
                        }
            
            status["schedule"]["timers"] = parsed_timers
            if not parsed_timers and not status["schedule"].get("error"):
                msg_no_timers = "No relevant fluxfce timers found or listed by systemctl."
                if "0 timers listed." in stdout_timers or "No timers found." in stdout_timers:
                    status["schedule"]["info"] = msg_no_timers
                # else if stdout_timers is not empty but parsing yielded nothing, it's also "not found" effectively
                elif stdout_timers.strip() and not lines[0].upper().startswith("NEXT"): # Handle cases where output is not the expected table
                    status["schedule"]["info"] = f"Unexpected timer listing format. Output: {stdout_timers[:100]}..."
                else: # Default "not found" if truly empty or parsing fails
                    status["schedule"]["info"] = msg_no_timers


    except Exception as e_timers:
        log.exception("API Status: Unexpected error getting systemd timer schedule status.")
        status["schedule"]["error"] = f"Unexpected error querying timers: {e_timers}"

    # 4. Get Systemd Service Status
    services_to_check = {
        "scheduler_service": sysd.SCHEDULER_SERVICE_NAME,
        "login_service": sysd.LOGIN_SERVICE_NAME,
        "resume_service": sysd.RESUME_SERVICE_NAME,
    }
    any_service_error_occurred = False
    for key, unit_name in services_to_check.items():
        try:
            enabled_code, _, _ = _sysd_mgr_api._run_systemctl(["is-enabled", unit_name], check_errors=False, capture_output=True)
            active_code, _, _ = _sysd_mgr_api._run_systemctl(["is-active", unit_name], check_errors=False, capture_output=True)
            status["systemd_services"][key] = f"{'Enabled' if enabled_code == 0 else 'Disabled'}, {'Active' if active_code == 0 else 'Inactive'}"
        except exc.SystemdError as e_svc: # This should ideally not be hit if _run_systemctl handles its errors
            status["systemd_services"][key] = f"Error checking ({unit_name}): {e_svc}"
            any_service_error_occurred = True
            log.warning(f"API Status: SystemdError checking service {unit_name}: {e_svc}")
        except Exception as e_svc_unexpected:
            log.exception(f"API Status: Unexpected error getting status for service {unit_name}")
            status["systemd_services"][key] = f"Unexpected error checking {unit_name}"
            any_service_error_occurred = True
            
    if any_service_error_occurred and not status["systemd_services"].get("error"): # Add a general error if specific one wasn't set
        status["systemd_services"]["error"] = "One or more services could not be checked reliably."
            
    return status
    
##############
fluxfce_core/config.py

# ~/dev/fluxfce-simplified/fluxfce_core/config.py
"""
Configuration management for FluxFCE.

This module handles the loading, saving, and default value application
for FluxFCE's configuration file (`config.ini`). It defines the
structure of the default configuration and provides the ConfigManager
class to interact with configuration settings.
"""

import configparser
import logging
import pathlib

# typing.Dict and typing.Optional will be flagged by ruff (UP006/UP007/UP035)
# and can be changed to dict and | None (or just Optional if Python < 3.10 for return only)
# For now, keeping them as per original file for direct comparison of state file removal.
from typing import Optional

# Import custom exceptions from within the same package
from .exceptions import (
    ConfigError,
)  # ValidationError is not used in this file after changes

log = logging.getLogger(__name__)

# --- Constants ---
APP_NAME = "fluxfce"
CONFIG_DIR = pathlib.Path.home() / ".config" / APP_NAME
CONFIG_FILE = CONFIG_DIR / "config.ini"
# STATE_FILE constant removed

# Default configuration values
DEFAULT_CONFIG: dict[str, dict[str, str]] = (
    {  # Ruff will suggest: dict[str, dict[str, str]]
        "Location": {
            "LATITUDE": "43.65N",  # Toronto Latitude (Example)
            "LONGITUDE": "79.38W",  # Toronto Longitude (Example)
            "TIMEZONE": "America/Toronto",  # IANA Timezone Name
        },
        "Themes": {
            "LIGHT_THEME": "Arc-Lighter",
            "DARK_THEME": "Materia-dark-compact",
        },
        "BackgroundDay": {
            "BG_HEX1": "ADD8E6",
            "BG_HEX2": "87CEEB",
            "BG_DIR": "v",
        },
        "ScreenDay": {
            "XSCT_TEMP": "6500",  # Typically reset, but provide a default value
            "XSCT_BRIGHT": "1.0",  # Typically reset, but provide a default value
        },
        "BackgroundNight": {
            "BG_HEX1": "1E1E2E",
            "BG_HEX2": "000000",
            "BG_DIR": "v",
        },
        "ScreenNight": {
            "XSCT_TEMP": "4500",
            "XSCT_BRIGHT": "0.85",
        },
    }
)


# --- Configuration Manager ---


class ConfigManager:
    """Handles reading/writing config.ini."""  # Docstring updated: "and state file" removed

    def __init__(self):
        """Ensures the configuration directory exists."""
        try:
            CONFIG_DIR.mkdir(parents=True, exist_ok=True)
            log.debug(f"Configuration directory ensured: {CONFIG_DIR}")
        except OSError as e:
            # This is potentially serious, raise it.
            raise ConfigError(
                f"Failed to create configuration directory {CONFIG_DIR}: {e}"
            ) from e

    def _load_ini(self, file_path: pathlib.Path) -> configparser.ConfigParser:
        """Loads an INI file, returning a ConfigParser object."""
        parser = configparser.ConfigParser()
        if file_path.exists():
            try:
                # Handle potential empty file
                if file_path.stat().st_size > 0:
                    read_files = parser.read(file_path, encoding="utf-8")
                    if not read_files:
                        log.warning(
                            f"Config file {file_path} was reported as read, but might be empty or unparseable by configparser."
                        )
                    else:
                        log.debug(f"Loaded config from {file_path}")
                else:
                    log.warning(f"Config file {file_path} is empty.")
            except configparser.Error as e:
                # Raise specific error for parsing issues
                raise ConfigError(
                    f"Could not parse config file {file_path}: {e}"
                ) from e
            except (
                OSError
            ) as e:  # Changed from IOError to OSError for broader catch, though read_text uses OSError
                raise ConfigError(f"Could not read config file {file_path}: {e}") from e
        else:
            log.debug(f"Config file {file_path} not found. Returning empty parser.")

        return parser

    def _save_ini(
        self, parser: configparser.ConfigParser, file_path: pathlib.Path
    ) -> bool:
        """Saves a ConfigParser object to an INI file."""
        try:
            with file_path.open("w", encoding="utf-8") as f:
                parser.write(f)
            log.debug(f"Saved configuration to {file_path}")
            return True
        except OSError as e:  # Changed from IOError to OSError for broader catch
            raise ConfigError(
                f"Failed to write configuration to {file_path}: {e}"
            ) from e

    def load_config(self) -> configparser.ConfigParser:
        """
        Loads the main config.ini (config.CONFIG_FILE).

        Applies default values (from config.DEFAULT_CONFIG) for any missing
        sections or keys directly to the returned ConfigParser object.
        It does *not* automatically save the file after applying defaults;
        the caller can modify further and then call save_config.

        Returns:
            A ConfigParser object representing the configuration.

        Raises:
            ConfigError: If the file cannot be read or parsed.
        """
        parser = self._load_ini(CONFIG_FILE)
        # Apply defaults in memory without saving immediately
        made_changes = False
        for section, defaults in DEFAULT_CONFIG.items():
            if not parser.has_section(section):
                parser.add_section(section)
                made_changes = True
                log.debug(f"Added missing section [{section}] to config object")
            for key, value in defaults.items():
                if not parser.has_option(section, key):
                    parser.set(section, key, value)
                    made_changes = True
                    log.debug(
                        f"Added missing key '{key}' = '{value}' to section [{section}] in config object"
                    )

        if made_changes:
            log.info("Default values applied in memory to the loaded configuration.")
            # Caller must call save_config explicitly if they want to persist these defaults

        return parser

    def save_config(self, config: configparser.ConfigParser) -> bool:
        """
        Saves the provided ConfigParser object to the main config.ini file.

        Args:
            config: The ConfigParser object to save.

        Returns:
            True if saving was successful.

        Raises:
            ConfigError: If the file cannot be written.
        """
        log.info(f"Saving configuration to {CONFIG_FILE}")
        return self._save_ini(config, CONFIG_FILE)

    # --- Presets Removed ---

    def get_setting(
        self,
        config: configparser.ConfigParser,
        section: str,
        key: str,
        default: Optional[str] = None,  # Ruff will suggest: str | None = None
    ) -> Optional[str]:  # Ruff will suggest: str | None
        """Gets a setting value from a ConfigParser object."""
        # Uses configparser's fallback mechanism
        return config.get(section, key, fallback=default)

    def set_setting(
        self, config: configparser.ConfigParser, section: str, key: str, value: str
    ):
        """
        Sets a setting value in a ConfigParser object.
        Creates the section if it doesn't exist.
        """
        if not config.has_section(section):
            log.debug(
                f"Adding section [{section}] to config object for setting key '{key}'"
            )
            config.add_section(section)
        log.debug(f"Setting [{section}] {key} = '{value}' in config object")
        config.set(section, key, value)

##############
fluxfce_core/desktop_manager.py

# fluxfce_core/desktop_manager.py
"""
High-level desktop-appearance operations for FluxFCE.

This module is **UI-only**: it never touches systemd or the filesystem
outside XFCE/XSCT calls.  All public call-sites previously lived in
`api.py`; moving them here breaks the monolith and enables focused tests.

Author: <you>
"""

from __future__ import annotations

import logging
from datetime import datetime
from typing import Literal, Optional

from . import config as cfg
from . import helpers, xfce
from .exceptions import ConfigError, FluxFceError, ValidationError, XfceError

log = logging.getLogger(__name__)

# Module-level ConfigManager instance for desktop operations
_cfg_mgr_desktop = cfg.ConfigManager()

# --------------------------------------------------------------------------- #
# private helpers
# --------------------------------------------------------------------------- #

def handle_internal_apply(mode: Literal["day", "night"]) -> bool:
    """
    Called by systemd (fluxfce-apply-transition@.service) to apply mode.
    Uses this module's public apply_mode function.
    """
    log.info(f"DesktopManager: Internal apply called for mode '{mode}' by systemd.")
    try:
        # Calls the public apply_mode from this same module
        return apply_mode(mode) 
    except FluxFceError as e: # Catch specific FluxFceErrors that apply_mode might re-raise
        log.error(f"DesktopManager: Error during internal apply for mode '{mode}': {e}")
        return False
    except Exception as e: # Catch any other unexpected errors
        log.exception(f"DesktopManager: Unexpected error during internal apply for mode '{mode}': {e}")
        return False

def handle_run_login_check() -> bool:
    """
    Called by systemd (fluxfce-login.service, fluxfce-resume.service)
    and by API's enable_scheduling.
    Determines current solar period and applies appropriate theme settings.
    """
    log.info("DesktopManager: Handling 'run-login-check' command (login/resume/enable)...")
    
    # Load configuration using this module's helper
    conf = _load_cfg() 
    
    # Determine current period using this module's helper
    # Pass the already loaded config object to it.
    mode_to_apply = determine_current_period(conf) 
    
    log.info(f"DesktopManager: Login/Resume/Enable check determined mode '{mode_to_apply}'. Applying now.")
    try:
        # Calls the public apply_mode from this same module
        return apply_mode(mode_to_apply)
    except FluxFceError as e: # Catch specific FluxFceErrors
        log.error(f"DesktopManager: Error during 'run-login-check' applying mode '{mode_to_apply}': {e}")
        return False
    except Exception as e: 
        log.exception(f"DesktopManager: Unexpected error during 'run-login-check' applying mode '{mode_to_apply}': {e}")
        return False

def _load_cfg() -> cfg.configparser.ConfigParser:
    """Return the current config (with in-memory defaults) using the module-level manager."""
    return _cfg_mgr_desktop.load_config()


def _settings_from_cfg(
    mode: Literal["day", "night"],
    conf: cfg.configparser.ConfigParser,
) -> dict[str, str | None]:
    """Collect everything the desktop needs for *one* mode."""
    theme_key = "LIGHT_THEME" if mode == "day" else "DARK_THEME"
    bg_section = "BackgroundDay" if mode == "day" else "BackgroundNight"
    screen_section = "ScreenDay" if mode == "day" else "ScreenNight"

    return {
        "theme": conf.get("Themes", theme_key, fallback=None),
        "bg_hex1": conf.get(bg_section, "BG_HEX1", fallback=None),
        "bg_hex2": conf.get(bg_section, "BG_HEX2", fallback=None),
        "bg_dir": conf.get(bg_section, "BG_DIR", fallback=None),
        "xsct_temp": conf.get(screen_section, "XSCT_TEMP", fallback=None),
        "xsct_bright": conf.get(screen_section, "XSCT_BRIGHT", fallback=None),
    }


def _apply_single_mode(mode: Literal["day", "night"]) -> bool:
    """Low-level worker that performs *all* appearance changes."""
    xfce_handler = xfce.XfceHandler()
    conf = _load_cfg()
    s = _settings_from_cfg(mode, conf)

    if not s["theme"]:
        raise ConfigError(f"Theme for mode '{mode}' is not configured.")

    # -- GTK theme -----------------------------------------------------------
    xfce_handler.set_gtk_theme(s["theme"])

    # -- Background ----------------------------------------------------------
    if s["bg_hex1"] and s["bg_dir"]:
        xfce_handler.set_background(s["bg_hex1"], s["bg_hex2"], s["bg_dir"])
    else:
        log.info("Background not configured — skipping.")

    # -- Screen temperature / brightness -------------------------------------
    try:
        temp = int(s["xsct_temp"]) if s["xsct_temp"] else None
        bright = float(s["xsct_bright"]) if s["xsct_bright"] else None
    except ValueError as e:
        log.warning("Invalid xsct values in config: %s", e)
        temp = bright = None

    xfce_handler.set_screen_temp(temp, bright)
    return True


# --------------------------------------------------------------------------- #
# public API
# --------------------------------------------------------------------------- #


def apply_mode(mode: Literal["day", "night"]) -> bool:
    """
    Apply **Day** or **Night** appearance immediately.

    Re-raises fatal errors so the caller/CLI can exit non-zero.
    """
    if mode not in ("day", "night"):
        raise ValidationError(f"Invalid mode '{mode}'.")
    log.info("Applying %s mode …", mode)
    return _apply_single_mode(mode)


def set_defaults_from_current(mode: Literal["day", "night"]) -> bool:
    """
    Save the *current* XFCE look as the new default for *mode*.

    This does **not** modify the desktop; only the configuration file.
    """
    xfce_handler = xfce.XfceHandler()
    # Use the module-level ConfigManager instance
    conf = _load_cfg() 

    bg_section_name = "BackgroundDay" if mode == "day" else "BackgroundNight"

    # Load current background settings from config for the given mode
    current_config_bg = {
        "hex1": conf.get(bg_section_name, "BG_HEX1", fallback=None),
        "hex2": conf.get(bg_section_name, "BG_HEX2", fallback=None),
        "dir": conf.get(bg_section_name, "BG_DIR", fallback=None)
    }

    # read current desktop ---------------------------------------------------
    theme = xfce_handler.get_gtk_theme()
    bg = xfce_handler.get_background_settings(current_config_bg=current_config_bg)  # may raise XfceError
    screen = xfce_handler.get_screen_settings()

    theme_key = "LIGHT_THEME" if mode == "day" else "DARK_THEME"
    # bg_section_name is already defined above
    screen_section = "ScreenDay" if mode == "day" else "ScreenNight"

    changed = False
    if conf.get("Themes", theme_key, fallback="") != theme:
        _cfg_mgr_desktop.set_setting(conf, "Themes", theme_key, theme)
        changed = True

    if bg:
        for src, dst in (("dir", "BG_DIR"), ("hex1", "BG_HEX1"), ("hex2", "BG_HEX2")):
            if conf.get(bg_section_name, dst, fallback="") != (bg[src] or ""): # Use bg_section_name
                _cfg_mgr_desktop.set_setting(conf, bg_section_name, dst, bg[src] or "") # Use bg_section_name
                changed = True

    if screen:
        new_temp = "" if screen["temperature"] is None else str(screen["temperature"])
        new_bri = "" if screen["brightness"] is None else f"{screen['brightness']:.2f}"
        if conf.get(screen_section, "XSCT_TEMP", fallback="") != new_temp:
            _cfg_mgr_desktop.set_setting(conf, screen_section, "XSCT_TEMP", new_temp)
            changed = True
        if conf.get(screen_section, "XSCT_BRIGHT", fallback="") != new_bri:
            _cfg_mgr_desktop.set_setting(conf, screen_section, "XSCT_BRIGHT", new_bri)
            changed = True

    if changed:
        log.info("Desktop defaults updated for %s mode — saving config.ini", mode)
        return _cfg_mgr_desktop.save_config(conf)
    log.info("Configuration already matches the current desktop; nothing to do.")
    return True


def determine_current_period(conf: cfg.configparser.ConfigParser) -> Literal["day", "night"]:
    """
    Cheap helper shared by status & login-check code.

    Returns `"day"` if *now* is between sunrise and sunset for the configured
    coordinates, otherwise `"night"`.  Falls back to `"night"` on errors.
    """
    from zoneinfo import ZoneInfo  # local import to avoid module cost at import-time
    from . import sun

    try:
        lat = helpers.latlon_str_to_float(conf.get("Location", "LATITUDE"))
        lon = helpers.latlon_str_to_float(conf.get("Location", "LONGITUDE"))
        tz = conf.get("Location", "TIMEZONE")
        tzinfo = ZoneInfo(tz)
        now = datetime.now(tzinfo)
        today = now.date()
        times = sun.get_sun_times(lat, lon, today, tz)
    except Exception as e:
        log.warning("Cannot compute current period (%s) — assuming night.", e)
        return "night"

    return "day" if times["sunrise"] <= now < times["sunset"] else "night"

##############
fluxfce_core/exceptions.py

# fluxfce_core/exceptions.py
"""
Custom exception classes for the FluxFCE core library.

These exceptions provide more specific error information than built-in
exceptions, allowing for more targeted error handling by callers.
All custom exceptions inherit from the base `FluxFceError`.
"""
class FluxFceError(Exception):
    """Base exception for fluxfce core errors."""

    pass


class ConfigError(FluxFceError):
    """Errors related to configuration loading, saving, or validation."""

    pass


class CalculationError(FluxFceError):
    """Errors during sunrise/sunset calculation."""

    pass


class XfceError(FluxFceError):
    """Errors interacting with xfconf-query or xsct."""

    pass


class SchedulerError(FluxFceError):
    """Errors interacting with atd (at, atq, atrm)."""

    pass


class SystemdError(FluxFceError):
    """Errors interacting with systemctl."""

    pass


class DependencyError(FluxFceError):
    """Errors due to missing external command dependencies."""

    pass


class ValidationError(FluxFceError):
    """Errors for invalid user input or data formats."""

    pass

##############
fluxfce_core/helpers.py

# ~/dev/fluxfce-simplified/fluxfce_core/helpers.py
"""
Utility functions for the FluxFCE core library.

This module provides a collection of helper functions used by other
modules within `fluxfce_core`. These include utilities for:
- Running external commands.
- Checking for system dependencies.
- Detecting the system's IANA timezone.
- Validating and converting data (e.g., coordinates, hex colors).
- Basic library logging setup.
"""

import logging
import os
import pathlib
import re
import shutil
import subprocess
from typing import Optional

try:
    from zoneinfo import ZoneInfo, ZoneInfoNotFoundError
except ImportError:
    raise ImportError(
        "Required module 'zoneinfo' not found. FluxFCE requires Python 3.9+."
    )
# Import custom exceptions from within the same package
from .exceptions import DependencyError, FluxFceError, ValidationError

# Setup a logger specific to this module for internal debugging
log = logging.getLogger(__name__)

# --- Command Execution ---


def run_command(
    cmd_list: list[str],
    check: bool = False,
    capture: bool = True,
    input_str: Optional[str] = None,
) -> tuple[int, str, str]:
    """
    Runs an external command and returns its status, stdout, and stderr.

    Args:
        cmd_list: The command and its arguments as a list of strings.
        check: If True, raise CalledProcessError if the command returns non-zero.
               (Note: Generally, we'll use check=False and handle errors based
               on the return code in the calling function for more specific
               exception types).
        capture: If True (default), capture stdout and stderr. If False, they are
                 not captured (sent to system stdout/stderr).
        input_str: Optional string to pass as standard input to the command.

    Returns:
        A tuple containing: (return_code, stdout_str, stderr_str).
        stdout_str and stderr_str will be empty if capture=False.

    Raises:
        FileNotFoundError: If the command executable is not found.
        subprocess.CalledProcessError: If check=True and the command fails.
        Exception: For other unexpected subprocess errors.
    """
    log.debug(f"Running command: {' '.join(cmd_list)}")
    stdout_pipe = subprocess.PIPE if capture else None
    stderr_pipe = subprocess.PIPE if capture else None

    try:
        process = subprocess.run(
            cmd_list,
            check=check,  # Let CalledProcessError be raised if check is True
            input=input_str,
            stdout=stdout_pipe,
            stderr=stderr_pipe,
            text=True,
            encoding="utf-8",
        )
        stdout = process.stdout.strip() if process.stdout and capture else ""
        stderr = process.stderr.strip() if process.stderr and capture else ""
        log.debug(f"Command '{cmd_list[0]}' finished with code {process.returncode}")
        if stdout and capture:
            log.debug(f"stdout: {stdout[:200]}...")  # Log truncated stdout
        if stderr and capture:
            log.debug(f"stderr: {stderr[:200]}...")  # Log truncated stderr
        return process.returncode, stdout, stderr
    except FileNotFoundError as e:
        # This specific error is often critical and worth propagating
        log.error(f"Command not found: {cmd_list[0]} - {e}")
        raise FileNotFoundError(
            f"Required command '{cmd_list[0]}' not found in PATH."
        ) from e
    except subprocess.CalledProcessError as e:
        # Log details if check=True caused the exception
        # The caller should handle this if check=True was intentional
        stdout = e.stdout.strip() if e.stdout and capture else ""
        stderr = e.stderr.strip() if e.stderr and capture else ""
        log.warning(
            f"Command failed with exit code {e.returncode}: {' '.join(cmd_list)}"
        )
        if stdout:
            log.warning(f"stdout: {stdout[:200]}...")
        if stderr:
            log.warning(f"stderr: {stderr[:200]}...")
        raise  # Re-raise the original exception if check=True
    except Exception as e:
        log.exception(
            f"An unexpected error occurred running command: {' '.join(cmd_list)} - {e}"
        )
        # Wrap unexpected errors in our base exception type
        raise FluxFceError(
            f"Unexpected error running command '{cmd_list[0]}': {e}"
        ) from e


# --- Dependency Checks ---


def check_dependencies(deps: list[str]) -> bool:
    """
    Checks if required external commands exist in PATH using shutil.which.

    Args:
        deps: A list of command names to check (e.g., ['xfconf-query', 'xsct']).

    Returns:
        True if all dependencies are found.

    Raises:
        DependencyError: If one or more dependencies are not found.
    """
    log.debug(f"Checking for dependencies: {', '.join(deps)}")
    missing = []
    for dep in deps:
        if shutil.which(dep) is None:  # shutil.which returns None if not found
            missing.append(dep)

    if missing:
        error_msg = (
            f"Missing required command(s): {', '.join(missing)}. Please install them."
        )
        log.error(error_msg)
        raise DependencyError(error_msg)

    log.debug(f"All dependencies checked successfully: {', '.join(deps)}")
    return True


def check_atd_service() -> bool:
    """
    Checks if the 'atd' service appears to be running via systemctl.

    Returns:
        True if the service is detected as active.

    Raises:
        DependencyError: If 'systemctl' command is not found.
        FluxFceError: For unexpected errors during the check or if the
                      service is confirmed not to be active.
    """
    log.debug("Checking if atd service is active...")
    # Ensure systemctl exists first
    check_dependencies(["systemctl"])

    try:
        # Check system service first
        code_sys, _, err_sys = run_command(
            ["systemctl", "is-active", "--quiet", "atd.service"]
        )
        # --quiet: return code 0 for active, non-zero otherwise (usually 3 for inactive)

        if code_sys == 0:
            log.debug("System 'atd' service reported as active.")
            return True

        log.debug(
            f"System 'atd' not active (code: {code_sys}). Checking user service..."
        )
        # Check user service as fallback (less common for atd)
        code_user, _, err_user = run_command(
            ["systemctl", "--user", "is-active", "--quiet", "atd.service"]
        )

        if code_user == 0:
            log.debug("User 'atd' service reported as active.")
            return True

        # If neither is active
        error_msg = "The 'atd' service (system or user) is not active. Automatic scheduling requires 'atd'. Please install and enable it (e.g., 'sudo systemctl enable --now atd')."
        log.error(error_msg)
        # Use FluxFceError as it's a runtime state issue, not a missing binary
        raise FluxFceError(error_msg)

    except (
        FileNotFoundError
    ):  # Should be caught by check_dependencies, but belts and suspenders
        raise DependencyError(
            "The 'systemctl' command was not found, cannot check 'atd' status."
        )
    except Exception as e:
        # Catch potential errors from run_command itself or re-raised CalledProcessError
        log.exception(f"Failed to check 'atd' status: {e}")
        raise FluxFceError(f"Failed to check 'atd' status: {e}") from e


# --- Detect timezone ---
def detect_system_timezone() -> Optional[str]:
    """
    Attempts to detect the system's configured IANA timezone name.

    Tries methods in order: TZ env var, timedatectl, /etc/localtime symlink, /etc/timezone file.

    Returns:
        The detected IANA timezone name (str) if found and valid, otherwise None.
    """
    log.debug("Attempting to detect system timezone...")

    def _is_valid_timezone(tz_name: Optional[str]) -> bool:
        """Helper to validate a potential timezone name."""
        if not tz_name or not isinstance(tz_name, str):
            return False
        try:
            ZoneInfo(tz_name)
            log.debug(f"Validated timezone '{tz_name}' successfully.")
            return True
        except ZoneInfoNotFoundError:
            log.debug(f"ZoneInfoNotFoundError for '{tz_name}'.")
            return False
        except Exception as e:
            log.warning(f"Error validating timezone '{tz_name}' with ZoneInfo: {e}")
            return False

    # 1. Check TZ environment variable first (overrides system settings)
    tz_env = os.environ.get("TZ")
    if tz_env:
        tz_env_cleaned = tz_env.lstrip(":")
        log.debug(
            f"Found TZ environment variable: '{tz_env}' (cleaned: '{tz_env_cleaned}')"
        )
        if _is_valid_timezone(tz_env_cleaned):
            log.info(f"Using timezone from TZ environment variable: {tz_env_cleaned}")
            return tz_env_cleaned
        else:
            log.warning(
                f"TZ environment variable ('{tz_env}') is set but not a valid timezone name."
            )

    # 2. Try timedatectl (systemd)
    try:
        check_dependencies(["timedatectl"])  # Check if command exists
        cmd = ["timedatectl", "show", "--property=Timezone", "--value"]
        code, stdout, stderr = run_command(cmd)
        if code == 0 and stdout:
            tz_name = stdout.strip()
            log.debug(f"timedatectl returned: '{tz_name}'")
            if _is_valid_timezone(tz_name):
                log.info(f"Detected timezone via timedatectl: {tz_name}")
                return tz_name
            else:
                log.warning(f"timedatectl returned invalid timezone: '{tz_name}'")
        else:
            log.debug(f"timedatectl command failed or returned empty (code: {code})")
    except DependencyError:
        log.debug("timedatectl command not found, skipping.")
    except Exception as e:
        log.warning(f"Error running timedatectl: {e}")

    # 3. Try /etc/localtime symlink
    localtime_path = pathlib.Path("/etc/localtime")
    if localtime_path.is_symlink():
        try:
            target = localtime_path.readlink()  # Read the target path object
            zoneinfo_dir = pathlib.Path("/usr/share/zoneinfo")
            if not target.is_absolute():
                target = (localtime_path.parent / target).resolve()
            if zoneinfo_dir in target.parents or str(target).startswith(
                str(zoneinfo_dir)
            ):
                try:
                    tz_name = str(target.relative_to(zoneinfo_dir))
                    log.debug(
                        f"/etc/localtime points to '{target}', relative zoneinfo path: '{tz_name}'"
                    )
                    if _is_valid_timezone(tz_name):
                        log.info(
                            f"Detected timezone via /etc/localtime symlink: {tz_name}"
                        )
                        return tz_name
                    else:
                        log.warning(
                            f"Extracted path '{tz_name}' from /etc/localtime link is not a valid timezone."
                        )
                except ValueError:
                    log.warning(
                        f"Could not determine relative path for localtime target '{target}' within '{zoneinfo_dir}'."
                    )
            else:
                log.debug(
                    f"/etc/localtime target '{target}' is outside standard zoneinfo directory."
                )
        except OSError as e:
            log.warning(f"Could not read /etc/localtime symlink: {e}")
        except Exception as e:
            log.exception(f"Unexpected error processing /etc/localtime link: {e}")

    # 4. Try /etc/timezone file (Debian/Ubuntu)
    timezone_path = pathlib.Path("/etc/timezone")
    if timezone_path.is_file():
        try:
            content = timezone_path.read_text(encoding="utf-8").strip()
            if content:
                tz_name = content.splitlines()[0].split()[0]
                log.debug(f"Read from /etc/timezone: '{tz_name}'")
                if _is_valid_timezone(tz_name):
                    log.info(f"Detected timezone via /etc/timezone file: {tz_name}")
                    return tz_name
                else:
                    log.warning(
                        f"Content of /etc/timezone ('{tz_name}') is not a valid timezone."
                    )
            else:
                log.debug("/etc/timezone file is empty.")
        except OSError as e:
            log.warning(f"Could not read /etc/timezone: {e}")
        except Exception as e:
            log.exception(f"Unexpected error processing /etc/timezone: {e}")

    # 5. Fallback - Could not detect
    log.warning("Failed to detect system timezone using common methods.")
    return None


# --- Data Validation ---


def latlon_str_to_float(coord_str: str) -> float:
    """
    Converts Lat/Lon string (e.g., '43.65N', '79.38W') to float degrees.

    Args:
        coord_str: The coordinate string to parse.

    Returns:
        The coordinate as a float value.

    Raises:
        ValidationError: If the format is invalid or the value is out of range.
    """
    if not isinstance(coord_str, str):
        raise ValidationError(
            f"Invalid input type for coordinate: expected string, got {type(coord_str)}"
        )

    coord_strip = coord_str.strip().upper()
    match = re.match(r"^(\d+(\.\d+)?)([NSEW])$", coord_strip)
    if not match:
        raise ValidationError(
            f"Invalid coordinate format: '{coord_str}'. Use format like '43.65N' or '79.38W'."
        )

    try:
        value = float(match.group(1))
    except ValueError:
        # Should not happen with the regex, but safeguard
        raise ValidationError(
            f"Could not convert value part '{match.group(1)}' to float."
        )

    direction = match.group(3)
    if direction in ("S", "W"):
        value = -value

    # Range check
    if direction in ("N", "S") and not (-90 <= value <= 90):
        raise ValidationError(
            f"Latitude out of range (-90 to 90): {value} ({coord_str})"
        )
    if direction in ("E", "W") and not (-180 <= value <= 180):
        raise ValidationError(
            f"Longitude out of range (-180 to 180): {value} ({coord_str})"
        )

    log.debug(f"Converted coordinate '{coord_str}' to {value}")
    return value


def hex_to_rgba_doubles(hex_color: str) -> list[float]:
    """
    Converts a 6-digit hex color string (#RRGGBB or RRGGBB) to RGBA doubles
    [R, G, B, A] (0.0-1.0), with Alpha always 1.0.

    Args:
        hex_color: The 6-digit hex color string.

    Returns:
        A list of four floats [R, G, B, A] between 0.0 and 1.0.

    Raises:
        ValidationError: If the hex string format is invalid.
    """
    if not isinstance(hex_color, str):
        raise ValidationError(
            f"Invalid input type for hex color: expected string, got {type(hex_color)}"
        )

    hex_strip = hex_color.lstrip("#")
    if not re.match(r"^[0-9a-fA-F]{6}$", hex_strip):
        raise ValidationError(f"Invalid 6-digit hex color format: '{hex_color}'")

    try:
        r = int(hex_strip[0:2], 16) / 255.0
        g = int(hex_strip[2:4], 16) / 255.0
        b = int(hex_strip[4:6], 16) / 255.0
        rgba = [r, g, b, 1.0]  # R, G, B, Alpha
        log.debug(f"Converted hex '{hex_color}' to RGBA {rgba}")
        return rgba
    except ValueError as e:
        # Should not happen with regex, but safeguard
        raise ValidationError(
            f"Could not convert hex components to integer: '{hex_color}' - {e}"
        ) from e


# --- Logging Setup (Simplified for Core Library) ---


def setup_library_logging(level=logging.WARNING):
    """
    Configures basic logging for the fluxfce_core library components.
    This is primarily intended for internal debugging and might be overridden
    by the calling application (GUI/CLI). By default, sets a higher level
    to avoid polluting the output of the consuming application unless
    debugging is explicitly enabled.
    """
    # Configure logging for the entire 'fluxfce_core' package namespace
    package_logger = logging.getLogger("fluxfce_core")

    # Avoid adding multiple handlers if called repeatedly
    if not package_logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter(
            "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
        )
        handler.setFormatter(formatter)
        package_logger.addHandler(handler)

    package_logger.setLevel(level)
    log.info(f"fluxfce_core logging configured to level: {logging.getLevelName(level)}")


# Example of how to potentially enable debug logging from outside:
# import logging
# from fluxfce_core import helpers
# helpers.setup_library_logging(level=logging.DEBUG)

##############
fluxfce_core/__init__.py

# fluxfce_core/__init__.py

# Make exceptions available directly
from .exceptions import (
    CalculationError,
    ConfigError,
    DependencyError,
    FluxFceError,
    SystemdError,
    ValidationError,
    XfceError,
)

# Make public API functions (now via the api.py facade) available
from .api import (
    apply_manual_mode,
    disable_scheduling,
    enable_scheduling,
    get_current_config,
    get_status,
    handle_internal_apply, # Called by CLI
    handle_run_login_check,    # Called by CLI
    handle_schedule_dynamic_transitions_command, # Called by CLI
    install_fluxfce,
    save_configuration,
    set_default_from_current,
    uninstall_fluxfce,
)

# --- Make core constants accessible ---
from .config import CONFIG_DIR, CONFIG_FILE, DEFAULT_CONFIG # Added DEFAULT_CONFIG for cli.py
from .helpers import detect_system_timezone # If CLI needs it directly

# --- ADD SYSTEMD CONSTANTS ---
from .systemd import (
    LOGIN_SERVICE_NAME,
    RESUME_SERVICE_NAME,
    SCHEDULER_SERVICE_NAME,
    SCHEDULER_TIMER_NAME,
    SUNRISE_EVENT_TIMER_NAME, # For CLI status output if needed
    SUNSET_EVENT_TIMER_NAME,  # For CLI status output if needed
)

__all__ = [
    # Constants from config.py
    "CONFIG_DIR",
    "CONFIG_FILE",
    "DEFAULT_CONFIG",
    # Constants from systemd.py (ensure these are what CLI's print_status needs)
    "LOGIN_SERVICE_NAME",
    "RESUME_SERVICE_NAME",
    "SCHEDULER_SERVICE_NAME",
    "SCHEDULER_TIMER_NAME",
    "SUNRISE_EVENT_TIMER_NAME", # Make available if CLI uses them
    "SUNSET_EVENT_TIMER_NAME",  # Make available if CLI uses them
    # Exceptions
    "CalculationError",
    "ConfigError",
    "DependencyError",
    "FluxFceError",
    "SystemdError",
    "ValidationError",
    "XfceError",
    # API Functions (from api.py facade)
    "apply_manual_mode",
    "disable_scheduling",
    "enable_scheduling",
    "get_current_config",
    "get_status",
    "install_fluxfce",
    "save_configuration",
    "set_default_from_current",
    "uninstall_fluxfce",
    # Internal Handlers (available for CLI, routed through api.py)
    "handle_internal_apply",
    "handle_run_login_check",
    "handle_schedule_dynamic_transitions_command",
    # Helper Functions
    "detect_system_timezone",
]

##############
fluxfce_core/scheduler.py

# fluxfce_core/scheduler.py
"""
Manages Systemd-based scheduling for FluxFCE.

This module handles the creation and management of dynamic systemd timers
for sunrise/sunset events and the main daily scheduler task.
"""

import logging
from datetime import datetime, timedelta
from typing import Optional

# Imports from within fluxfce_core
from . import config as cfg # For get_current_config via _load_config_with_defaults if not passed
from . import exceptions as exc
from . import helpers, sun, systemd as sysd # Use sysd alias for clarity

# For type hinting configparser object if passed directly
import configparser 

# zoneinfo needed for sun time calculations here
try:
    from zoneinfo import (
        ZoneInfo,
        ZoneInfoNotFoundError,
    )
except ImportError:
    raise ImportError(
        "Required module 'zoneinfo' not found. FluxFCE requires Python 3.9+."
    )

log = logging.getLogger(__name__)

# --- Private Helper to Load Config (if needed, similar to desktop_manager) ---
# This assumes we might need to load config if not passed around explicitly
# Or, these functions can be modified to accept a config_obj if preferred
_cfg_mgr_scheduler = cfg.ConfigManager() # Module-level instance

def _load_scheduler_config() -> configparser.ConfigParser:
    """Loads configuration for scheduler functions."""
    # This reuses the existing ConfigManager logic.
    # No need to re-implement _load_config_with_defaults here if it's generic enough.
    # Let's assume get_current_config from api.py (or its future equivalent) is preferred.
    # For now, we'll replicate a simple load for self-containment,
    # but this could be refactored to use a shared config loading utility.
    try:
        return _cfg_mgr_scheduler.load_config()
    except exc.ConfigError as e:
        log.error(f"Scheduler: Failed to load configuration: {e}")
        raise
    except Exception as e:
        log.exception(f"Scheduler: Unexpected error loading configuration: {e}")
        raise exc.FluxFceError(f"Scheduler: Unexpected error loading configuration: {e}") from e

_sysd_mgr_scheduler = sysd.SystemdManager() # Module-level instance for SystemdManager


# --- Scheduling Functions (Moved from api.py) ---

def handle_schedule_dynamic_transitions_command(
    python_exe_path: str, script_exe_path: str
) -> bool:
    """
    Calculates next sun events, writes dynamic systemd timer files, reloads the
    systemd daemon, and starts the dynamic timers.
    Called by the fluxfce-scheduler.service.
    """
    log.info("Scheduler: Handling 'schedule-dynamic-transitions' command...")
    try:
        # current_config = get_current_config() # Original call
        current_config = _load_scheduler_config() # Use local loader or pass config_obj

        lat_str = current_config.get("Location", "LATITUDE")
        lon_str = current_config.get("Location", "LONGITUDE")
        tz_name = current_config.get("Location", "TIMEZONE")

        if not all([lat_str, lon_str, tz_name, 
                    lat_str != "Not Set", lon_str != "Not Set", tz_name != "Not Set"]):
            raise exc.ConfigError("Scheduler: Location (latitude, longitude, timezone) not fully configured.")

        lat = helpers.latlon_str_to_float(lat_str)
        lon = helpers.latlon_str_to_float(lon_str)
        
        try:
            local_tz = ZoneInfo(tz_name)
        except ZoneInfoNotFoundError as e_tz:
            raise exc.ConfigError(f"Scheduler: Invalid timezone in configuration: {tz_name}") from e_tz

        now_local = datetime.now(local_tz)
        today_local = now_local.date()
        next_event_times: dict[str, Optional[datetime]] = {"day": None, "night": None}

        for day_offset in range(2): # Check today and tomorrow
            target_date = today_local + timedelta(days=day_offset)
            try:
                sun_times = sun.get_sun_times(lat, lon, target_date, tz_name)
                if not next_event_times["day"] and sun_times["sunrise"] > now_local:
                    next_event_times["day"] = sun_times["sunrise"]
                if not next_event_times["night"] and sun_times["sunset"] > now_local:
                    next_event_times["night"] = sun_times["sunset"]
            except exc.CalculationError as e:
                log.warning(f"Scheduler: Could not calculate sun times for {target_date}: {e}")
            if next_event_times["day"] and next_event_times["night"]:
                break
        
        _sysd_mgr_scheduler._run_systemctl(
            ["stop", sysd.SUNRISE_EVENT_TIMER_NAME, sysd.SUNSET_EVENT_TIMER_NAME],
            check_errors=False, capture_output=True
        )

        scheduled_any_timer = False
        utc_tz = ZoneInfo("UTC")

        if next_event_times["day"]:
            utc_event_time = next_event_times["day"].astimezone(utc_tz)
            _sysd_mgr_scheduler.write_dynamic_event_timer_unit_file("day", utc_event_time)
            scheduled_any_timer = True
            log.info(f"Scheduler: Dynamic timer for SUNRISE prepared for: {utc_event_time.isoformat()}")
        else:
            log.warning("Scheduler: No upcoming sunrise event found. Removing existing timer if any.")
            (sysd.SYSTEMD_USER_DIR / sysd.SUNRISE_EVENT_TIMER_NAME).unlink(missing_ok=True)

        if next_event_times["night"]:
            utc_event_time = next_event_times["night"].astimezone(utc_tz)
            _sysd_mgr_scheduler.write_dynamic_event_timer_unit_file("night", utc_event_time)
            scheduled_any_timer = True
            log.info(f"Scheduler: Dynamic timer for SUNSET prepared for: {utc_event_time.isoformat()}")
        else:
            log.warning("Scheduler: No upcoming sunset event found. Removing existing timer if any.")
            (sysd.SYSTEMD_USER_DIR / sysd.SUNSET_EVENT_TIMER_NAME).unlink(missing_ok=True)

        _sysd_mgr_scheduler._run_systemctl(["daemon-reload"], capture_output=True)

        if next_event_times["day"]:
            _sysd_mgr_scheduler._run_systemctl(["start", sysd.SUNRISE_EVENT_TIMER_NAME], check_errors=False, capture_output=True)
        if next_event_times["night"]:
            _sysd_mgr_scheduler._run_systemctl(["start", sysd.SUNSET_EVENT_TIMER_NAME], check_errors=False, capture_output=True)
        
        if not scheduled_any_timer:
            log.warning("Scheduler: No sun event timers could be scheduled (e.g. polar day/night).")
        else:
            log.info("Scheduler: Dynamic event timers (re)written, daemon reloaded, and timers (re)started.")
        return True

    except (exc.ConfigError, exc.ValidationError, exc.SystemdError, exc.FluxFceError) as e:
        log.error(f"Scheduler: Failed to schedule dynamic transitions: {e}")
        return False
    except Exception as e:
        log.exception(f"Scheduler: Unexpected error during 'schedule-dynamic-transitions': {e}")
        return False

def enable_scheduling(
    python_exe_path: str,
    script_exe_path: str,
    # It's good practice for higher-level functions like this to call lower-level ones.
    # We'll need access to the desktop_manager's apply current function.
    # For now, let's assume it will be called from api.py after this returns.
    # Or we could import desktop_manager here if we make it a hard dependency.
    # Let's keep it simple for now and assume api.py handles the apply_current_period.
) -> bool:
    """
    Enables automatic theme transitions:
    1. Defines dynamic event timers for the next sunrise/sunset.
    2. Enables and starts the main daily scheduler timer (`fluxfce-scheduler.timer`).
    """
    # Note: The application of the current theme (via handle_run_login_check)
    # will be handled by the calling function in api.py after this function succeeds.

    log.info("Scheduler: Enabling scheduling with dynamic systemd timers...")
    try:
        define_schedule_ok = handle_schedule_dynamic_transitions_command(
            python_exe_path=python_exe_path, script_exe_path=script_exe_path
        )
        if not define_schedule_ok:
            log.warning("Scheduler: Initial definition of dynamic event timers failed or scheduled nothing, "
                        "but proceeding to enable the main daily scheduler.")

        code, _, stderr = _sysd_mgr_scheduler._run_systemctl(
            ["enable", "--now", sysd.SCHEDULER_TIMER_NAME], capture_output=True
        )
        if code != 0:
            raise exc.SystemdError(
                f"Scheduler: Failed to enable and start main scheduler timer ({sysd.SCHEDULER_TIMER_NAME}): {stderr.strip()}"
            )
        
        log.info(f"Scheduler: Main scheduler ({sysd.SCHEDULER_TIMER_NAME}) enabled; its service runs once now to set schedule.")
        log.info("Scheduler: Scheduling setup completed successfully by scheduler module.")
        return True
        
    except (exc.SystemdError, exc.FluxFceError) as e: 
        log.error(f"Scheduler: Failed to enable scheduling: {e}")
        raise 
    except Exception as e: 
        log.exception(f"Scheduler: Unexpected error enabling scheduling: {e}")
        raise exc.FluxFceError(f"Scheduler: An unexpected error occurred while enabling scheduling: {e}") from e

def disable_scheduling() -> bool:
    """
    Disables automatic theme transitions.
    """
    log.info("Scheduler: Disabling scheduling and removing dynamic systemd timers...")
    try:
        _sysd_mgr_scheduler._run_systemctl(["stop", sysd.SCHEDULER_TIMER_NAME], check_errors=False, capture_output=True)
        _sysd_mgr_scheduler._run_systemctl(["disable", sysd.SCHEDULER_TIMER_NAME], check_errors=False, capture_output=True)
        log.debug(f"Scheduler: Main scheduler timer ({sysd.SCHEDULER_TIMER_NAME}) stopped and disabled.")

        _sysd_mgr_scheduler._run_systemctl(["stop", sysd.SUNRISE_EVENT_TIMER_NAME], check_errors=False, capture_output=True)
        _sysd_mgr_scheduler._run_systemctl(["stop", sysd.SUNSET_EVENT_TIMER_NAME], check_errors=False, capture_output=True)
        log.debug("Scheduler: Dynamic event timers stopped.")

        for timer_name in [sysd.SUNRISE_EVENT_TIMER_NAME, sysd.SUNSET_EVENT_TIMER_NAME]:
            timer_path = sysd.SYSTEMD_USER_DIR / timer_name
            try:
                timer_path.unlink(missing_ok=True)
                log.debug(f"Scheduler: Removed {timer_name} (if existed).")
            except OSError as e:
                log.warning(f"Scheduler: Could not remove {timer_name}: {e}")

        _sysd_mgr_scheduler._run_systemctl(["daemon-reload"], capture_output=True)
        log.debug("Scheduler: Systemd daemon reloaded.")
        
        units_to_reset = [
            sysd.SCHEDULER_TIMER_NAME, 
            sysd.SUNRISE_EVENT_TIMER_NAME, 
            sysd.SUNSET_EVENT_TIMER_NAME,
            sysd.SCHEDULER_SERVICE_NAME 
        ]
        _sysd_mgr_scheduler._run_systemctl(["reset-failed", *units_to_reset], check_errors=False, capture_output=True)

        log.info("Scheduler: Scheduling disabled successfully.")
        return True

    except (exc.SystemdError, exc.FluxFceError) as e:
        log.error(f"Scheduler: Failed to disable scheduling: {e}")
        raise
    except Exception as e:
        log.exception(f"Scheduler: Unexpected error disabling scheduling: {e}")
        raise exc.FluxFceError(f"Scheduler: An unexpected error occurred while disabling scheduling: {e}") from e

##############
fluxfce_core/sun.py

# ~/dev/fluxfce-simplified/fluxfce_core/sun.py
"""
Sunrise and sunset time calculations for FluxFCE.

This module uses an adaptation of the NOAA algorithm to determine civil
twilight (sunrise/sunset) times for a given geographic location and date.
It accounts for timezone conversions to provide local event times.
"""

import logging
import math
from datetime import date, datetime, timedelta, timezone

# zoneinfo is standard library in Python 3.9+
try:
    from zoneinfo import ZoneInfo, ZoneInfoNotFoundError
except ImportError:
    # This is a critical dependency failure if zoneinfo is expected
    raise ImportError(
        "Required module 'zoneinfo' not found. FluxFCE requires Python 3.9+."
    )

# Import custom exceptions from within the same package
from .exceptions import CalculationError, ValidationError

log = logging.getLogger(__name__)


# --- Internal Sun Calculation Algorithm ---


def _noaa_sunrise_sunset(
    *, lat: float, lon: float, target_date: date
) -> tuple[float, float]:
    """
    Internal NOAA algorithm to calculate UTC sunrise/sunset times in minutes past midnight.

    Based on NOAA Javascript: www.esrl.noaa.gov/gmd/grad/solcalc/calcdetails.html

    Args:
        lat: Latitude in decimal degrees (-90 to 90).
        lon: Longitude in decimal degrees (-180 to 180).
        target_date: The specific date for calculation.

    Returns:
        A tuple (sunrise_utc_minutes, sunset_utc_minutes).

    Raises:
        CalculationError: If latitude/longitude are out of range, or for
                          polar day/night conditions where calculation fails.
    """
    log.debug(
        f"Calculating NOAA sun times for lat={lat}, lon={lon}, date={target_date}"
    )
    # Validate latitude/longitude ranges (redundant if called via get_sun_times which validates input strings, but good practice)
    if not (-90 <= lat <= 90):
        raise CalculationError(
            f"Invalid latitude for calculation: {lat}. Must be between -90 and 90."
        )
    if not (-180 <= lon <= 180):
        raise CalculationError(
            f"Invalid longitude for calculation: {lon}. Must be between -180 and 180."
        )

    n = target_date.timetuple().tm_yday  # Day of year
    longitude = lon  # Use validated input directly

    # Equation of Time and Declination (approximation)
    gamma = (2 * math.pi / 365) * (
        n - 1 + (12 - (longitude / 15)) / 24
    )  # Fractional year
    eqtime = 229.18 * (
        0.000075
        + 0.001868 * math.cos(gamma)
        - 0.032077 * math.sin(gamma)
        - 0.014615 * math.cos(2 * gamma)
        - 0.040849 * math.sin(2 * gamma)
    )
    decl = (
        0.006918
        - 0.399912 * math.cos(gamma)
        + 0.070257 * math.sin(gamma)
        - 0.006758 * math.cos(2 * gamma)
        + 0.000907 * math.sin(2 * gamma)
        - 0.002697 * math.cos(3 * gamma)
        + 0.00148 * math.sin(3 * gamma)
    )

    # Hour Angle Calculation
    lat_rad = math.radians(lat)
    # Zenith for sunrise/sunset (geometric center of sun) - 90.833 degrees
    # includes refraction and sun radius adjustment
    cos_zenith = math.cos(math.radians(90.833))
    try:
        # Argument for arccos to find hour angle
        cos_h_arg = (cos_zenith - math.sin(lat_rad) * math.sin(decl)) / (
            math.cos(lat_rad) * math.cos(decl)
        )
    except ZeroDivisionError:
        # This can happen near the poles if cos(decl) is near zero
        raise CalculationError(
            "Division by zero encountered during hour angle calculation (likely near poles)."
        )

    # Check for polar day/night conditions
    if cos_h_arg > 1.0:
        # Sun never rises (polar night)
        raise CalculationError(
            f"Sun never rises on {target_date} at lat {lat} (polar night)."
        )
    if cos_h_arg < -1.0:
        # Sun never sets (polar day)
        raise CalculationError(
            f"Sun never sets on {target_date} at lat {lat} (polar day)."
        )

    try:
        ha_rad = math.acos(cos_h_arg)  # Hour angle in radians
        ha_minutes = 4 * math.degrees(
            ha_rad
        )  # Convert hour angle to minutes (15 deg/hour * 4 min/deg)
    except ValueError as e:
        # Should not happen due to checks above, but safeguard
        raise CalculationError(f"Error calculating arccos for hour angle: {e}") from e

    # Solar noon (in minutes from UTC midnight)
    solar_noon_utc_min = 720 - 4 * longitude - eqtime  # 720 = 12 * 60

    sunrise_utc_min = solar_noon_utc_min - ha_minutes
    sunset_utc_min = solar_noon_utc_min + ha_minutes

    log.debug(
        f"Calculated UTC times (minutes from midnight): sunrise={sunrise_utc_min:.2f}, sunset={sunset_utc_min:.2f}"
    )
    return sunrise_utc_min, sunset_utc_min


# --- Public API for Sun Times ---


def get_sun_times(
    lat: float, lon: float, target_date: date, tz_name: str
) -> dict[str, datetime]:
    """
    Calculates sunrise and sunset times, returning them as timezone-aware datetimes.

    Args:
        lat: Latitude in decimal degrees (-90 to 90).
        lon: Longitude in decimal degrees (-180 to 180).
        target_date: The date for which to calculate times.
        tz_name: The IANA timezone name (e.g., 'America/Toronto').

    Returns:
        A dictionary {'sunrise': datetime_obj, 'sunset': datetime_obj} where
        datetime objects are timezone-aware for the specified tz_name.

    Raises:
        ValidationError: If the timezone name is invalid or not found by zoneinfo.
        CalculationError: If the underlying NOAA calculation fails (e.g., invalid
                          lat/lon passed internally, polar day/night).
    """
    log.debug(
        f"Getting sun times for lat={lat}, lon={lon}, date={target_date}, timezone={tz_name}"
    )
    try:
        tz_info = ZoneInfo(tz_name)
    except ZoneInfoNotFoundError:
        log.error(f"Invalid or unknown IANA Timezone Name: '{tz_name}'")
        raise ValidationError(f"Invalid or unknown IANA Timezone Name: '{tz_name}'")
    except Exception as e:  # Catch other potential zoneinfo errors
        log.error(f"Error loading timezone '{tz_name}': {e}")
        raise ValidationError(f"Error loading timezone '{tz_name}': {e}") from e

    try:
        # Call the internal algorithm
        sunrise_min, sunset_min = _noaa_sunrise_sunset(
            lat=lat, lon=lon, target_date=target_date
        )
    except CalculationError as e:
        # Propagate calculation errors (like polar day/night)
        log.error(f"Sun time calculation failed: {e}")
        raise  # Re-raise the specific CalculationError

    # Convert minutes from UTC midnight to datetime objects
    # Create a UTC midnight datetime for the target date
    utc_midnight = datetime(
        target_date.year, target_date.month, target_date.day, tzinfo=timezone.utc
    )

    # Add the calculated minutes to get the UTC event times
    sunrise_utc_dt = utc_midnight + timedelta(minutes=sunrise_min)
    sunset_utc_dt = utc_midnight + timedelta(minutes=sunset_min)

    # Convert to the target local timezone
    try:
        sunrise_local = sunrise_utc_dt.astimezone(tz_info)
        sunset_local = sunset_utc_dt.astimezone(tz_info)
    except Exception as e:
        # Handle potential errors during timezone conversion (less likely)
        log.exception(
            f"Failed to convert calculated UTC times to timezone '{tz_name}': {e}"
        )
        raise CalculationError(
            f"Failed timezone conversion for '{tz_name}': {e}"
        ) from e

    log.debug(
        f"Calculated local times: sunrise={sunrise_local.isoformat()}, sunset={sunset_local.isoformat()}"
    )
    return {"sunrise": sunrise_local, "sunset": sunset_local}

##############
fluxfce_core/systemd.py

# ~/dev/fluxfce-simplified/fluxfce_core/systemd.py
"""
Systemd user unit management for FluxFCE.

This module is responsible for creating, installing, managing, and removing
the systemd user units (timers and services) required for FluxFCE's
automatic scheduling and theme application on login/resume.
It defines the templates for these units and interacts with `systemctl`.
"""

import logging
import pathlib
import sys
from datetime import datetime # For type hinting in write_dynamic_event_timer_unit_file
from typing import Optional

# Import helpers and exceptions from within the same package
from . import helpers
from .exceptions import DependencyError, SystemdError

log = logging.getLogger(__name__)

# --- Constants ---
_APP_NAME = "fluxfce" # Application name, used in unit descriptions and names
SYSTEMD_USER_DIR = pathlib.Path.home() / ".config" / "systemd" / "user"

# --- Static Unit Names and File Paths ---
SCHEDULER_TIMER_NAME = f"{_APP_NAME}-scheduler.timer"
SCHEDULER_SERVICE_NAME = f"{_APP_NAME}-scheduler.service"
APPLY_TRANSITION_SERVICE_TEMPLATE_NAME = f"{_APP_NAME}-apply-transition@.service"
LOGIN_SERVICE_NAME = f"{_APP_NAME}-login.service"
RESUME_SERVICE_NAME = f"{_APP_NAME}-resume.service"
USER_SLEEP_TARGET_NAME = "sleep.target" # User-level anchor for sleep.target

SCHEDULER_TIMER_FILE = SYSTEMD_USER_DIR / SCHEDULER_TIMER_NAME
SCHEDULER_SERVICE_FILE = SYSTEMD_USER_DIR / SCHEDULER_SERVICE_NAME
APPLY_TRANSITION_SERVICE_TEMPLATE_FILE = SYSTEMD_USER_DIR / APPLY_TRANSITION_SERVICE_TEMPLATE_NAME
LOGIN_SERVICE_FILE = SYSTEMD_USER_DIR / LOGIN_SERVICE_NAME
RESUME_SERVICE_FILE = SYSTEMD_USER_DIR / RESUME_SERVICE_NAME
USER_SLEEP_TARGET_FILE = SYSTEMD_USER_DIR / USER_SLEEP_TARGET_NAME # Path for user-level sleep.target

# --- Dynamic Unit Names (filenames for timers generated at runtime) ---
SUNRISE_EVENT_TIMER_NAME = f"{_APP_NAME}-sunrise-event.timer"
SUNSET_EVENT_TIMER_NAME = f"{_APP_NAME}-sunset-event.timer"

# --- Lists for Management ---
STATIC_UNIT_FILES_MAP = {
    SCHEDULER_TIMER_NAME: SCHEDULER_TIMER_FILE,
    SCHEDULER_SERVICE_NAME: SCHEDULER_SERVICE_FILE,
    APPLY_TRANSITION_SERVICE_TEMPLATE_NAME: APPLY_TRANSITION_SERVICE_TEMPLATE_FILE,
    LOGIN_SERVICE_NAME: LOGIN_SERVICE_FILE,
    RESUME_SERVICE_NAME: RESUME_SERVICE_FILE,
    USER_SLEEP_TARGET_NAME: USER_SLEEP_TARGET_FILE, # Added user-level sleep.target
}

DYNAMIC_EVENT_TIMER_NAMES = [
    SUNRISE_EVENT_TIMER_NAME,
    SUNSET_EVENT_TIMER_NAME,
]

# ALL_POTENTIAL_FLUXFCE_UNIT_NAMES includes all units that fluxfce might create or manage,
# including the user-level sleep.target for cleanup with reset-failed.
ALL_POTENTIAL_FLUXFCE_UNIT_NAMES = [
    SCHEDULER_TIMER_NAME,
    SCHEDULER_SERVICE_NAME,
    f"{_APP_NAME}-apply-transition@day.service",
    f"{_APP_NAME}-apply-transition@night.service",
    LOGIN_SERVICE_NAME,
    RESUME_SERVICE_NAME,
    SUNRISE_EVENT_TIMER_NAME,
    SUNSET_EVENT_TIMER_NAME,
    USER_SLEEP_TARGET_NAME, # Added for reset-failed
]

# --- Unit File Templates ---

_SCHEDULER_TIMER_TEMPLATE = """\
[Unit]
Description={app_name}: Daily Timer to Reschedule Sunrise/Sunset Event Timers
PartOf=timers.target

[Timer]
Unit={scheduler_service_name}
OnCalendar=daily
RandomizedDelaySec=15min
Persistent=true
AccuracySec=1m

[Install]
WantedBy=timers.target
"""

_SCHEDULER_SERVICE_TEMPLATE = """\
[Unit]
Description={app_name}: Daily Service to Reschedule Sunrise/Sunset Event Timers
After=time-set.target

[Service]
Type=oneshot
ExecStart={python_executable} "{script_path}" schedule-dynamic-transitions
StandardOutput=journal
StandardError=journal
"""

_APPLY_TRANSITION_TEMPLATE = """\
[Unit]
Description={app_name}: Apply %I Mode Transition
PartOf=graphical-session.target
After=graphical-session.target xfce4-session.target
ConditionEnvironment=DISPLAY

[Service]
Type=oneshot
ExecStart={python_executable} "{script_path}" internal-apply --mode %i
StandardOutput=journal
StandardError=journal
"""

_LOGIN_SERVICE_TEMPLATE = """\
[Unit]
Description={app_name}: Apply theme on login
After=graphical-session.target xfce4-session.target plasma-workspace.target gnome-session.target
Requires=graphical-session.target
ConditionEnvironment=DISPLAY
[Service]
Type=oneshot
ExecStartPre=/bin/sleep 20
ExecStart={python_executable} "{script_path}" run-login-check
StandardError=journal
[Install]
WantedBy=graphical-session.target
"""

_RESUME_SERVICE_TEMPLATE = """\
[Unit]
Description={app_name} - Apply theme after system resume
After=sleep.target graphical-session.target
Requires=graphical-session.target
ConditionEnvironment=DISPLAY

[Service]
Type=oneshot
ExecStartPre=/bin/sleep 5
ExecStart={python_executable} "{script_path}" run-login-check
StandardError=journal

[Install]
WantedBy=sleep.target
"""

_USER_SLEEP_TARGET_TEMPLATE = """\
[Unit]
Description={app_name} User-Level Sleep Target Anchor
Documentation=man:systemd.special(7)
RefuseManualStart=yes
RefuseManualStop=yes
DefaultDependencies=no

[Install]
"""

_STATIC_UNIT_TEMPLATES = {
    SCHEDULER_TIMER_NAME: _SCHEDULER_TIMER_TEMPLATE,
    SCHEDULER_SERVICE_NAME: _SCHEDULER_SERVICE_TEMPLATE,
    APPLY_TRANSITION_SERVICE_TEMPLATE_NAME: _APPLY_TRANSITION_TEMPLATE,
    LOGIN_SERVICE_NAME: _LOGIN_SERVICE_TEMPLATE,
    RESUME_SERVICE_NAME: _RESUME_SERVICE_TEMPLATE,
    USER_SLEEP_TARGET_NAME: _USER_SLEEP_TARGET_TEMPLATE, # Added template for user sleep.target
}


class SystemdManager:
    """Handles creation, installation, and removal of systemd user units for fluxfce."""

    def __init__(self):
        """Check for systemctl dependency."""
        self.app_name = _APP_NAME
        try:
            helpers.check_dependencies(["systemctl"])
        except DependencyError as e:
            log.error(f"SystemdManager initialization failed: {e}")
            raise SystemdError(f"Cannot initialize SystemdManager: {e}") from e

    def _run_systemctl(
        self, args: list[str], check_errors: bool = True, capture_output: bool = False
    ) -> tuple[int, str, str]:
        """Runs a systemctl --user command."""
        cmd = ["systemctl", "--user", *args]
        try:
            # helpers.run_command captures output if capture_output is True.
            # It handles stripping stdout/stderr.
            code, stdout, stderr = helpers.run_command(cmd, check=False, capture=capture_output)
            if code != 0 and check_errors:
                # Log error only if check_errors is True and command failed.
                # stdout/stderr will be from the captured output if capture_output was True.
                # If not captured, they'll be empty strings from helpers.run_command.
                err_details = stderr.strip() if stderr else stdout.strip() # Prefer stderr for error details
                log.error(
                    f"systemctl --user {' '.join(args)} failed (code {code}). Details: '{err_details}'"
                )
            return code, stdout, stderr # stdout/stderr are already strings
        except FileNotFoundError:
            log.error(f"systemctl command not found when trying to run: systemctl --user {' '.join(args)}")
            raise DependencyError("systemctl command not found.")
        except Exception as e:
            log.exception(f"Unexpected error running systemctl command: systemctl --user {' '.join(args)}")
            raise SystemdError(
                f"Unexpected error running systemctl command 'systemctl --user {' '.join(args)}': {e}"
            ) from e

    def check_user_instance(self) -> bool:
        """
        Checks if the systemd user instance appears to be running and in a usable state.
        Raises SystemdError if the instance is not in a good state.
        """
        log.debug("Checking systemd user instance status...")
        code, stdout, stderr = self._run_systemctl(
            ["is-system-running"], check_errors=False, capture_output=True
        )
        
        status_output = stdout.strip().lower()

        if code == 0: # is-system-running returns 0 for "running", "degraded", etc.
            if status_output == "running":
                log.info(f"Systemd user instance reported: '{status_output}'.")
                return True
            elif status_output == "degraded":
                log.warning(
                    f"Systemd user instance reported: '{status_output}'. "
                    f"{self.app_name} functionality might be limited or unreliable."
                )
                return True # Still allow proceeding but with a stronger warning.
            else:
                # Other states like "stopping", "offline", "initializing", "starting"
                error_msg = (
                    f"Systemd user instance is in an ambiguous state: '{status_output}' (exit code {code}). "
                    f"While not a fatal error state according to 'is-system-running', "
                    f"this state may prevent {self.app_name} from operating correctly. "
                    f"Stderr: '{stderr.strip()}'"
                )
                log.warning(error_msg) 
                return True # Allow proceeding but highlight potential issues.
        else: # Non-zero usually means a more significant issue or "offline"
            error_msg = (
                f"Systemd user instance is not in a usable state "
                f"(command 'is-system-running' exit code: {code}, status: '{status_output}'). "
                f"Stderr: '{stderr.strip()}'. "
                f"{self.app_name} cannot proceed with systemd operations."
            )
            log.error(error_msg)
            raise SystemdError(error_msg)

    def install_units(
        self, script_path: str, python_executable: Optional[str] = None
    ) -> bool:
        """
        Creates and installs the static systemd user units for fluxfce.
        Enables the login, resume, and main scheduler timer services.
        """
        log.info(f"Installing static systemd user units for {self.app_name}...")
        self.check_user_instance()

        py_exe = python_executable or sys.executable
        script_abs_path = str(pathlib.Path(script_path).resolve())

        if not pathlib.Path(py_exe).is_file():
            raise FileNotFoundError(f"Python executable for systemd units not found: {py_exe}")
        if not pathlib.Path(script_abs_path).is_file():
            raise FileNotFoundError(f"Target script for systemd units not found: {script_abs_path}")

        try:
            SYSTEMD_USER_DIR.mkdir(parents=True, exist_ok=True)
            log.debug(f"Ensured systemd user directory exists: {SYSTEMD_USER_DIR}")
        except OSError as e:
            raise SystemdError(
                f"Failed to create systemd user directory {SYSTEMD_USER_DIR}: {e}"
            ) from e

        for unit_name, unit_file_path in STATIC_UNIT_FILES_MAP.items():
            template_content = _STATIC_UNIT_TEMPLATES.get(unit_name)
            if not template_content:
                log.error(f"Internal error: No template found for static unit {unit_name}, skipping.")
                continue
            
            # The user-level sleep.target template does not need these specific format args
            # but format will ignore extra keys.
            formatted_content = template_content.format(
                app_name=self.app_name,
                python_executable=py_exe,
                script_path=script_abs_path,
                scheduler_service_name=SCHEDULER_SERVICE_NAME,
            )
            try:
                unit_file_path.write_text(formatted_content, encoding="utf-8")
                log.info(f"Written systemd unit file: {unit_file_path}")
            except OSError as e:
                raise SystemdError(
                    f"Failed to write systemd unit file {unit_file_path}: {e}"
                ) from e

        reload_code, _, reload_err = self._run_systemctl(["daemon-reload"], capture_output=True)
        if reload_code != 0:
            raise SystemdError(f"systemctl daemon-reload failed: {reload_err.strip()}")
        log.debug("Systemd daemon-reload successful.")

        # Enable essential static units.
        # api.enable_scheduling() will handle --now for SCHEDULER_TIMER_NAME
        # and the setup of dynamic event timers.
        # The user-level sleep.target does not need to be "enabled" itself.
        services_to_enable_on_install = [
            LOGIN_SERVICE_NAME,
            RESUME_SERVICE_NAME,
            SCHEDULER_TIMER_NAME 
        ]
        for service_name in services_to_enable_on_install:
            enable_code, _, enable_err = self._run_systemctl(["enable", service_name], capture_output=True)
            if enable_code != 0:
                # For resume service and sleep.target, a specific warning about non-existent target
                # is now handled by creating the user-level sleep.target.
                # Other enable errors are still critical.
                error_msg = (
                    f"Failed to enable essential systemd unit '{service_name}' during installation. "
                    f"Stderr: '{enable_err.strip()}'. "
                    f"{self.app_name} may not function correctly."
                )
                log.error(error_msg)
                raise SystemdError(error_msg) 
            else:
                log.info(f"Enabled systemd unit: {service_name}")
        
        log.info(f"Static systemd units for {self.app_name} installed and essential services enabled successfully.")
        return True

    def remove_units(self) -> bool:
        """Stops, disables, and removes all static and dynamic fluxfce systemd user units."""
        log.info(f"Removing all {self.app_name} systemd user units...")
        
        units_to_stop_and_disable = [
            SCHEDULER_TIMER_NAME, SCHEDULER_SERVICE_NAME, # Scheduler components
            LOGIN_SERVICE_NAME, RESUME_SERVICE_NAME,      # Login/Resume hooks
            *DYNAMIC_EVENT_TIMER_NAMES,                   # Dynamic sunrise/sunset timers
            # Potentially running instances of the apply transition service
            f"{_APP_NAME}-apply-transition@day.service",
            f"{_APP_NAME}-apply-transition@night.service",
        ]
        
        # Stop units
        for unit_name in units_to_stop_and_disable:
             self._run_systemctl(["stop", unit_name], check_errors=False, capture_output=True)
        log.debug(f"Attempted to stop all potentially running {self.app_name} units/timers.")

        # Disable units that were explicitly enabled (static ones + scheduler timer)
        # Dynamic timers are not "enabled" in the same persistent way.
        # The user-level sleep.target isn't "enabled" either.
        units_to_disable_persistently = [
            SCHEDULER_TIMER_NAME,
            LOGIN_SERVICE_NAME,
            RESUME_SERVICE_NAME
        ]
        for unit_name in units_to_disable_persistently:
            self._run_systemctl(["disable", unit_name], check_errors=False, capture_output=True)
        log.debug(f"Attempted to disable static units: {', '.join(units_to_disable_persistently)}")

        # Remove all files defined in STATIC_UNIT_FILES_MAP (includes user_sleep_target)
        for unit_file_path in STATIC_UNIT_FILES_MAP.values():
            try:
                unit_file_path.unlink(missing_ok=True)
                log.debug(f"Removed unit file: {unit_file_path} (if it existed)")
            except OSError as e:
                log.warning(f"Error removing unit file {unit_file_path}: {e} (continuing)")

        # Remove dynamic timer files
        for dynamic_timer_name in DYNAMIC_EVENT_TIMER_NAMES:
            dynamic_file_path = SYSTEMD_USER_DIR / dynamic_timer_name
            try:
                dynamic_file_path.unlink(missing_ok=True)
                log.debug(f"Removed dynamic timer file: {dynamic_file_path} (if it existed)")
            except OSError as e:
                log.warning(f"Error removing dynamic timer file {dynamic_file_path}: {e} (continuing)")
        
        reload_code, _, reload_err = self._run_systemctl(["daemon-reload"], capture_output=True)
        if reload_code != 0:
            log.warning(f"systemctl daemon-reload failed during unit removal: {reload_err.strip()}. State might be inconsistent.")
        else:
            log.debug("Systemd daemon-reload successful after unit removal.")

        # Use ALL_POTENTIAL_FLUXFCE_UNIT_NAMES for reset-failed
        reset_code, _, reset_err = self._run_systemctl(["reset-failed", *ALL_POTENTIAL_FLUXFCE_UNIT_NAMES], check_errors=False, capture_output=True)
        if reset_code !=0:
            log.debug(f"reset-failed command for some units may have reported issues: {reset_err.strip()}")
        else:
            log.debug(f"Attempted reset-failed for all {self.app_name} units.")
        
        log.info(f"{self.app_name} systemd units removed.")
        return True

    def write_dynamic_event_timer_unit_file(
        self,
        mode: str, 
        utc_execution_time: datetime,
    ) -> bool:
        """
        Creates or overwrites a dynamic event timer file.
        The timer triggers an instance of APPLY_TRANSITION_SERVICE_TEMPLATE_NAME.
        `utc_execution_time` MUST be timezone-aware and set to UTC.
        """
        if mode not in ["day", "night"]:
            log.error(f"Invalid mode '{mode}' specified for dynamic event timer generation.")
            return False # Or raise error

        if utc_execution_time.tzinfo is None or utc_execution_time.tzinfo.utcoffset(utc_execution_time) is None:
            msg = f"utc_execution_time for dynamic timer ({mode}) must be UTC and timezone-aware."
            log.error(msg)
            raise ValueError(msg)

        timer_name = SUNRISE_EVENT_TIMER_NAME if mode == "day" else SUNSET_EVENT_TIMER_NAME
        timer_file_path = SYSTEMD_USER_DIR / timer_name
        
        service_instance_to_trigger = f"{_APP_NAME}-apply-transition@{mode}.service"
        # Systemd OnCalendar expects UTC if the timezone is specified as 'UTC'
        on_calendar_utc_str = utc_execution_time.strftime('%Y-%m-%d %H:%M:%S UTC')

        timer_content = f"""\
[Unit]
Description={self.app_name}: Event Timer for {mode.capitalize()} Transition (Dynamic)
# This timer requires the corresponding apply-transition@mode.service instance
Requires={service_instance_to_trigger}
# If the service it triggers is removed/fails, this timer might also be affected.
# PartOf can be used if desired, but Requires is explicit for the specific instance.

[Timer]
Unit={service_instance_to_trigger}
OnCalendar={on_calendar_utc_str}
Persistent=true  # So it runs if the machine was off at the scheduled time
AccuracySec=1s   # Timer accuracy
WakeSystem=false # Don't wake the system just for this timer

[Install]
# Dynamic timers are not typically "WantedBy" other targets directly.
# They are started/stopped by the application logic (e.g., via fluxfce-scheduler.service)
"""
        try:
            SYSTEMD_USER_DIR.mkdir(parents=True, exist_ok=True) # Ensure dir exists
            timer_file_path.write_text(timer_content, encoding="utf-8")
            log.info(f"Written dynamic timer file: {timer_file_path} for event at {on_calendar_utc_str}")
            return True
        except OSError as e:
            log.error(f"Failed to write dynamic timer file {timer_file_path}: {e}")
            raise SystemdError(f"Failed to write dynamic timer file {timer_file_path}: {e}") from e
        except ValueError as e: # Catch other errors like strftime issues if any
            log.error(f"Error preparing dynamic timer content for {mode}: {e}")
            raise

##############
fluxfce_core/xfce.py

# ~/dev/fluxfce-simplified/fluxfce_core/xfce.py
"""
XFCE desktop environment interaction for FluxFCE.

This module provides the `XfceHandler` class, which encapsulates all
direct interactions with XFCE settings. This includes getting/setting
GTK themes, desktop background colors/gradients, and screen
temperature/brightness using `xfconf-query` and `xsct` utilities.
"""

import logging
import re
import subprocess
import time
from typing import Any, Optional

# Import helpers and exceptions from within the same package
from . import helpers
from .exceptions import DependencyError, ValidationError, XfceError

log = logging.getLogger(__name__)

# --- XFCE Constants ---
XFCONF_CHANNEL = "xfce4-desktop"
XFCONF_THEME_CHANNEL = "xsettings"
XFCONF_THEME_PROPERTY = "/Net/ThemeName"


class XfceHandler:
    """Handles interactions with XFCE settings via xfconf-query and xsct."""

    def __init__(self):
        """Check for essential dependencies."""
        try:
            helpers.check_dependencies(["xfconf-query", "xsct"])
        except DependencyError as e:
            raise XfceError(f"Cannot initialize XfceHandler: {e}") from e

    def find_desktop_paths(self) -> list[str]:
        """
        Finds relevant XFCE desktop property base paths for background settings.
        These paths usually correspond to specific monitor/workspace combinations.
        Returns a sorted list of potential base property paths.
        """
        log.debug(f"Querying {XFCONF_CHANNEL} for background property paths...")
        cmd = ["xfconf-query", "-c", XFCONF_CHANNEL, "-l"]
        try:
            code, stdout, stderr = helpers.run_command(cmd)
            if code != 0:
                raise XfceError(
                    f"Failed to list xfconf properties in channel {XFCONF_CHANNEL}: {stderr} (code: {code})"
                )

            paths = set()
            # Regex: (any_path_ending_with_workspace_number)/last-image
            prop_pattern_workspace = re.compile(
                r"(/backdrop/screen\d+/[\w.-]+/workspace\d+)/last-image$"
            )
            # Regex: (any_path_ending_with_monitor_name_or_id)/last-image
            prop_pattern_monitor = re.compile(
                r"(/backdrop/screen\d+/[\w.-]+)/last-image$"
            )

            # Prioritize more specific per-workspace paths
            for line in stdout.splitlines():
                match = prop_pattern_workspace.match(line.strip())
                if match:
                    paths.add(match.group(1))
            
            # Add per-monitor paths (these are often the effective ones if single-workspace-mode is true)
            # Or if no workspace-specific paths were found for "last-image"
            for line in stdout.splitlines():
                match = prop_pattern_monitor.match(line.strip())
                if match:
                    # Avoid adding a monitor path if its workspace sub-paths are already included
                    # (e.g., if we have .../monitorX/workspace0, don't also add .../monitorX unless distinct)
                    # This logic is a bit simplified; a more robust check might be needed for complex cases.
                    # For now, we add both and let get_background_settings iterate.
                    paths.add(match.group(1))


            if not paths:
                # Fallback to a common default if absolutely no paths found by pattern
                # This is less likely to be effective but provides a last resort.
                default_paths_to_try = [
                    "/backdrop/screen0/monitor0/workspace0", # Generic workspace
                    "/backdrop/screen0/monitor0"             # Generic monitor
                ]
                for default_path in default_paths_to_try:
                    cmd_check = ["xfconf-query", "-c", XFCONF_CHANNEL, "-p", f"{default_path}/last-image"]
                    # Check if property exists, don't care about value. check=False to handle non-zero for non-existent.
                    code_check, _, _ = helpers.run_command(cmd_check, check=False, capture=True)
                    if code_check == 0: # Property exists
                        log.warning(f"Using fallback default path: {default_path} as it seems to exist.")
                        paths.add(default_path)
                        break # Use the first default path that exists

                if not paths: # Still no paths
                    raise XfceError("Could not find any XFCE background property paths.")

            # Sort for consistent processing order, though XFCE's priority is not based on this sort.
            sorted_paths = sorted(list(paths), key=len, reverse=False) # Try shorter (often more general or primary) paths first
            log.info(f"Found {len(sorted_paths)} potential background paths: {sorted_paths}")
            return sorted_paths

        except Exception as e:
            if isinstance(e, XfceError):
                raise
            log.exception(f"Error finding desktop paths: {e}")
            raise XfceError(f"An unexpected error occurred while finding desktop paths: {e}") from e

    def get_gtk_theme(self) -> str:
        log.debug(f"Getting GTK theme from {XFCONF_THEME_CHANNEL} {XFCONF_THEME_PROPERTY}")
        cmd = ["xfconf-query", "-c", XFCONF_THEME_CHANNEL, "-p", XFCONF_THEME_PROPERTY]
        try:
            code, stdout, stderr = helpers.run_command(cmd)
            if code != 0:
                raise XfceError(f"Failed to query GTK theme: {stderr} (code: {code})") from None
            if not stdout: # Should not happen if code is 0, but good check
                raise XfceError("GTK theme query returned success but empty output.")
            log.info(f"Current GTK theme: {stdout}")
            return stdout
        except Exception as e:
            if isinstance(e, XfceError): raise
            log.exception(f"Error getting GTK theme: {e}")
            raise XfceError(f"An unexpected error occurred while getting GTK theme: {e}") from e

    def set_gtk_theme(self, theme_name: str) -> bool:
        if not theme_name:
            raise ValidationError("Theme name cannot be empty.")
        log.info(f"Setting GTK theme to: {theme_name}")
        cmd = ["xfconf-query", "-c", XFCONF_THEME_CHANNEL, "-p", XFCONF_THEME_PROPERTY, "-s", theme_name]
        try:
            code, _, stderr = helpers.run_command(cmd)
            if code != 0:
                raise XfceError(f"Failed to set GTK theme to '{theme_name}': {stderr} (code: {code})")
            log.debug(f"Successfully set GTK theme to '{theme_name}'")
            return True
        except Exception as e:
            if isinstance(e, (XfceError, ValidationError)): raise
            log.exception(f"Error setting GTK theme: {e}")
            raise XfceError(f"An unexpected error occurred while setting GTK theme: {e}") from e

    def get_background_settings(self, current_config_bg: Optional[dict] = None) -> dict[str, Any]:
        """
        Gets background settings (style, colors) by checking candidate paths.
        If current_config_bg is provided and multiple differing XFCE settings exist,
        it prioritizes the one that uniquely deviates from current_config_bg.
        Otherwise, it uses the first path found (sorted by shortest) that is 
        configured for 'Color' mode and from which all color data can be successfully read.
        """
        candidate_paths = self.find_desktop_paths()
        if not candidate_paths: # find_desktop_paths should raise if it finds nothing
            raise XfceError("No candidate desktop paths found by find_desktop_paths.")

        log.debug(f"Attempting to get background settings from candidate paths: {candidate_paths}")

        # --- Nested helper functions ---
        def _get_prop_for_path(base_path_arg: str, prop_name: str) -> Optional[str]:
            prop_path = f"{base_path_arg}/{prop_name}"
            cmd = ["xfconf-query", "-c", XFCONF_CHANNEL, "-p", prop_path]
            try:
                code, stdout, stderr = helpers.run_command(cmd, capture=True) # Ensure capture
                if code != 0:
                    if "does not exist" in stderr.lower():
                        log.debug(f"Property {prop_path} does not exist for candidate path.")
                    else:
                        log.warning(f"Could not query {prop_path} for candidate path {base_path_arg}: {stderr} (code: {code})")
                    return None 
                return stdout.strip()
            except Exception as e: # Includes FileNotFoundError if xfconf-query isn't there
                log.warning(f"Unexpected error getting property {prop_path} for {base_path_arg}: {e}")
                return None

        def _parse_rgba_for_path(base_path_arg: str, prop_name: str) -> Optional[list[float]]:
            prop_path = f"{base_path_arg}/{prop_name}"
            cmd = ["xfconf-query", "-c", XFCONF_CHANNEL, "-p", prop_path]
            code, stdout, stderr = helpers.run_command(cmd, capture=True) # Ensure capture
            if code != 0:
                if "does not exist" in stderr.lower():
                    log.debug(f"RGBA property {prop_path} does not exist for candidate path {base_path_arg}.")
                else:
                    log.warning(f"Could not query {prop_name} from {base_path_arg}: {stderr} (code: {code})")
                return None

            float_values = []
            num_pattern = re.compile(r"^\s*(-?\d+(?:\.\d+)?)\s*$") # Non-capturing group for decimal part
            for line in stdout.splitlines():
                match = num_pattern.match(line)
                if match:
                    try:
                        float_values.append(float(match.group(1)))
                    except ValueError: 
                        log.warning(f"ValueError converting '{match.group(1)}' to float from {prop_path}")
                        continue 
            if len(float_values) == 4:
                log.debug(f"Parsed {prop_name} values from {base_path_arg}: {float_values}")
                return float_values
            else:
                log.warning(f"Could not parse 4 float values for {prop_name} from {base_path_arg} (found {len(float_values)}). Output:\n{stdout}")
                return None

        def _floats_to_hex(rgba_floats: Optional[list[float]]) -> Optional[str]:
            if not rgba_floats or len(rgba_floats) != 4:
                log.debug(f"_floats_to_hex: Invalid input (not a list of 4 floats): {rgba_floats}")
                return None
            try:
                r_f, g_f, b_f = rgba_floats[0], rgba_floats[1], rgba_floats[2] # Alpha (rgba_floats[3]) ignored for hex
                
                r = max(0, min(255, int(r_f * 255 + 0.5)))
                g = max(0, min(255, int(g_f * 255 + 0.5)))
                b = max(0, min(255, int(b_f * 255 + 0.5)))
                
                hex_str = f"{r:02X}{g:02X}{b:02X}"
                log.debug(f"Converted floats {rgba_floats} to hex '{hex_str}'")
                return hex_str
            except (ValueError, TypeError, IndexError) as e:
                log.error(f"Error converting float list {rgba_floats} to hex: {e}")
                return None
        
        # --- Iterate through candidate paths ---
        valid_settings_found = [] # List to store (path, settings_dict)

        for path_to_check in candidate_paths:
            log.debug(f"Checking candidate path for background settings: {path_to_check}")
            
            image_style = _get_prop_for_path(path_to_check, "image-style")
            if image_style != "1": # "1" is for 'Color' mode
                log.debug(f"Path {path_to_check} not in 'Color' mode (image-style: {image_style}). Skipping.")
                continue

            color_style = _get_prop_for_path(path_to_check, "color-style")
            if color_style is None or color_style not in ("0", "1", "2"): # solid, horizontal, vertical
                log.debug(f"Path {path_to_check} has invalid/missing color-style ({color_style}). Skipping.")
                continue

            current_settings_from_path = {"hex1": None, "hex2": None, "dir": None}

            rgba1_floats = _parse_rgba_for_path(path_to_check, "rgba1")
            current_settings_from_path["hex1"] = _floats_to_hex(rgba1_floats)
            if not current_settings_from_path["hex1"]:
                log.warning(f"Failed to parse primary color (rgba1) from path {path_to_check}. Skipping this path.")
                continue 

            if color_style == "0":  # Solid
                current_settings_from_path["dir"] = "s"
                current_settings_from_path["hex2"] = None 
            elif color_style in ("1", "2"):  # Gradient (horizontal or vertical)
                current_settings_from_path["dir"] = "h" if color_style == "1" else "v"
                rgba2_floats = _parse_rgba_for_path(path_to_check, "rgba2")
                current_settings_from_path["hex2"] = _floats_to_hex(rgba2_floats)
                if not current_settings_from_path["hex2"]:
                    log.warning(f"Path {path_to_check} is gradient mode but failed to parse secondary color (rgba2). Skipping this path.")
                    continue
            
            log.info(
                f"Successfully parsed background settings from {path_to_check}: "
                f"Dir={current_settings_from_path['dir']}, Hex1={current_settings_from_path['hex1']}, "
                f"Hex2={current_settings_from_path.get('hex2', 'N/A')}"
            )
            valid_settings_found.append((path_to_check, current_settings_from_path))

        if not valid_settings_found:
            raise XfceError("Could not find any xfconf path actively configured for color background settings among candidates.")

        if len(valid_settings_found) == 1:
            # Only one valid path found, return its settings
            path, settings = valid_settings_found[0]
            log.info(f"Using background settings from the only valid path: {path}")
            return settings

        # Multiple valid paths found, check for discrepancies and prioritize
        # Sort by path length (ascending) to prioritize shorter (often more general or primary) paths when multiple settings are found.
        valid_settings_found.sort(key=lambda item: len(item[0]), reverse=False)

        # Check if all settings are identical
        first_settings = valid_settings_found[0][1]
        all_same = True
        for _, settings in valid_settings_found[1:]:
            if settings != first_settings:
                all_same = False
                break
        
        # Default to the shortest path after sorting, can be overridden by deviation logic
        chosen_path, chosen_settings = valid_settings_found[0]
        choice_reason = "shortest path heuristic" # Default reason

        if current_config_bg: # Log current_config_bg if provided, early in the decision process
            log.debug(f"Received current_config_bg for reference: {current_config_bg}")

        if len(valid_settings_found) == 1:
            choice_reason = "only valid path"
            # chosen_path and chosen_settings are already correctly set from valid_settings_found[0]
            # This case was technically handled before this block, but re-stating for logical flow.
        elif all_same:
            choice_reason = "all settings identical"
            # chosen_path and chosen_settings are correct (from the first item, as all are same)
        else: # This is the complex case: multiple valid_settings_found with differing configurations
            log.warning(
                "Multiple XFCE paths have different valid background color settings. "
                "Attempting to determine the best choice..."
            )
            # Log all differing settings for full context before decision logic
            for path, settings in valid_settings_found:
                log.warning(
                    f"  Path candidate: {path}, Settings: Dir={settings['dir']}, "
                    f"Hex1={settings['hex1']}, Hex2={settings.get('hex2', 'N/A')}"
                )

            if current_config_bg:
                # current_config_bg is available, use it to find a unique deviation
                deviating_settings_list = [] # Renamed to avoid conflict with the log variable name
                log.debug("Starting deviation checks against current_config_bg:")
                for item_path, item_settings in valid_settings_found:
                    log.debug(f"  Comparing Path: {item_path}, Settings: {item_settings}")
                    are_different = not (
                        item_settings['hex1'] == current_config_bg.get('hex1') and
                        item_settings['dir'] == current_config_bg.get('dir') and
                        (item_settings.get('hex2') or None) == (current_config_bg.get('hex2') or None)
                    )
                    log.debug(f"    Are different from current_config_bg? {are_different}")
                    if are_different:
                        deviating_settings_list.append((item_path, item_settings))
                
                log.debug(f"List of settings deviating from current_config_bg: {deviating_settings_list}")

                if len(deviating_settings_list) == 1:
                    chosen_path, chosen_settings = deviating_settings_list[0]
                    choice_reason = "unique deviation from saved config"
                elif len(deviating_settings_list) == 0:
                    # No settings deviate from current_config_bg. All are same as current_config_bg.
                    # Stick with the shortest path among them (already default).
                    choice_reason = "no deviation from saved config, using shortest path heuristic"
                    log.info(
                        "All differing XFCE settings match the provided current_config_bg. "
                        "Using the shortest path as per default heuristic."
                    )
                else: # len(deviating_settings_list) > 1
                    # Multiple settings deviate from current_config_bg.
                    # Fallback to shortest path AMONG THE DEVIATING ONES.
                    log.warning(
                        f"{len(deviating_settings_list)} configurations deviate from saved config. "
                        "Choosing the shortest path among these deviating ones."
                    )
                    deviating_settings_list.sort(key=lambda item: len(item[0]), reverse=False)
                    chosen_path, chosen_settings = deviating_settings_list[0]
                    choice_reason = "shortest path among multiple deviations"
            else:
                # No current_config_bg provided. Stick with the default (shortest path of all valid_settings_found).
                choice_reason = "no current_config_bg, using shortest path heuristic among all differing"
                log.info(
                    "No current_config_bg provided. Defaulting to the shortest path among "
                    "the differing XFCE settings."
                )
            
            # Log tie-breaking if the chosen reason involves "shortest path"
            if "shortest path" in choice_reason:
                paths_for_tie_check = valid_settings_found
                if "among multiple deviations" in choice_reason:
                    paths_for_tie_check = deviating_settings_list # type: ignore
                
                min_len_for_chosen = len(chosen_path)
                tied_shortest_paths_with_diff_settings = []
                for p_path, p_settings in paths_for_tie_check:
                    if len(p_path) == min_len_for_chosen and p_settings != chosen_settings:
                        tied_shortest_paths_with_diff_settings.append((p_path, p_settings))
                
                if tied_shortest_paths_with_diff_settings:
                    log.warning(
                        f"Path '{chosen_path}' was chosen based on '{choice_reason}'. "
                        f"However, other paths with the same length ({min_len_for_chosen}) "
                        f"and different settings exist: {tied_shortest_paths_with_diff_settings}. "
                        "The choice among these ties was due to sort order."
                    )

        # Final log message including the explicit choice_reason
        log.info(
            f"Final decision: Using background settings from path '{chosen_path}' "
            f"(Dir={chosen_settings['dir']}, Hex1={chosen_settings['hex1']}, "
            f"Hex2={chosen_settings.get('hex2', 'N/A')}) - Reason: {choice_reason}."
        )
        return chosen_settings


    def set_background(self, hex1: str, hex2: Optional[str], direction: str) -> bool:
        log.info(f"Setting background: Dir={direction}, Hex1={hex1}, Hex2={hex2 or 'N/A'}")
        paths = self.find_desktop_paths()
        if not paths:
            raise XfceError("No desktop paths found by find_desktop_paths to apply background settings.")

        try:
            rgba1_list = helpers.hex_to_rgba_doubles(hex1)
        except ValidationError as e:
            raise ValidationError(f"Invalid format for hex1 '{hex1}': {e}") from e

        rgba2_list = None
        if direction in ("h", "v"):
            if not hex2: # hex2 is required for gradients
                raise ValidationError(f"Gradient direction '{direction}' specified but hex2 is missing.")
            try:
                rgba2_list = helpers.hex_to_rgba_doubles(hex2)
            except ValidationError as e:
                raise ValidationError(f"Invalid format for hex2 '{hex2}': {e}") from e
        elif direction == "s":
            if hex2 is not None and hex2.strip() != "": # Ensure hex2 is effectively None or empty for solid
                log.warning(f"Ignoring hex2='{hex2}' because direction='s' (solid) was specified.")
                # No need to explicitly set rgba2_list to None here, as it's already initialized to None
        else:
            raise ValidationError(f"Invalid background direction: '{direction}'. Must be 's', 'h', or 'v'.")

        image_style_val = "1"  # Color mode
        color_style_val = "0"  # Default to Solid
        if direction == "h": color_style_val = "1"
        elif direction == "v": color_style_val = "2"

        overall_success = True
        for base_path in paths:
            log.debug(f"Applying background settings to XFCE path: {base_path}")
            path_apply_success = True
            
            # Sequence of commands for xfconf-query
            commands_to_run = []
            commands_to_run.append(["xfconf-query", "-c", XFCONF_CHANNEL, "-p", f"{base_path}/image-path", "-n", "-t", "string", "-s", ""])
            commands_to_run.append(["xfconf-query", "-c", XFCONF_CHANNEL, "-p", f"{base_path}/image-style", "-n", "-t", "int", "-s", image_style_val])
            commands_to_run.append(["xfconf-query", "-c", XFCONF_CHANNEL, "-p", f"{base_path}/color-style", "-n", "-t", "int", "-s", color_style_val])
            
            # RGBA1: Reset then Set
            commands_to_run.append(["xfconf-query", "-c", XFCONF_CHANNEL, "-p", f"{base_path}/rgba1", "-r"])
            cmd_rgba1_set = ["xfconf-query", "-c", XFCONF_CHANNEL, "-p", f"{base_path}/rgba1", "-n"]
            for val_comp in rgba1_list: cmd_rgba1_set.extend(["-t", "double", "-s", f"{val_comp:.6f}"])
            commands_to_run.append(cmd_rgba1_set)

            # RGBA2: Reset. If gradient, then Set.
            commands_to_run.append(["xfconf-query", "-c", XFCONF_CHANNEL, "-p", f"{base_path}/rgba2", "-r"])
            if rgba2_list: # Only set rgba2 if it's a gradient and rgba2_list is populated
                cmd_rgba2_set = ["xfconf-query", "-c", XFCONF_CHANNEL, "-p", f"{base_path}/rgba2", "-n"]
                for val_comp in rgba2_list: cmd_rgba2_set.extend(["-t", "double", "-s", f"{val_comp:.6f}"])
                commands_to_run.append(cmd_rgba2_set)
            
            commands_to_run.append(["xfconf-query", "-c", XFCONF_CHANNEL, "-p", f"{base_path}/last-image", "-n", "-t", "string", "-s", ""])

            for cmd in commands_to_run:
                code, _, stderr = helpers.run_command(cmd, check=False, capture=True) # Always capture for this
                if code != 0:
                    is_reset_cmd = "-r" in cmd
                    prop_missing_err = "property" in stderr.lower() and "does not exist" in stderr.lower()
                    if is_reset_cmd and prop_missing_err:
                        log.debug(f"Property {cmd[4]} did not exist for reset (ignoring for path {base_path}): {stderr}")
                    else:
                        log.error(f"Failed command for {base_path}: {' '.join(cmd)} - Code: {code}, Stderr: {stderr}")
                        path_apply_success = False
                        break # Stop processing commands for this path if a critical one fails

            if not path_apply_success:
                overall_success = False # If any path fails, mark overall as potentially problematic
                log.warning(f"Settings failed to apply completely for path: {base_path}. Continuing with other paths.")
        
        self.reload_xfdesktop()

        if not overall_success:
            # If any path failed, this indicates an issue.
            # Depending on strictness, this could still be considered a "success" if primary monitor worked.
            # For now, let's log and return true if at least one path succeeded implicitly (no XfceError raised)
            log.warning("Background settings may not have applied to all detected XFCE paths. Check logs.")
            # Raising an error might be too strict if some paths are irrelevant/stale.
            # The critical part is that the *visually active* path gets set.
        else:
            log.info("Background settings applied successfully to all detected XFCE paths.")
        
        return overall_success


    def get_screen_settings(self) -> dict[str, Any]:
        log.debug("Getting screen settings via xsct")
        cmd = ["xsct"]
        try:
            code, stdout, stderr = helpers.run_command(cmd, capture=True)
            if code != 0:
                if "unknown" in stderr.lower() or "usage:" in stderr.lower() or "failed" in stderr.lower():
                    log.info("xsct appears off or failed to query. Assuming default screen settings (temp/bright will be None).")
                    return {"temperature": None, "brightness": None}
                else:
                    raise XfceError(f"xsct command failed unexpectedly (code {code}): {stderr}")

            temp: Optional[int] = None
            brightness: Optional[float] = None
            combined_match = re.search(r"temperature\s+~\s+(\d+)\s+([\d.]+)", stdout, re.IGNORECASE)
            if combined_match:
                log.debug("xsct output matched combined regex pattern.")
                try:
                    temp = int(combined_match.group(1))
                    brightness = float(combined_match.group(2))
                except (ValueError, IndexError) as e:
                    log.warning(f"Could not parse values from combined xsct regex match: {e}. Output: '{stdout}'")
            
            if temp is None or brightness is None: # Try separate if combined failed or didn't match
                log.debug("Combined regex failed or partial, trying separate regexes for xsct.")
                temp_match = re.search(r"(?:temperature|temp)\s*[:~]?\s*(\d+)K?", stdout, re.IGNORECASE)
                bright_match = re.search(r"(?:brightness|bright)\s*[:~]?\s*([\d.]+)", stdout, re.IGNORECASE)
                if temp_match:
                    try: temp = int(temp_match.group(1))
                    except (ValueError, IndexError): log.warning(f"Could not parse temperature from separate xsct match: '{stdout}'")
                else: log.debug(f"No separate temperature pattern in xsct output: '{stdout}'")
                
                if bright_match:
                    try: brightness = float(bright_match.group(1))
                    except (ValueError, IndexError): log.warning(f"Could not parse brightness from separate xsct match: '{stdout}'")
                else: log.debug(f"No separate brightness pattern in xsct output: '{stdout}'")

            if temp is not None and brightness is not None:
                log.info(f"Retrieved screen settings: Temp={temp}, Brightness={brightness:.2f}")
                return {"temperature": temp, "brightness": brightness}
            else: # If either is still None
                log.info(f"Could not parse both temp/brightness from xsct output. Assuming default. Output: '{stdout}'")
                return {"temperature": None, "brightness": None}

        except XfceError: raise
        except Exception as e:
            log.exception(f"Error getting screen settings: {e}")
            raise XfceError(f"An unexpected error occurred getting screen settings: {e}") from e

    def set_screen_temp(self, temp: Optional[int], brightness: Optional[float]) -> bool:
        if temp is not None and brightness is not None:
            if not (1000 <= temp <= 10000):
                raise ValidationError(f"Temperature value {temp}K is outside typical range (1000-10000).")
            if not (0.1 <= brightness <= 2.0): # Looser check for brightness
                log.warning(f"Brightness value {brightness} is outside a very common range (0.1-1.0), but attempting to set.")
            log.info(f"Setting screen: Temp={temp}, Brightness={brightness:.2f}")
            cmd_args = ["xsct", str(temp), f"{brightness:.2f}"]
        else:
            log.info("Resetting screen temperature/brightness (xsct -x)")
            cmd_args = ["xsct", "-x"]
        try:
            code, _, stderr = helpers.run_command(cmd_args, capture=True)
            if code != 0:
                raise XfceError(f"Failed to set screen via xsct: {stderr} (code: {code})")
            log.debug("Successfully set screen temperature/brightness.")
            return True
        except Exception as e:
            if isinstance(e, (XfceError, ValidationError)): raise
            log.exception(f"Error setting screen temperature/brightness: {e}")
            raise XfceError(f"An unexpected error occurred setting screen temperature/brightness: {e}") from e

    def reload_xfdesktop(self):
        log.debug("Reloading xfdesktop...")
        cmd = ["xfdesktop", "--reload"]
        try:
            helpers.check_dependencies(["xfdesktop"])
            subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            # Adding a small delay to give xfdesktop a moment to process the reload.
            # This is a heuristic and might not be sufficient in all system load conditions.
            # If issues persist with background not updating, this delay might be a factor.
            time.sleep(0.5) 
            log.debug("xfdesktop --reload command issued and initial delay passed.")
        except DependencyError:
            log.warning("xfdesktop command not found, skipping reload.")
        except Exception as e: # Catch other Popen errors
            log.warning(f"Exception trying to reload xfdesktop: {e}")

##############
fluxfce_deps_check.py

#!/usr/bin/env python3

import os
import shutil
import subprocess
import sys
from typing import Optional

MIN_PYTHON_VERSION = (3, 9)

# Updated list of command-line dependencies to check
DEPS_TO_CHECK = {
    # command_name: (package_name_suggestion_for_apt, friendly_name)
    "xfconf-query": ("xfce4-utils", "XFCE Configuration tool ('xfconf-query')"),
    "systemctl": ("systemd", "Systemd control tool ('systemctl')"),
    "timedatectl": ("systemd", "Systemd time/date tool ('timedatectl')"),
    "xfdesktop": ("xfdesktop4", "XFCE Desktop manager ('xfdesktop')"),
    "xsct": ("xsct", "Screen Color Temperature tool ('xsct')"),
}

# Fallback package suggestion if xfce4-utils isn't found directly (e.g., part of a meta-package)
XFCE4_UTILS_FALLBACK = "xfce4-session"


# --- Helper Functions ---

def print_info(message: str):
    print(f"[INFO] {message}")

def print_warning(message: str):
    print(f"[WARN] {message}")

def print_error(message: str):
    print(f"[ERROR] {message}")

def print_success(message: str):
    print(f"[OK]   {message}") # Added more space for alignment

def run_command(
    command: list[str], check_exit_code: bool = True, capture_output: bool = False
) -> tuple[int, Optional[str], Optional[str]]:
    """Runs a system command."""
    try:
        process = subprocess.run(
            command,
            check=check_exit_code and not capture_output, # Let CalledProcessError raise if not capturing
            capture_output=capture_output,
            text=True,
            env=os.environ.copy(),
        )
        stdout = process.stdout.strip() if process.stdout else None
        stderr = process.stderr.strip() if process.stderr else None
        
        if capture_output and check_exit_code and process.returncode != 0:
            # Manually raise for captured output if check_exit_code is True and run failed
            raise subprocess.CalledProcessError(
                process.returncode, command, output=stdout, stderr=stderr
            )
        return process.returncode, stdout, stderr
    except FileNotFoundError:
        # This specific error is often critical for expected commands
        print_error(f"Command not found: {command[0]}. Please ensure it is installed and in your PATH.")
        return -1, None, None # Indicate command not found
    except subprocess.CalledProcessError as e:
        stderr_msg = f": {e.stderr}" if e.stderr and e.stderr.strip() else ""
        print_error(
            f"Command '{' '.join(e.cmd)}' failed with exit code {e.returncode}{stderr_msg}"
        )
        return e.returncode, e.stdout, e.stderr
    except Exception as e:
        print_error(
            f"An unexpected error occurred running command '{' '.join(command)}': {e}"
        )
        return -2, None, None # Indicate other unexpected error

def ask_yes_no(prompt: str, default_yes: bool = False) -> bool:
    """Asks a yes/no question and returns True for yes, False for no."""
    suffix = "[Y/n]" if default_yes else "[y/N]"
    while True:
        try:
            response = input(f"{prompt} {suffix}: ").strip().lower()
            if not response:
                return default_yes
            if response in ["y", "yes"]:
                return True
            if response in ["n", "no"]:
                return False
            print_warning("Invalid input. Please enter 'y' or 'n'.")
        except EOFError:
            print()
            return default_yes
        except KeyboardInterrupt:
            print("\nPrompt interrupted. Assuming 'no'.")
            return False

# --- Check Functions ---

def check_python_version() -> bool:
    """Checks if the current Python version meets the minimum requirement."""
    print_info(f"Checking Python version (minimum {MIN_PYTHON_VERSION[0]}.{MIN_PYTHON_VERSION[1]})...")
    if sys.version_info >= MIN_PYTHON_VERSION:
        print_success(f"Python version {sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro} is sufficient.")
        return True
    else:
        print_error(
            f"Python version is {sys.version_info.major}.{sys.version_info.minor}. "
            f"FluxFCE requires Python {MIN_PYTHON_VERSION[0]}.{MIN_PYTHON_VERSION[1]} or newer."
        )
        return False

def check_command_installed(cmd_name: str, friendly_name: str) -> bool:
    """Checks if a command is installed and executable using shutil.which."""
    print_info(f"Checking for {friendly_name} ('{cmd_name}')...")
    path = shutil.which(cmd_name)
    if path:
        print_success(f"{friendly_name} found at: {path}")
        return True
    else:
        print_warning(f"{friendly_name} ('{cmd_name}') NOT found in PATH.")
        return False

# --- Installation Functions ---

def print_manual_xsct_instructions():
    """Prints manual installation instructions for xsct."""
    print_warning("-" * 60)
    print_warning("Manual Installation for 'xsct' might be required.")
    print_warning("If 'sudo apt install xsct' failed or was skipped, you might need to build it from source:")
    print_info("  1. Install build dependencies (example for Debian/Ubuntu):")
    print_info("     sudo apt update")
    print_info("     sudo apt install build-essential libx11-dev libxrandr-dev git")
    print_info("  2. Clone the xsct repository:")
    print_info("     git clone https://github.com/faf0/xsct.git")
    print_info("  3. Compile and install:")
    print_info("     cd xsct")
    print_info("     sudo make install  # Installs to /usr/local/bin by default")
    print_info("     # OR, for user-local install (ensure ~/.local/bin is in PATH):")
    print_info("     # mkdir -p ~/.local/bin && make PREFIX=~/.local install")
    print_warning("-" * 60)

def install_package(
    pkg_name_suggestion: str, cmd_name_being_checked: str, friendly_name: str
) -> bool:
    """
    Attempts to install a package using apt.
    Handles xsct special case for manual instructions.
    Handles xfce4-utils fallback.
    """
    install_prompt = (
        f"Attempt to install '{friendly_name}' (package suggestion: {pkg_name_suggestion}) "
        f"using 'sudo apt install {pkg_name_suggestion}'?"
    )
    if not ask_yes_no(install_prompt, default_yes=True): # Default to yes for convenience
        print_info(f"Skipping installation of {friendly_name}.")
        if cmd_name_being_checked == "xsct":
            print_manual_xsct_instructions()
        return False

    print_info(f"Attempting to install {pkg_name_suggestion}...")
    
    # Offer to run apt update first
    if ask_yes_no("Run 'sudo apt update' first to refresh package lists?", default_yes=True):
        print_info("Running 'sudo apt update'...")
        ret_update, _, _ = run_command(["sudo", "apt", "update"])
        if ret_update != 0:
            print_warning("Failed to run 'sudo apt update'. Package lists may be outdated. Continuing install attempt...")
    else:
        print_info("Skipping 'apt update'.")

    ret_install, _, _ = run_command(["sudo", "apt", "install", "-y", pkg_name_suggestion])
    
    if ret_install == 0:
        print_success(f"Successfully installed package '{pkg_name_suggestion}' for {friendly_name}.")
        # Verify the command is now available
        if shutil.which(cmd_name_being_checked):
            print_success(f"Command '{cmd_name_being_checked}' is now available.")
            return True
        else:
            print_warning(f"Package '{pkg_name_suggestion}' installed, but command '{cmd_name_being_checked}' still not found. This is unexpected.")
            return False # Command still not found
    else:
        print_error(f"Failed to install package '{pkg_name_suggestion}' for {friendly_name}.")
        if cmd_name_being_checked == "xsct":
            print_info("The package 'xsct' might not be available in your system's default repositories or installation failed.")
            print_manual_xsct_instructions()
        elif cmd_name_being_checked == "xfconf-query" and pkg_name_suggestion == "xfce4-utils":
            print_info(f"Trying fallback package '{XFCE4_UTILS_FALLBACK}' for XFCE utilities.")
            # Recursive call for the fallback package.
            return install_package(XFCE4_UTILS_FALLBACK, cmd_name_being_checked, friendly_name)
        return False

# --- Main Logic ---
def main():
    print_info("FluxFCE Dependency Checker for Debian/Ubuntu-based systems")
    print_info("(Focuses on command-line tools needed by FluxFCE core)")
    print_info("=" * 60)

    if not shutil.which("apt"):
        print_warning("This script's package installation suggestions use 'apt'.")
        print_warning("If you are on a non-APT system, you'll need to install dependencies manually.")
        # Continue with checks, but installation attempts might not be relevant.

    if os.geteuid() == 0:
        print_warning(
            "This script is not designed to be run as root, though it will invoke 'sudo' "
            "for package installations if you permit."
        )
        if not ask_yes_no("Continue anyway?", default_yes=False):
            sys.exit(1)

    all_deps_ok_initially = True
    missing_commands_to_resolve: dict[str, tuple[str, str]] = {} # cmd_name: (pkg_suggestion, friendly_name)

    # 1. Check Python Version
    if not check_python_version():
        all_deps_ok_initially = False
        # This is a critical failure for FluxFCE itself.
        print_error("Please upgrade Python before proceeding with FluxFCE installation.")
        # Exiting early if Python version is insufficient, as fluxfce_cli.py won't run.
        # sys.exit(1) # Or choose to report all other missing deps first. Let's report all.

    # 2. Check Commands
    print_info("\n--- Checking for required command-line tools ---")
    for cmd, (pkg_suggestion, friendly) in DEPS_TO_CHECK.items():
        if not check_command_installed(cmd, friendly):
            all_deps_ok_initially = False
            if cmd not in missing_commands_to_resolve: # Avoid duplicates if somehow listed twice
                missing_commands_to_resolve[cmd] = (pkg_suggestion, friendly)
    
    print_info("-" * 60)
    if all_deps_ok_initially:
        print_success("All checked dependencies appear to be OK!")
        print_info("Note: Core system utilities (like 'python3', 'mkdir', 'ln') are assumed to be present.")
        sys.exit(0)
    else:
        print_warning("Some dependencies require attention.")

    # 3. Attempt to Install Missing Items
    if missing_commands_to_resolve:
        print_info("\n--- Attempting to resolve missing dependencies ---")
        # Prioritize xsct for special handling/messaging if apt install fails
        if "xsct" in missing_commands_to_resolve:
            pkg_sugg, friendly_name = missing_commands_to_resolve.pop("xsct")
            install_package(pkg_sugg, "xsct", friendly_name)
            # Re-check xsct specifically, as its installation can be manual
            if check_command_installed("xsct", DEPS_TO_CHECK["xsct"][1]):
                 print_success("'xsct' is now available.")
            else:
                 print_warning("'xsct' still appears to be unavailable after installation attempt.")
                 # Manual instructions were already printed by install_package on failure.

        # Attempt to install other missing packages
        for cmd_name, (pkg_sugg, friendly_name) in missing_commands_to_resolve.items():
            # Check again in case a previous install provided this command (e.g., meta-package)
            if not shutil.which(cmd_name):
                install_package(pkg_sugg, cmd_name, friendly_name)
    else:
        print_info("No missing command-line tools to attempt to install (or user skipped previous prompts).")

    print_info("-" * 60)
    # Final verification
    print_info("Re-verifying all dependencies after installation attempts...")
    final_all_ok = True
    if not check_python_version(): # Re-check Python version
        final_all_ok = False

    for cmd, (_, friendly) in DEPS_TO_CHECK.items():
        if not check_command_installed(cmd, friendly):
            final_all_ok = False
            if cmd == "xsct":
                print_warning(f"'{cmd}' ({friendly}) is still missing. Manual installation might be required (see instructions above if printed).")
            else:
                print_warning(f"'{cmd}' ({friendly}) is still missing. Please install it manually.")


    print_info("-" * 60)
    if final_all_ok:
        print_success("All critical dependencies appear to be satisfied now!")
        sys.exit(0)
    else:
        print_error("One or more critical dependencies are still missing after installation attempts.")
        print_error("Please review the output above and install them manually.")
        sys.exit(1)

if __name__ == "__main__":
    main()

##############
fluxfce_gui.py


##############
pyproject.toml

[tool.ruff]
line-length = 88
indent-width = 4
target-version = "py39"

[tool.ruff.lint]
select = [
    "E", "F", "W", "I", "UP", "B", "C90", "SIM", "TID", "RUF",
]
ignore = ["B008", "E501"]
fixable = ["ALL"]
unfixable = []
dummy-variable-rgx = "^(_+|(_+[a-zA-Z0-9_]*[a-zA-Z0-9]+?))$"

[tool.ruff.lint.isort]
known-first-party = ["fluxfce_core", "fluxfce_dependency_setup"]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
skip-magic-trailing-comma = false
line-ending = "auto"
docstring-code-format = true
docstring-code-line-length = "dynamic"

##############
readme.md

# fluxfce - XFCE Auto-Theming Utility

**Fluxfce** automates switching XFCE desktop appearance (GTK Theme, Background Color/Gradient, Screen Temperature/Brightness) between user-defined Day and Night modes at sunrise and sunset times. It uses an adapted NOAA algorithm to calculate transition times. **Systemd user timers** are used for precise, low-resource scheduling.

This is a refactored and simplified version focusing on core functionality, reliability, and maintainability.

<p align="center">
  <img src="logo.png" alt="fluxfce Logo Placeholder" width="150">
</p>

---

## Features

- **Automatic Switching:** Automatically transitions between Day and Night modes at local sunrise and sunset.
- **Easy Default Setting:** Save your current desktop look as the new default for Day or Night mode (`fluxfce set-default --mode day`).
- **Component Control:** Adjusts:
  - GTK Theme (`Net/ThemeName`)
  - Desktop Background (Solid color or vertical/horizontal gradient via `xfce4-desktop` properties)
  - Screen Temperature & Brightness (via `xsct`)
- **Location Aware:** Calculates sunrise/sunset times based on user-configured latitude, longitude, and IANA timezone.
- **Timezone Detection:** Attempts to automatically detect system timezone during initial install.
- **Low Resource Usage:** Uses systemd user timers, avoiding a persistent custom background daemon.
- **Systemd Integration:** Installs systemd user units (`.timer`, `.service`) for:
    - Daily rescheduling of sunrise/sunset event timers.
    - Triggering theme transitions at precise sunrise/sunset times.
    - Applying the correct theme on login and resume from suspend.
- **Manual Overrides:** Easily force Day or Night mode (`force-day`, `force-night`). Manual overrides disable automatic scheduling.
- **Simple Configuration:** Uses a clear INI file (`~/.config/fluxfce/config.ini`).
- **Status Reporting:** Check current configuration, calculated times, and systemd timer status (`status`).

## Requirements

- **Linux Distribution:** Designed for XFCE distributions with systemd.
  - **Primary Targets:** Ubuntu 22.04+ (Xubuntu), Linux Mint 21.x+ (XFCE), Debian 11+ (XFCE).
  - *May work on other systemd-based XFCE distributions (e.g., Fedora XFCE, Arch XFCE) with adjustments to package names for dependencies.*
- **Desktop Environment:** XFCE 4.x
- **Python:** Python 3.9+ (due to `zoneinfo` usage).
- **System Tools & Services (Dependencies):**
  - **`systemd`:** User instance must be operational.
  - **`xsct`:** For screen temperature and brightness control.
    - Installation on **Ubuntu 24.04 (Noble Numbat) and newer (or equivalent Linux Mint/Debian versions)**:
      ```bash
      sudo apt update
      sudo apt install xsct
      ```
  - **Core XFCE/System Tools** (Usually pre-installed on XFCE systems):
    - `xfconf-query` (from `xfce4-utils` or similar)
    - `xfdesktop` (from `xfdesktop4` or similar, for background reloads)
    - `timedatectl` (part of systemd)

## Installation

1.  **Clone the repository (or download the source code):**
    ```bash
    git clone https://github.com/camdoherty/fluxfce-simplified.git
    cd fluxfce
    ```

2.  **Run the install command:**
    ```bash
    python3 fluxfce_cli.py install
    ```
    The script will:
    *   Check for Python version.
    *   Check for required system dependencies using `fluxfce_deps_check.py` and guide you through installing missing ones (like `xsct` via `apt`).
    *   Prompt you for location (latitude/longitude) and attempt to detect your timezone for accurate sun time calculations if a configuration file doesn't exist.
    *   Install systemd user units for automatic operation.
    *   Enable scheduling, which sets up timers for the next sunrise/sunset and ensures the current desktop appearance matches the current solar period.

3.  **Make the `fluxfce` command easily accessible (if not using `pip install .` in the future):**
    The `install` script will provide instructions. A common method is:
    *   Ensure `~/.local/bin` is in your `PATH`. Add if necessary:
        ```bash
        # Add to your ~/.bashrc or ~/.zshrc, then source it or restart terminal
        export PATH="$HOME/.local/bin:$PATH"
        ```
    *   Make the main script executable:
        ```bash
        chmod +x ./fluxfce_cli.py
        ```
    *   Create a symbolic link:
        ```bash
        SCRIPT_ABS_PATH=$(readlink -f ./fluxfce_cli.py) # Or use: SCRIPT_ABS_PATH=$(pwd)/fluxfce_cli.py
        mkdir -p ~/.local/bin
        ln -s -f "$SCRIPT_ABS_PATH" ~/.local/bin/fluxfce # -f forces overwrite if symlink exists
        ```

4.  **(Recommended) Configure Day/Night Appearance:**
    Set your desired XFCE theme, background color/gradient, and screen temperature/brightness for **Daytime**, then run:
    ```bash
    fluxfce set-default --mode day
    ```
    Then, set your desired look for **Nighttime**, and run:
    ```bash
    fluxfce set-default --mode night
    ```
    `fluxfce` will save these settings to its configuration file. When `fluxfce enable` is run, or when the scheduled transitions occur, these configured settings will be applied.

## Usage

```bash
fluxfce <command> [options]
```

**Commands:**
- `install` — Performs dependency checks, interactive setup (if needed), installs systemd units, and enables automatic scheduling.
- `uninstall` — Removes systemd units and clears schedule (prompts to remove config).
- `enable` — Enables automatic scheduling (sets up systemd timers for sunrise/sunset and ensures current appearance matches the solar period).
- `disable` — Disable automatic scheduling (stops and disables relevant systemd timers).
- `status` — Show config, calculated times, and systemd timer/service status.
- `force-day` — Apply Day Mode settings now (disables automatic scheduling).
- `force-night` — Apply Night Mode settings now (disables automatic scheduling).
- `set-default --mode {day,night}` — Save current desktop look as the new default for Day or Night mode.

**Options:**
- `-h`, `--help` — Show this help message and exit.
- `-v`, `--verbose` — Enable detailed logging output for `fluxfce` operations.

## Configuration

Fluxfce uses an INI file located at `~/.config/fluxfce/config.ini`.
The `fluxfce install` command will help you create this initially. You can edit it manually later.

**Example `config.ini`:**
```ini
[Location]
latitude = 43.65N
longitude = 79.38W
timezone = America/Toronto

[Themes]
light_theme = Adwaita
dark_theme = Adwaita-dark

[BackgroundDay]
bg_dir = v
bg_hex1 = ADD8E6
bg_hex2 = 87CEEB

[ScreenDay]
xsct_temp = 6500
xsct_bright = 1.0

[BackgroundNight]
bg_dir = v
bg_hex1 = 1E1E2E
bg_hex2 = 000000

[ScreenNight]
xsct_temp = 4500
xsct_bright = 0.85
```

- **`bg_dir` (Background Direction):**
  - `s` = Solid color (uses `bg_hex1` only)
  - `h` = Horizontal gradient (uses `bg_hex1` and `bg_hex2`)
  - `v` = Vertical gradient (uses `bg_hex1` and `bg_hex2`)
- **`xsct_temp` (Screen Temperature):** In Kelvin (e.g., 3700, 6500). If empty for Day mode, `xsct` typically resets to its default (temperature and brightness are usually reset together for day mode if either is empty).
- **`xsct_bright` (Screen Brightness):** Factor (e.g., 0.8, 1.0). If empty for Day mode, `xsct` typically resets to its default.

## Troubleshooting

- **Verbose Output:** Always try running `fluxfce` with the `-v` flag first to get more detailed logs:
  ```bash
  fluxfce -v status
  fluxfce -v enable
  # etc.
  ```
- **Dependency Check Script:**
  The `fluxfce install` command runs `fluxfce_deps_check.py` automatically. If you need to re-run it manually (e.g., after system changes):
  ```bash
  python3 ./fluxfce_deps_check.py 
  ```
  (Assuming `fluxfce_deps_check.py` is in the same directory as `fluxfce_cli.py`).

- **Systemd User Units & Timers:**
  - **List FluxFCE Timers:** See if `fluxfce` timers are scheduled and their next run times:
    ```bash
    systemctl --user list-timers --all | grep fluxfce
    ```
  - **Check Status of Specific FluxFCE Units:** (Replace `fluxfce-unit-name` with the actual unit, e.g., `fluxfce-scheduler.timer` or `fluxfce-apply-transition@day.service`)
    ```bash
    systemctl --user status fluxfce-unit-name
    ```
    Common units to check: `fluxfce-scheduler.timer`, `fluxfce-scheduler.service`, `fluxfce-sunrise-event.timer`, `fluxfce-sunset-event.timer`, `fluxfce-apply-transition@day.service`, `fluxfce-apply-transition@night.service`, `fluxfce-login.service`, `fluxfce-resume.service`.
  - **View Journal Logs for Specific Units:** For detailed error messages:
    ```bash
    journalctl --user -u fluxfce-scheduler.service -e --no-pager
    journalctl --user -u fluxfce-apply-transition@day.service -e --no-pager 
    # etc. for other fluxfce units. '-e' jumps to end, '--no-pager' prints to console.
    ```

- **Configuration File Path:** Ensure your config is at `~/.config/fluxfce/config.ini`.

- **Manual Theme Application Test (via Systemd Service):** To test if a specific mode application service is working correctly:
  ```bash
  # Ensure you are in the opposite mode first (e.g., run 'fluxfce force-day')
  # Then to test night mode application:
  systemctl --user start fluxfce-apply-transition@night.service
  # Check your desktop. Then check the journal for this unit if issues occurred:
  # journalctl --user -u fluxfce-apply-transition@night.service -e --no-pager
  ```

## License

MIT

